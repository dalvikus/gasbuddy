/*!
 * deCarta JavaScript Mapping API
 * Copyright 2006-2012 deCarta. All rights reserved.
 * version DDS 5.1
 *
 * Bundles:
 *   Raphael
 *   Project: http://raphaeljs.com/
 *   License: MIT License
 *
 *   Sarissa
 *   Project: http://dev.abiss.gr/sarissa/
 *   License: Apache 2.0
 *   License Location: http://dev.abiss.gr/sarissa/licenses/asl.txt
 */

/*
 * Raphael 1.5.2 - JavaScript Vector Library
 *
 * Copyright (c) 2010 Dmitry Baranovskiy (http://raphaeljs.com)
 * Licensed under the MIT (http://raphaeljs.com/license.html) license.
 */
(function(){function a(){if(a.is(arguments[0],G)){var b=arguments[0],d=bV[m](a,b.splice(0,3+a.is(b[0],E))),e=d.set();for(var g=0,h=b[w];g<h;g++){var i=b[g]||{};c[f](i.type)&&e[L](d[i.type]().attr(i))}return e}return bV[m](a,arguments)}a.version="1.5.2";var b=/[, ]+/,c={circle:1,rect:1,path:1,ellipse:1,text:1,image:1},d=/\{(\d+)\}/g,e="prototype",f="hasOwnProperty",g=document,h=window,i={was:Object[e][f].call(h,"Raphael"),is:h.Raphael},j= function(){this.customAttributes={}},k,l="appendChild",m="apply",n="concat",o="createTouch"in g,p="",q=" ",r=String,s="split",t="click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend orientationchange touchcancel gesturestart gesturechange gestureend"[s](q),u={mousedown:"touchstart",mousemove:"touchmove",mouseup:"touchend"},v="join",w="length",x=r[e].toLowerCase,y=Math,z=y.max,A=y.min,B=y.abs,C=y.pow,D=y.PI,E="number",F="string",G="array",H="toString",I="fill",J=Object[e][H],K={},L="push",M=/^url\(['"]?([^\)]+?)['"]?\)$/i,N=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,O={"NaN":1,Infinity:1,"-Infinity":1},P=/^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,Q=y.round,R="setAttribute",S=parseFloat,T=parseInt,U=" progid:DXImageTransform.Microsoft",V=r[e].toUpperCase,W={blur:0,"clip-rect":"0 0 1e9 1e9",cursor:"default",cx:0,cy:0,fill:"#fff","fill-opacity":1,font:"10px \"Arial\"","font-family":"\"Arial\"","font-size":"10","font-style":"normal","font-weight":400,gradient:0,height:0,href:"http://raphaeljs.com/",opacity:1,path:"M0,0",r:0,rotation:0,rx:0,ry:0,scale:"1 1",src:"",stroke:"#000","stroke-dasharray":"","stroke-linecap":"butt","stroke-linejoin":"butt","stroke-miterlimit":0,"stroke-opacity":1,"stroke-width":1,target:"_blank","text-anchor":"middle",title:"Raphael",translation:"0 0",width:0,x:0,y:0},X={along:"along",blur:E,"clip-rect":"csv",cx:E,cy:E,fill:"colour","fill-opacity":E,"font-size":E,height:E,opacity:E,path:"path",r:E,rotation:"csv",rx:E,ry:E,scale:"csv",stroke:"colour","stroke-opacity":E,"stroke-width":E,translation:"csv",width:E,x:E,y:E},Y="replace",Z=/^(from|to|\d+%?)$/,$=/\s*,\s*/,_={hs:1,rg:1},ba=/,?([achlmqrstvxz]),?/gi,bb=/([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,bc=/(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,bd=/^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/,be= function(a,b){return a.key-b.key};a.type=h.SVGAngle||g.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")?"SVG":"VML";if(a.type=="VML"){var bf=g.createElement("div"),bg;bf.innerHTML="<v:shape adj=\"1\"/>";bg=bf.firstChild;bg.style.behavior="url(#default#VML)";if(!(bg&&typeof bg.adj=="object"))return a.type=null;bf=null}a.svg=!(a.vml=a.type=="VML");j[e]=a[e];k=j[e];a._id=0;a._oid=0;a.fn={};a.is= function(a,b){b=x.call(b);if(b=="finite")return!O[f](+a);return b=="null"&&a===null||b==typeof a||b=="object"&&a===Object(a)||b=="array"&&Array.isArray&&Array.isArray(a)||J.call(a).slice(8,-1).toLowerCase()==b};a.angle= function(b,c,d,e,f,g){{if(f==null){var h=b-d,i=c-e;if(!h&&!i)return 0;return((h<0)*180+y.atan(-i/-h)*180/D+360)%360}return a.angle(b,c,f,g)-a.angle(d,e,f,g)}};a.rad= function(a){return a%360*D/180};a.deg= function(a){return a*180/D%360};a.snapTo= function(b,c,d){d=a.is(d,"finite")?d:10;if(a.is(b,G)){var e=b.length;while(e--)if(B(b[e]-c)<=d)return b[e]}else{b=+b;var f=c%b;if(f<d)return c-f;if(f>b-d)return c-f+b}return c};function bh(){var a=[],b=0;for(;b<32;b++)a[b]=(~(~(y.random()*16)))[H](16);a[12]=4;a[16]=(a[16]&3|8)[H](16);return"r-"+a[v]("")}a.setWindow= function(a){h=a;g=h.document};var bi= function(b){if(a.vml){var c=/^\s+|\s+$/g,d;try{var e=new ActiveXObject("htmlfile");e.write("<body>");e.close();d=e.body}catch(a){d=createPopup().document.body}var f=d.createTextRange();bi=bm(function(a){try{d.style.color=r(a)[Y](c,p);var b=f.queryCommandValue("ForeColor");b=(b&255)<<16|b&65280|(b&16711680)>>>16;return"#"+("000000"+b[H](16)).slice(-6)}catch(a){return"none"}})}else{var h=g.createElement("i");h.title="Raphaël Colour Picker";h.style.display="none";g.body[l](h);bi=bm(function(a){h.style.color=a;return g.defaultView.getComputedStyle(h,p).getPropertyValue("color")})}return bi(b)},bj= function(){return"hsb("+[this.h,this.s,this.b]+")"},bk= function(){return"hsl("+[this.h,this.s,this.l]+")"},bl= function(){return this.hex};a.hsb2rgb= function(b,c,d,e){if(a.is(b,"object")&&"h"in b&&"s"in b&&"b"in b){d=b.b;c=b.s;b=b.h;e=b.o}return a.hsl2rgb(b,c,d/2,e)};a.hsl2rgb= function(b,c,d,e){if(a.is(b,"object")&&"h"in b&&"s"in b&&"l"in b){d=b.l;c=b.s;b=b.h}if(b>1||c>1||d>1){b/=360;c/=100;d/=100}var f={},g=["r","g","b"],h,i,j,k,l,m;if(c){d<0.5?h=d*(1+c):h=d+c-d*c;i=2*d-h;for(var n=0;n<3;n++){j=b+1/3*-(n-1);j<0&&j++;j>1&&j--;j*6<1?f[g[n]]=i+(h-i)*6*j:j*2<1?f[g[n]]=h:j*3<2?f[g[n]]=i+(h-i)*(2/3-j)*6:f[g[n]]=i}}else f={r:d,g:d,b:d};f.r*=255;f.g*=255;f.b*=255;f.hex="#"+(16777216|f.b|f.g<<8|f.r<<16).toString(16).slice(1);a.is(e,"finite")&&(f.opacity=e);f.toString=bl;return f};a.rgb2hsb= function(b,c,d){if(c==null&&a.is(b,"object")&&"r"in b&&"g"in b&&"b"in b){d=b.b;c=b.g;b=b.r}if(c==null&&a.is(b,F)){var e=a.getRGB(b);b=e.r;c=e.g;d=e.b}if(b>1||c>1||d>1){b/=255;c/=255;d/=255}var f=z(b,c,d),g=A(b,c,d),h,i,j=f;{if(g==f)return{h:0,s:0,b:f,toString:bj};var k=f-g;i=k/f;b==f?h=(c-d)/k:c==f?h=2+(d-b)/k:h=4+(b-c)/k;h/=6;h<0&&h++;h>1&&h--}return{h:h,s:i,b:j,toString:bj}};a.rgb2hsl= function(b,c,d){if(c==null&&a.is(b,"object")&&"r"in b&&"g"in b&&"b"in b){d=b.b;c=b.g;b=b.r}if(c==null&&a.is(b,F)){var e=a.getRGB(b);b=e.r;c=e.g;d=e.b}if(b>1||c>1||d>1){b/=255;c/=255;d/=255}var f=z(b,c,d),g=A(b,c,d),h,i,j=(f+g)/2,k;if(g==f)k={h:0,s:0,l:j};else{var l=f-g;i=j<0.5?l/(f+g):l/(2-f-g);b==f?h=(c-d)/l:c==f?h=2+(d-b)/l:h=4+(b-c)/l;h/=6;h<0&&h++;h>1&&h--;k={h:h,s:i,l:j}}k.toString=bk;return k};a._path2string= function(){return this.join(",")[Y](ba,"$1")};function bm(a,b,c){function d(){var g=Array[e].slice.call(arguments,0),h=g[v]("?"),i=d.cache=d.cache||{},j=d.count=d.count||[];if(i[f](h))return c?c(i[h]):i[h];j[w]>=1000&&delete i[j.shift()];j[L](h);i[h]=a[m](b,g);return c?c(i[h]):i[h]}return d}a.getRGB=bm(function(b){if(!b||!(!((b=r(b)).indexOf("-")+1)))return{r:-1,g:-1,b:-1,hex:"none",error:1};if(b=="none")return{r:-1,g:-1,b:-1,hex:"none"};!(_[f](b.toLowerCase().substring(0,2))||b.charAt()=="#")&&(b=bi(b));var c,d,e,g,h,i,j,k=b.match(N);if(k){if(k[2]){g=T(k[2].substring(5),16);e=T(k[2].substring(3,5),16);d=T(k[2].substring(1,3),16)}if(k[3]){g=T((i=k[3].charAt(3))+i,16);e=T((i=k[3].charAt(2))+i,16);d=T((i=k[3].charAt(1))+i,16)}if(k[4]){j=k[4][s]($);d=S(j[0]);j[0].slice(-1)=="%"&&(d*=2.55);e=S(j[1]);j[1].slice(-1)=="%"&&(e*=2.55);g=S(j[2]);j[2].slice(-1)=="%"&&(g*=2.55);k[1].toLowerCase().slice(0,4)=="rgba"&&(h=S(j[3]));j[3]&&j[3].slice(-1)=="%"&&(h/=100)}if(k[5]){j=k[5][s]($);d=S(j[0]);j[0].slice(-1)=="%"&&(d*=2.55);e=S(j[1]);j[1].slice(-1)=="%"&&(e*=2.55);g=S(j[2]);j[2].slice(-1)=="%"&&(g*=2.55);(j[0].slice(-3)=="deg"||j[0].slice(-1)=="°")&&(d/=360);k[1].toLowerCase().slice(0,4)=="hsba"&&(h=S(j[3]));j[3]&&j[3].slice(-1)=="%"&&(h/=100);return a.hsb2rgb(d,e,g,h)}if(k[6]){j=k[6][s]($);d=S(j[0]);j[0].slice(-1)=="%"&&(d*=2.55);e=S(j[1]);j[1].slice(-1)=="%"&&(e*=2.55);g=S(j[2]);j[2].slice(-1)=="%"&&(g*=2.55);(j[0].slice(-3)=="deg"||j[0].slice(-1)=="°")&&(d/=360);k[1].toLowerCase().slice(0,4)=="hsla"&&(h=S(j[3]));j[3]&&j[3].slice(-1)=="%"&&(h/=100);return a.hsl2rgb(d,e,g,h)}k={r:d,g:e,b:g};k.hex="#"+(16777216|g|e<<8|d<<16).toString(16).slice(1);a.is(h,"finite")&&(k.opacity=h);return k}return{r:-1,g:-1,b:-1,hex:"none",error:1}},a);a.getColor= function(a){var b=this.getColor.start=this.getColor.start||{h:0,s:1,b:a||0.75},c=this.hsb2rgb(b.h,b.s,b.b);b.h+=0.075;if(b.h>1){b.h=0;b.s-=0.2;b.s<=0&&(this.getColor.start={h:0,s:1,b:b.b})}return c.hex};a.getColor.reset= function(){delete this.start};a.parsePathString=bm(function(b){if(!b)return null;var c={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},d=[];a.is(b,G)&&a.is(b[0],G)&&(d=bo(b));d[w]||r(b)[Y](bb,function(a,b,e){var f=[],g=x.call(b);e[Y](bc,function(a,b){b&&f[L](+b)});if(g=="m"&&f[w]>2){d[L]([b][n](f.splice(0,2)));g="l";b=b=="m"?"l":"L"}while(f[w]>=c[g]){d[L]([b][n](f.splice(0,c[g])));if(!c[g])break}});d[H]=a._path2string;return d});a.findDotsAtSegment= function(a,b,c,d,e,f,g,h,i){var j=1-i,k=C(j,3)*a+C(j,2)*3*i*c+j*3*i*i*e+C(i,3)*g,l=C(j,3)*b+C(j,2)*3*i*d+j*3*i*i*f+C(i,3)*h,m=a+2*i*(c-a)+i*i*(e-2*c+a),n=b+2*i*(d-b)+i*i*(f-2*d+b),o=c+2*i*(e-c)+i*i*(g-2*e+c),p=d+2*i*(f-d)+i*i*(h-2*f+d),q=(1-i)*a+i*c,r=(1-i)*b+i*d,s=(1-i)*e+i*g,t=(1-i)*f+i*h,u=90-y.atan((m-o)/(n-p))*180/D;(m>o||n<p)&&(u+=180);return{x:k,y:l,m:{x:m,y:n},n:{x:o,y:p},start:{x:q,y:r},end:{x:s,y:t},alpha:u}};var bn=bm(function(a){if(!a)return{x:0,y:0,width:0,height:0};a=bw(a);var b=0,c=0,d=[],e=[],f;for(var g=0,h=a[w];g<h;g++){f=a[g];if(f[0]=="M"){b=f[1];c=f[2];d[L](b);e[L](c)}else{var i=bv(b,c,f[1],f[2],f[3],f[4],f[5],f[6]);d=d[n](i.min.x,i.max.x);e=e[n](i.min.y,i.max.y);b=f[5];c=f[6]}}var j=A[m](0,d),k=A[m](0,e);return{x:j,y:k,width:z[m](0,d)-j,height:z[m](0,e)-k}}),bo= function(b){var c=[];if(!a.is(b,G)||!a.is(b&&b[0],G))b=a.parsePathString(b);for(var d=0,e=b[w];d<e;d++){c[d]=[];for(var f=0,g=b[d][w];f<g;f++)c[d][f]=b[d][f]}c[H]=a._path2string;return c},bp=bm(function(b){if(!a.is(b,G)||!a.is(b&&b[0],G))b=a.parsePathString(b);var c=[],d=0,e=0,f=0,g=0,h=0;if(b[0][0]=="M"){d=b[0][1];e=b[0][2];f=d;g=e;h++;c[L](["M",d,e])}for(var i=h,j=b[w];i<j;i++){var k=c[i]=[],l=b[i];if(l[0]!=x.call(l[0])){k[0]=x.call(l[0]);switch(k[0]){case"a":k[1]=l[1];k[2]=l[2];k[3]=l[3];k[4]=l[4];k[5]=l[5];k[6]=+(l[6]-d).toFixed(3);k[7]=+(l[7]-e).toFixed(3);break;case"v":k[1]=+(l[1]-e).toFixed(3);break;case"m":f=l[1];g=l[2];default:for(var m=1,n=l[w];m<n;m++)k[m]=+(l[m]-(m%2?d:e)).toFixed(3)}}else{k=c[i]=[];if(l[0]=="m"){f=l[1]+d;g=l[2]+e}for(var o=0,p=l[w];o<p;o++)c[i][o]=l[o]}var q=c[i][w];switch(c[i][0]){case"z":d=f;e=g;break;case"h":d+=+c[i][q-1];break;case"v":e+=+c[i][q-1];break;default:d+=+c[i][q-2];e+=+c[i][q-1]}}c[H]=a._path2string;return c},0,bo),bq=bm(function(b){if(!a.is(b,G)||!a.is(b&&b[0],G))b=a.parsePathString(b);var c=[],d=0,e=0,f=0,g=0,h=0;if(b[0][0]=="M"){d=+b[0][1];e=+b[0][2];f=d;g=e;h++;c[0]=["M",d,e]}for(var i=h,j=b[w];i<j;i++){var k=c[i]=[],l=b[i];if(l[0]!=V.call(l[0])){k[0]=V.call(l[0]);switch(k[0]){case"A":k[1]=l[1];k[2]=l[2];k[3]=l[3];k[4]=l[4];k[5]=l[5];k[6]=+(l[6]+d);k[7]=+(l[7]+e);break;case"V":k[1]=+l[1]+e;break;case"H":k[1]=+l[1]+d;break;case"M":f=+l[1]+d;g=+l[2]+e;default:for(var m=1,n=l[w];m<n;m++)k[m]=+l[m]+(m%2?d:e)}}else for(var o=0,p=l[w];o<p;o++)c[i][o]=l[o];switch(k[0]){case"Z":d=f;e=g;break;case"H":d=k[1];break;case"V":e=k[1];break;case"M":f=c[i][c[i][w]-2];g=c[i][c[i][w]-1];default:d=c[i][c[i][w]-2];e=c[i][c[i][w]-1]}}c[H]=a._path2string;return c},null,bo),br= function(a,b,c,d){return[a,b,c,d,c,d]},bs= function(a,b,c,d,e,f){var g=1/3,h=2/3;return[g*a+h*c,g*b+h*d,g*e+h*c,g*f+h*d,e,f]},bt= function(a,b,c,d,e,f,g,h,i,j){var k=D*120/180,l=D/180*(+e||0),m=[],o,p=bm(function(a,b,c){var d=a*y.cos(c)-b*y.sin(c),e=a*y.sin(c)+b*y.cos(c);return{x:d,y:e}});if(j){G=j[0];H=j[1];E=j[2];F=j[3]}else{o=p(a,b,-l);a=o.x;b=o.y;o=p(h,i,-l);h=o.x;i=o.y;var q=y.cos(D/180*e),r=y.sin(D/180*e),t=(a-h)/2,u=(b-i)/2,x=t*t/(c*c)+u*u/(d*d);if(x>1){x=y.sqrt(x);c=x*c;d=x*d}var z=c*c,A=d*d,C=(f==g?-1:1)*y.sqrt(B((z*A-z*u*u-A*t*t)/(z*u*u+A*t*t))),E=C*c*u/d+(a+h)/2,F=C*-d*t/c+(b+i)/2,G=y.asin(((b-F)/d).toFixed(9)),H=y.asin(((i-F)/d).toFixed(9));G=a<E?D-G:G;H=h<E?D-H:H;G<0&&(G=D*2+G);H<0&&(H=D*2+H);g&&G>H&&(G=G-D*2);!g&&H>G&&(H=H-D*2)}var I=H-G;if(B(I)>k){var J=H,K=h,L=i;H=G+k*(g&&H>G?1:-1);h=E+c*y.cos(H);i=F+d*y.sin(H);m=bt(h,i,c,d,e,0,g,K,L,[H,J,E,F])}I=H-G;var M=y.cos(G),N=y.sin(G),O=y.cos(H),P=y.sin(H),Q=y.tan(I/4),R=4/3*c*Q,S=4/3*d*Q,T=[a,b],U=[a+R*N,b-S*M],V=[h+R*P,i-S*O],W=[h,i];U[0]=2*T[0]-U[0];U[1]=2*T[1]-U[1];{if(j)return[U,V,W][n](m);m=[U,V,W][n](m)[v]()[s](",");var X=[];for(var Y=0,Z=m[w];Y<Z;Y++)X[Y]=Y%2?p(m[Y-1],m[Y],l).y:p(m[Y],m[Y+1],l).x;return X}},bu= function(a,b,c,d,e,f,g,h,i){var j=1-i;return{x:C(j,3)*a+C(j,2)*3*i*c+j*3*i*i*e+C(i,3)*g,y:C(j,3)*b+C(j,2)*3*i*d+j*3*i*i*f+C(i,3)*h}},bv=bm(function(a,b,c,d,e,f,g,h){var i=e-2*c+a-(g-2*e+c),j=2*(c-a)-2*(e-c),k=a-c,l=(-j+y.sqrt(j*j-4*i*k))/2/i,n=(-j-y.sqrt(j*j-4*i*k))/2/i,o=[b,h],p=[a,g],q;B(l)>"1e12"&&(l=0.5);B(n)>"1e12"&&(n=0.5);if(l>0&&l<1){q=bu(a,b,c,d,e,f,g,h,l);p[L](q.x);o[L](q.y)}if(n>0&&n<1){q=bu(a,b,c,d,e,f,g,h,n);p[L](q.x);o[L](q.y)}i=f-2*d+b-(h-2*f+d);j=2*(d-b)-2*(f-d);k=b-d;l=(-j+y.sqrt(j*j-4*i*k))/2/i;n=(-j-y.sqrt(j*j-4*i*k))/2/i;B(l)>"1e12"&&(l=0.5);B(n)>"1e12"&&(n=0.5);if(l>0&&l<1){q=bu(a,b,c,d,e,f,g,h,l);p[L](q.x);o[L](q.y)}if(n>0&&n<1){q=bu(a,b,c,d,e,f,g,h,n);p[L](q.x);o[L](q.y)}return{min:{x:A[m](0,p),y:A[m](0,o)},max:{x:z[m](0,p),y:z[m](0,o)}}}),bw=bm(function(a,b){var c=bq(a),d=b&&bq(b),e={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},f={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},g= function(a,b){var c,d;if(!a)return["C",b.x,b.y,b.x,b.y,b.x,b.y];!(a[0]in{T:1,Q:1})&&(b.qx=b.qy=null);switch(a[0]){case"M":b.X=a[1];b.Y=a[2];break;case"A":a=["C"][n](bt[m](0,[b.x,b.y][n](a.slice(1))));break;case"S":c=b.x+(b.x-(b.bx||b.x));d=b.y+(b.y-(b.by||b.y));a=["C",c,d][n](a.slice(1));break;case"T":b.qx=b.x+(b.x-(b.qx||b.x));b.qy=b.y+(b.y-(b.qy||b.y));a=["C"][n](bs(b.x,b.y,b.qx,b.qy,a[1],a[2]));break;case"Q":b.qx=a[1];b.qy=a[2];a=["C"][n](bs(b.x,b.y,a[1],a[2],a[3],a[4]));break;case"L":a=["C"][n](br(b.x,b.y,a[1],a[2]));break;case"H":a=["C"][n](br(b.x,b.y,a[1],b.y));break;case"V":a=["C"][n](br(b.x,b.y,b.x,a[1]));break;case"Z":a=["C"][n](br(b.x,b.y,b.X,b.Y));break}return a},h= function(a,b){if(a[b][w]>7){a[b].shift();var e=a[b];while(e[w])a.splice(b++,0,["C"][n](e.splice(0,6)));a.splice(b,1);k=z(c[w],d&&d[w]||0)}},i= function(a,b,e,f,g){if(a&&b&&a[g][0]=="M"&&b[g][0]!="M"){b.splice(g,0,["M",f.x,f.y]);e.bx=0;e.by=0;e.x=a[g][1];e.y=a[g][2];k=z(c[w],d&&d[w]||0)}};for(var j=0,k=z(c[w],d&&d[w]||0);j<k;j++){c[j]=g(c[j],e);h(c,j);d&&(d[j]=g(d[j],f));d&&h(d,j);i(c,d,e,f,j);i(d,c,f,e,j);var l=c[j],o=d&&d[j],p=l[w],q=d&&o[w];e.x=l[p-2];e.y=l[p-1];e.bx=S(l[p-4])||e.x;e.by=S(l[p-3])||e.y;f.bx=d&&(S(o[q-4])||f.x);f.by=d&&(S(o[q-3])||f.y);f.x=d&&o[q-2];f.y=d&&o[q-1]}return d?[c,d]:c},null,bo),bx=bm(function(b){var c=[];for(var d=0,e=b[w];d<e;d++){var f={},g=b[d].match(/^([^:]*):?([\d\.]*)/);f.color=a.getRGB(g[1]);if(f.color.error)return null;f.color=f.color.hex;g[2]&&(f.offset=g[2]+"%");c[L](f)}for(d=1,e=c[w]-1;d<e;d++){if(!c[d].offset){var h=S(c[d-1].offset||0),i=0;for(var j=d+1;j<e;j++){if(c[j].offset){i=c[j].offset;break}}if(!i){i=100;j=e}i=S(i);var k=(i-h)/(j-d+1);for(;d<j;d++){h+=k;c[d].offset=h+"%"}}}return c}),by= function(b,c,d,e){var f;if(a.is(b,F)||a.is(b,"object")){f=a.is(b,F)?g.getElementById(b):b;if(f.tagName)return c==null?{container:f,width:f.style.pixelWidth||f.offsetWidth,height:f.style.pixelHeight||f.offsetHeight}:{container:f,width:c,height:d}}else return{container:1,x:b,y:c,width:d,height:e}},bz= function(a,b){var c=this;for(var d in b){if(b[f](d)&&!(d in a))switch(typeof b[d]){case"function":(function(b){a[d]=a===c?b:function(){return b[m](c,arguments)}})(b[d]);break;case"object":a[d]=a[d]||{};bz.call(this,a[d],b[d]);break;default:a[d]=b[d];break}}},bA= function(a,b){a==b.top&&(b.top=a.prev);a==b.bottom&&(b.bottom=a.next);a.next&&(a.next.prev=a.prev);a.prev&&(a.prev.next=a.next)},bB= function(a,b){if(b.top===a)return;bA(a,b);a.next=null;a.prev=b.top;b.top.next=a;b.top=a},bC= function(a,b){if(b.bottom===a)return;bA(a,b);a.next=b.bottom;a.prev=null;b.bottom.prev=a;b.bottom=a},bD= function(a,b,c){bA(a,c);b==c.top&&(c.top=a);b.next&&(b.next.prev=a);a.next=b.next;a.prev=b;b.next=a},bE= function(a,b,c){bA(a,c);b==c.bottom&&(c.bottom=a);b.prev&&(b.prev.next=a);a.prev=b.prev;b.prev=a;a.next=b},bF= function(a){return function(){throw new Error("Raphaël: you are calling to method "+a+" of removed object")}};a.pathToRelative=bp;if(a.svg){k.svgns="http://www.w3.org/2000/svg";k.xlink="http://www.w3.org/1999/xlink";Q= function(a){return+a+(~(~a)===a)*0.5};var bG= function(a,b){if(b)for(var c in b)b[f](c)&&a[R](c,r(b[c]));else{a=g.createElementNS(k.svgns,a);a.style.webkitTapHighlightColor="rgba(0,0,0,0)";return a}};a[H]= function(){return"Your browser supports SVG.\nYou are running Raphaël "+this.version};var bH= function(a,b){var c=bG("path");b.canvas&&b.canvas[l](c);var d=new bN(c,b);d.type="path";bK(d,{fill:"none",stroke:"#000",path:a});return d},bI= function(a,b,c){var d="linear",e=0.5,f=0.5,h=a.style;b=r(b)[Y](bd,function(a,b,c){d="radial";if(b&&c){e=S(b);f=S(c);var g=(f>0.5)*2-1;C(e-0.5,2)+C(f-0.5,2)>0.25&&(f=y.sqrt(0.25-C(e-0.5,2))*g+0.5)&&f!=0.5&&(f=f.toFixed(5)-0.00001*g)}return p});b=b[s](/\s*\-\s*/);if(d=="linear"){var i=b.shift();i=-S(i);if(isNaN(i))return null;var j=[0,0,y.cos(i*D/180),y.sin(i*D/180)],k=1/(z(B(j[2]),B(j[3]))||1);j[2]*=k;j[3]*=k;if(j[2]<0){j[0]=-j[2];j[2]=0}if(j[3]<0){j[1]=-j[3];j[3]=0}}var m=bx(b);if(!m)return null;var n=a.getAttribute(I);n=n.match(/^url\(#(.*)\)$/);n&&c.defs.removeChild(g.getElementById(n[1]));var o=bG(d+"Gradient");o.id=bh();bG(o,d=="radial"?{fx:e,fy:f}:{x1:j[0],y1:j[1],x2:j[2],y2:j[3]});c.defs[l](o);for(var q=0,t=m[w];q<t;q++){var u=bG("stop");bG(u,{offset:m[q].offset?m[q].offset:q?"100%":"0%","stop-color":m[q].color||"#fff"});o[l](u)}bG(a,{fill:"url(#"+o.id+")",opacity:1,"fill-opacity":1});h.fill=p;h.opacity=1;h.fillOpacity=1;return 1},bJ= function(b){var c=b.getBBox();bG(b.pattern,{patternTransform:a.format("translate({0},{1})",c.x,c.y)})},bK= function(c,d){var e={"":[0],none:[0],"-":[3,1],".":[1,1],"-.":[3,1,1,1],"-..":[3,1,1,1,1,1],". ":[1,3],"- ":[4,3],"--":[8,3],"- .":[4,3,1,3],"--.":[8,3,1,3],"--..":[8,3,1,3,1,3]},h=c.node,i=c.attrs,j=c.rotate(),k= function(a,b){b=e[x.call(b)];if(b){var c=a.attrs["stroke-width"]||"1",f=({round:c,square:c,butt:0})[a.attrs["stroke-linecap"]||d["stroke-linecap"]]||0,g=[],i=b[w];while(i--)g[i]=b[i]*c+(i%2?1:-1)*f;bG(h,{"stroke-dasharray":g[v](",")})}};d[f]("rotation")&&(j=d.rotation);var m=r(j)[s](b);if(m.length-1){m[1]=+m[1];m[2]=+m[2]}else m=null;S(j)&&c.rotate(0,true);for(var n in d){if(d[f](n)){if(!W[f](n))continue;var o=d[n];i[n]=o;switch(n){case"blur":c.blur(o);break;case"rotation":c.rotate(o,true);break;case"href":case"title":case"target":var t=h.parentNode;if(x.call(t.tagName)!="a"){var u=bG("a");t.insertBefore(u,h);u[l](h);t=u}n=="target"&&o=="blank"?t.setAttributeNS(c.paper.xlink,"show","new"):t.setAttributeNS(c.paper.xlink,n,o);break;case"cursor":h.style.cursor=o;break;case"clip-rect":var y=r(o)[s](b);if(y[w]==4){c.clip&&c.clip.parentNode.parentNode.removeChild(c.clip.parentNode);var z=bG("clipPath"),A=bG("rect");z.id=bh();bG(A,{x:y[0],y:y[1],width:y[2],height:y[3]});z[l](A);c.paper.defs[l](z);bG(h,{"clip-path":"url(#"+z.id+")"});c.clip=A}if(!o){var B=g.getElementById(h.getAttribute("clip-path")[Y](/(^url\(#|\)$)/g,p));B&&B.parentNode.removeChild(B);bG(h,{"clip-path":p});delete c.clip}break;case"path":c.type=="path"&&bG(h,{d:o?i.path=bq(o):"M0,0"});break;case"width":h[R](n,o);if(i.fx){n="x";o=i.x}else break;case"x":i.fx&&(o=-i.x-(i.width||0));case"rx":if(n=="rx"&&c.type=="rect")break;case"cx":m&&(n=="x"||n=="cx")&&(m[1]+=o-i[n]);h[R](n,o);c.pattern&&bJ(c);break;case"height":h[R](n,o);if(i.fy){n="y";o=i.y}else break;case"y":i.fy&&(o=-i.y-(i.height||0));case"ry":if(n=="ry"&&c.type=="rect")break;case"cy":m&&(n=="y"||n=="cy")&&(m[2]+=o-i[n]);h[R](n,o);c.pattern&&bJ(c);break;case"r":c.type=="rect"?bG(h,{rx:o,ry:o}):h[R](n,o);break;case"src":c.type=="image"&&h.setAttributeNS(c.paper.xlink,"href",o);break;case"stroke-width":h.style.strokeWidth=o;h[R](n,o);i["stroke-dasharray"]&&k(c,i["stroke-dasharray"]);break;case"stroke-dasharray":k(c,o);break;case"translation":var C=r(o)[s](b);C[0]=+C[0]||0;C[1]=+C[1]||0;if(m){m[1]+=C[0];m[2]+=C[1]}cz.call(c,C[0],C[1]);break;case"scale":C=r(o)[s](b);c.scale(+C[0]||1,+C[1]||+C[0]||1,isNaN(S(C[2]))?null:+C[2],isNaN(S(C[3]))?null:+C[3]);break;case I:var D=r(o).match(M);if(D){z=bG("pattern");var E=bG("image");z.id=bh();bG(z,{x:0,y:0,patternUnits:"userSpaceOnUse",height:1,width:1});bG(E,{x:0,y:0});E.setAttributeNS(c.paper.xlink,"href",D[1]);z[l](E);var F=g.createElement("img");F.style.cssText="position:absolute;left:-9999em;top-9999em";F.onload= function(){bG(z,{width:this.offsetWidth,height:this.offsetHeight});bG(E,{width:this.offsetWidth,height:this.offsetHeight});g.body.removeChild(this);c.paper.safari()};g.body[l](F);F.src=D[1];c.paper.defs[l](z);h.style.fill="url(#"+z.id+")";bG(h,{fill:"url(#"+z.id+")"});c.pattern=z;c.pattern&&bJ(c);break}var G=a.getRGB(o);if(G.error)if((({circle:1,ellipse:1})[f](c.type)||r(o).charAt()!="r")&&bI(h,o,c.paper)){i.gradient=o;i.fill="none";break}else{delete d.gradient;delete i.gradient;!a.is(i.opacity,"undefined")&&a.is(d.opacity,"undefined")&&bG(h,{opacity:i.opacity});!a.is(i["fill-opacity"],"undefined")&&a.is(d["fill-opacity"],"undefined")&&bG(h,{"fill-opacity":i["fill-opacity"]})}G[f]("opacity")&&bG(h,{"fill-opacity":G.opacity>1?G.opacity/100:G.opacity});case"stroke":G=a.getRGB(o);h[R](n,G.hex);n=="stroke"&&G[f]("opacity")&&bG(h,{"stroke-opacity":G.opacity>1?G.opacity/100:G.opacity});break;case"gradient":(({circle:1,ellipse:1})[f](c.type)||r(o).charAt()!="r")&&bI(h,o,c.paper);break;case"opacity":i.gradient&&!i[f]("stroke-opacity")&&bG(h,{"stroke-opacity":o>1?o/100:o});case"fill-opacity":if(i.gradient){var H=g.getElementById(h.getAttribute(I)[Y](/^url\(#|\)$/g,p));if(H){var J=H.getElementsByTagName("stop");J[J[w]-1][R]("stop-opacity",o)}break}default:n=="font-size"&&(o=T(o,10)+"px");var K=n[Y](/(\-.)/g,function(a){return V.call(a.substring(1))});h.style[K]=o;h[R](n,o);break}}}bM(c,d);m?c.rotate(m.join(q)):S(j)&&c.rotate(j,true)},bL=1.2,bM= function(b,c){if(b.type!="text"||!(c[f]("text")||c[f]("font")||c[f]("font-size")||c[f]("x")||c[f]("y")))return;var d=b.attrs,e=b.node,h=e.firstChild?T(g.defaultView.getComputedStyle(e.firstChild,p).getPropertyValue("font-size"),10):10;if(c[f]("text")){d.text=c.text;while(e.firstChild)e.removeChild(e.firstChild);var i=r(c.text)[s]("\n");for(var j=0,k=i[w];j<k;j++)if(i[j]){var m=bG("tspan");j&&bG(m,{dy:h*bL,x:d.x});m[l](g.createTextNode(i[j]));e[l](m)}}else{i=e.getElementsByTagName("tspan");for(j=0,k=i[w];j<k;j++)j&&bG(i[j],{dy:h*bL,x:d.x})}bG(e,{y:d.y});var n=b.getBBox(),o=d.y-(n.y+n.height/2);o&&a.is(o,"finite")&&bG(e,{y:d.y+o})},bN= function(b,c){var d=0,e=0;this[0]=b;this.id=a._oid++;this.node=b;b.raphael=this;this.paper=c;this.attrs=this.attrs||{};this.transformations=[];this._={tx:0,ty:0,rt:{deg:0,cx:0,cy:0},sx:1,sy:1};!c.bottom&&(c.bottom=this);this.prev=c.top;c.top&&(c.top.next=this);c.top=this;this.next=null},bO=bN[e];bN[e].rotate= function(c,d,e){if(this.removed)return this;if(c==null){if(this._.rt.cx)return[this._.rt.deg,this._.rt.cx,this._.rt.cy][v](q);return this._.rt.deg}var f=this.getBBox();c=r(c)[s](b);if(c[w]-1){d=S(c[1]);e=S(c[2])}c=S(c[0]);d!=null&&d!==false?this._.rt.deg=c:this._.rt.deg+=c;e==null&&(d=null);this._.rt.cx=d;this._.rt.cy=e;d=d==null?f.x+f.width/2:d;e=e==null?f.y+f.height/2:e;if(this._.rt.deg){this.transformations[0]=a.format("rotate({0} {1} {2})",this._.rt.deg,d,e);this.clip&&bG(this.clip,{transform:a.format("rotate({0} {1} {2})",-this._.rt.deg,d,e)})}else{this.transformations[0]=p;this.clip&&bG(this.clip,{transform:p})}bG(this.node,{transform:this.transformations[v](q)});return this};bN[e].hide= function(){!this.removed&&(this.node.style.display="none");return this};bN[e].show= function(){!this.removed&&(this.node.style.display="");return this};bN[e].remove= function(){if(this.removed)return;bA(this,this.paper);this.node.parentNode.removeChild(this.node);for(var a in this)delete this[a];this.removed=true};bN[e].getBBox= function(){if(this.removed)return this;if(this.type=="path")return bn(this.attrs.path);if(this.node.style.display=="none"){this.show();var a=true}var b={};try{b=this.node.getBBox()}catch(a){}finally{b=b||{}}if(this.type=="text"){b={x:b.x,y:Infinity,width:0,height:0};for(var c=0,d=this.node.getNumberOfChars();c<d;c++){var e=this.node.getExtentOfChar(c);e.y<b.y&&(b.y=e.y);e.y+e.height-b.y>b.height&&(b.height=e.y+e.height-b.y);e.x+e.width-b.x>b.width&&(b.width=e.x+e.width-b.x)}}a&&this.hide();return b};bN[e].attr= function(b,c){if(this.removed)return this;if(b==null){var d={};for(var e in this.attrs)this.attrs[f](e)&&(d[e]=this.attrs[e]);this._.rt.deg&&(d.rotation=this.rotate());(this._.sx!=1||this._.sy!=1)&&(d.scale=this.scale());d.gradient&&d.fill=="none"&&(d.fill=d.gradient)&&delete d.gradient;return d}if(c==null&&a.is(b,F)){if(b=="translation")return cz.call(this);if(b=="rotation")return this.rotate();if(b=="scale")return this.scale();if(b==I&&this.attrs.fill=="none"&&this.attrs.gradient)return this.attrs.gradient;return this.attrs[b]}if(c==null&&a.is(b,G)){var g={};for(var h=0,i=b.length;h<i;h++)g[b[h]]=this.attr(b[h]);return g}if(c!=null){var j={};j[b]=c}else b!=null&&a.is(b,"object")&&(j=b);for(var k in this.paper.customAttributes)if(this.paper.customAttributes[f](k)&&j[f](k)&&a.is(this.paper.customAttributes[k],"function")){var l=this.paper.customAttributes[k].apply(this,[][n](j[k]));this.attrs[k]=j[k];for(var m in l)l[f](m)&&(j[m]=l[m])}bK(this,j);return this};bN[e].toFront= function(){if(this.removed)return this;this.node.parentNode[l](this.node);var a=this.paper;a.top!=this&&bB(this,a);return this};bN[e].toBack= function(){if(this.removed)return this;if(this.node.parentNode.firstChild!=this.node){this.node.parentNode.insertBefore(this.node,this.node.parentNode.firstChild);bC(this,this.paper);var a=this.paper}return this};bN[e].insertAfter= function(a){if(this.removed)return this;var b=a.node||a[a.length-1].node;b.nextSibling?b.parentNode.insertBefore(this.node,b.nextSibling):b.parentNode[l](this.node);bD(this,a,this.paper);return this};bN[e].insertBefore= function(a){if(this.removed)return this;var b=a.node||a[0].node;b.parentNode.insertBefore(this.node,b);bE(this,a,this.paper);return this};bN[e].blur= function(a){var b=this;if(+a!==0){var c=bG("filter"),d=bG("feGaussianBlur");b.attrs.blur=a;c.id=bh();bG(d,{stdDeviation:+a||1.5});c.appendChild(d);b.paper.defs.appendChild(c);b._blur=c;bG(b.node,{filter:"url(#"+c.id+")"})}else{if(b._blur){b._blur.parentNode.removeChild(b._blur);delete b._blur;delete b.attrs.blur}b.node.removeAttribute("filter")}};var bP= function(a,b,c,d){var e=bG("circle");a.canvas&&a.canvas[l](e);var f=new bN(e,a);f.attrs={cx:b,cy:c,r:d,fill:"none",stroke:"#000"};f.type="circle";bG(e,f.attrs);return f},bQ= function(a,b,c,d,e,f){var g=bG("rect");a.canvas&&a.canvas[l](g);var h=new bN(g,a);h.attrs={x:b,y:c,width:d,height:e,r:f||0,rx:f||0,ry:f||0,fill:"none",stroke:"#000"};h.type="rect";bG(g,h.attrs);return h},bR= function(a,b,c,d,e){var f=bG("ellipse");a.canvas&&a.canvas[l](f);var g=new bN(f,a);g.attrs={cx:b,cy:c,rx:d,ry:e,fill:"none",stroke:"#000"};g.type="ellipse";bG(f,g.attrs);return g},bS= function(a,b,c,d,e,f){var g=bG("image");bG(g,{x:c,y:d,width:e,height:f,preserveAspectRatio:"none"});g.setAttributeNS(a.xlink,"href",b);a.canvas&&a.canvas[l](g);var h=new bN(g,a);h.attrs={x:c,y:d,width:e,height:f,src:b};h.type="image";return h},bT= function(a,b,c,d){var e=bG("text");bG(e,{x:b,y:c,"text-anchor":"middle"});a.canvas&&a.canvas[l](e);var f=new bN(e,a);f.attrs={x:b,y:c,"text-anchor":"middle",text:d,font:W.font,stroke:"none",fill:"#000"};f.type="text";bK(f,f.attrs);return f},bU= function(a,b){this.width=a||this.width;this.height=b||this.height;this.canvas[R]("width",this.width);this.canvas[R]("height",this.height);return this},bV= function(){var b=by[m](0,arguments),c=b&&b.container,d=b.x,e=b.y,f=b.width,h=b.height;if(!c)throw new Error("SVG container not found.");var i=bG("svg");d=d||0;e=e||0;f=f||512;h=h||342;bG(i,{xmlns:"http://www.w3.org/2000/svg",version:1.1,width:f,height:h});if(c==1){i.style.cssText="position:absolute;left:"+d+"px;top:"+e+"px";g.body[l](i)}else c.firstChild?c.insertBefore(i,c.firstChild):c[l](i);c=new j;c.width=f;c.height=h;c.canvas=i;bz.call(c,c,a.fn);c.clear();return c};k.clear= function(){var a=this.canvas;while(a.firstChild)a.removeChild(a.firstChild);this.bottom=this.top=null;(this.desc=bG("desc"))[l](g.createTextNode("Created with Raphaël"));a[l](this.desc);a[l](this.defs=bG("defs"))};k.remove= function(){this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas);for(var a in this)this[a]=bF(a)}}if(a.vml){var bW={M:"m",L:"l",C:"c",Z:"x",m:"t",l:"r",c:"v",z:"x"},bX=/([clmz]),?([^clmz]*)/gi,bY=/ progid:\S+Blur\([^\)]+\)/g,bZ=/-?[^,\s-]+/g,b$=1000+q+1000,b_=10,ca={path:1,rect:1},cb= function(a){var b=/[ahqstv]/ig,c=bq;r(a).match(b)&&(c=bw);b=/[clmz]/g;if(c==bq&&!r(a).match(b)){var d=r(a)[Y](bX,function(a,b,c){var d=[],e=x.call(b)=="m",f=bW[b];c[Y](bZ,function(a){if(e&&d[w]==2){f+=d+bW[b=="m"?"l":"L"];d=[]}d[L](Q(a*b_))});return f+d});return d}var e=c(a),f,g;d=[];for(var h=0,i=e[w];h<i;h++){f=e[h];g=x.call(e[h][0]);g=="z"&&(g="x");for(var j=1,k=f[w];j<k;j++)g+=Q(f[j]*b_)+(j!=k-1?",":p);d[L](g)}return d[v](q)};a[H]= function(){return"Your browser doesnt support SVG. Falling down to VML.\nYou are running Raphaël "+this.version};bH= function(a,b){var c=cd("group");c.style.cssText="position:absolute;left:0;top:0;width:"+b.width+"px;height:"+b.height+"px";c.coordsize=b.coordsize;c.coordorigin=b.coordorigin;var d=cd("shape"),e=d.style;e.width=b.width+"px";e.height=b.height+"px";d.coordsize=b$;d.coordorigin=b.coordorigin;c[l](d);var f=new bN(d,c,b),g={fill:"none",stroke:"#000"};a&&(g.path=a);f.type="path";f.path=[];f.Path=p;bK(f,g);b.canvas[l](c);return f};bK= function(c,d){c.attrs=c.attrs||{};var e=c.node,h=c.attrs,i=e.style,j,k=(d.x!=h.x||d.y!=h.y||d.width!=h.width||d.height!=h.height||d.r!=h.r)&&c.type=="rect",m=c;for(var n in d)d[f](n)&&(h[n]=d[n]);if(k){h.path=cc(h.x,h.y,h.width,h.height,h.r);c.X=h.x;c.Y=h.y;c.W=h.width;c.H=h.height}d.href&&(e.href=d.href);d.title&&(e.title=d.title);d.target&&(e.target=d.target);d.cursor&&(i.cursor=d.cursor);"blur"in d&&c.blur(d.blur);if(d.path&&c.type=="path"||k)e.path=cb(h.path);d.rotation!=null&&c.rotate(d.rotation,true);if(d.translation){j=r(d.translation)[s](b);cz.call(c,j[0],j[1]);if(c._.rt.cx!=null){c._.rt.cx+=+j[0];c._.rt.cy+=+j[1];c.setBox(c.attrs,j[0],j[1])}}if(d.scale){j=r(d.scale)[s](b);c.scale(+j[0]||1,+j[1]||+j[0]||1,+j[2]||null,+j[3]||null)}if("clip-rect"in d){var o=r(d["clip-rect"])[s](b);if(o[w]==4){o[2]=+o[2]+ +o[0];o[3]=+o[3]+ +o[1];var q=e.clipRect||g.createElement("div"),t=q.style,u=e.parentNode;t.clip=a.format("rect({1}px {2}px {3}px {0}px)",o);if(!e.clipRect){t.position="absolute";t.top=0;t.left=0;t.width=c.paper.width+"px";t.height=c.paper.height+"px";u.parentNode.insertBefore(q,u);q[l](u);e.clipRect=q}}d["clip-rect"]||e.clipRect&&(e.clipRect.style.clip=p)}c.type=="image"&&d.src&&(e.src=d.src);if(c.type=="image"&&d.opacity){e.filterOpacity=U+".Alpha(opacity="+d.opacity*100+")";i.filter=(e.filterMatrix||p)+(e.filterOpacity||p)}d.font&&(i.font=d.font);d["font-family"]&&(i.fontFamily="\""+d["font-family"][s](",")[0][Y](/^['"]+|['"]+$/g,p)+"\"");d["font-size"]&&(i.fontSize=d["font-size"]);d["font-weight"]&&(i.fontWeight=d["font-weight"]);d["font-style"]&&(i.fontStyle=d["font-style"]);if(d.opacity!=null||d["stroke-width"]!=null||d.fill!=null||d.stroke!=null||d["stroke-width"]!=null||d["stroke-opacity"]!=null||d["fill-opacity"]!=null||d["stroke-dasharray"]!=null||d["stroke-miterlimit"]!=null||d["stroke-linejoin"]!=null||d["stroke-linecap"]!=null){e=c.shape||e;var v=e.getElementsByTagName(I)&&e.getElementsByTagName(I)[0],x=false;!v&&(x=v=cd(I));if("fill-opacity"in d||"opacity"in d){var y=((+h["fill-opacity"]+1||2)-1)*((+h.opacity+1||2)-1)*((+a.getRGB(d.fill).o+1||2)-1);y=A(z(y,0),1);v.opacity=y}d.fill&&(v.on=true);if(v.on==null||d.fill=="none")v.on=false;if(v.on&&d.fill){var B=d.fill.match(M);if(B){v.src=B[1];v.type="tile"}else{v.color=a.getRGB(d.fill).hex;v.src=p;v.type="solid";if(a.getRGB(d.fill).error&&(m.type in{circle:1,ellipse:1}||r(d.fill).charAt()!="r")&&bI(m,d.fill)){h.fill="none";h.gradient=d.fill}}}x&&e[l](v);var C=e.getElementsByTagName("stroke")&&e.getElementsByTagName("stroke")[0],D=false;!C&&(D=C=cd("stroke"));if(d.stroke&&d.stroke!="none"||d["stroke-width"]||d["stroke-opacity"]!=null||d["stroke-dasharray"]||d["stroke-miterlimit"]||d["stroke-linejoin"]||d["stroke-linecap"])C.on=true;(d.stroke=="none"||C.on==null||d.stroke==0||d["stroke-width"]==0)&&(C.on=false);var E=a.getRGB(d.stroke);C.on&&d.stroke&&(C.color=E.hex);y=((+h["stroke-opacity"]+1||2)-1)*((+h.opacity+1||2)-1)*((+E.o+1||2)-1);var F=(S(d["stroke-width"])||1)*0.75;y=A(z(y,0),1);d["stroke-width"]==null&&(F=h["stroke-width"]);d["stroke-width"]&&(C.weight=F);F&&F<1&&(y*=F)&&(C.weight=1);C.opacity=y;d["stroke-linejoin"]&&(C.joinstyle=d["stroke-linejoin"]||"miter");C.miterlimit=d["stroke-miterlimit"]||8;d["stroke-linecap"]&&(C.endcap=d["stroke-linecap"]=="butt"?"flat":d["stroke-linecap"]=="square"?"square":"round");if(d["stroke-dasharray"]){var G={"-":"shortdash",".":"shortdot","-.":"shortdashdot","-..":"shortdashdotdot",". ":"dot","- ":"dash","--":"longdash","- .":"dashdot","--.":"longdashdot","--..":"longdashdotdot"};C.dashstyle=G[f](d["stroke-dasharray"])?G[d["stroke-dasharray"]]:p}D&&e[l](C)}if(m.type=="text"){i=m.paper.span.style;h.font&&(i.font=h.font);h["font-family"]&&(i.fontFamily=h["font-family"]);h["font-size"]&&(i.fontSize=h["font-size"]);h["font-weight"]&&(i.fontWeight=h["font-weight"]);h["font-style"]&&(i.fontStyle=h["font-style"]);m.node.string&&(m.paper.span.innerHTML=r(m.node.string)[Y](/</g,"&#60;")[Y](/&/g,"&#38;")[Y](/\n/g,"<br>"));m.W=h.w=m.paper.span.offsetWidth;m.H=h.h=m.paper.span.offsetHeight;m.X=h.x;m.Y=h.y+Q(m.H/2);switch(h["text-anchor"]){case"start":m.node.style["v-text-align"]="left";m.bbx=Q(m.W/2);break;case"end":m.node.style["v-text-align"]="right";m.bbx=-Q(m.W/2);break;default:m.node.style["v-text-align"]="center";break}}};bI= function(a,b){a.attrs=a.attrs||{};var c=a.attrs,d,e="linear",f=".5 .5";a.attrs.gradient=b;b=r(b)[Y](bd,function(a,b,c){e="radial";if(b&&c){b=S(b);c=S(c);C(b-0.5,2)+C(c-0.5,2)>0.25&&(c=y.sqrt(0.25-C(b-0.5,2))*((c>0.5)*2-1)+0.5);f=b+q+c}return p});b=b[s](/\s*\-\s*/);if(e=="linear"){var g=b.shift();g=-S(g);if(isNaN(g))return null}var h=bx(b);if(!h)return null;a=a.shape||a.node;d=a.getElementsByTagName(I)[0]||cd(I);!d.parentNode&&a.appendChild(d);if(h[w]){d.on=true;d.method="none";d.color=h[0].color;d.color2=h[h[w]-1].color;var i=[];for(var j=0,k=h[w];j<k;j++)h[j].offset&&i[L](h[j].offset+q+h[j].color);d.colors&&(d.colors.value=i[w]?i[v]():"0% "+d.color);if(e=="radial"){d.type="gradientradial";d.focus="100%";d.focussize=f;d.focusposition=f}else{d.type="gradient";d.angle=(270-g)%360}}return 1};bN= function(b,c,d){var e=0,f=0,g=0,h=1;this[0]=b;this.id=a._oid++;this.node=b;b.raphael=this;this.X=0;this.Y=0;this.attrs={};this.Group=c;this.paper=d;this._={tx:0,ty:0,rt:{deg:0},sx:1,sy:1};!d.bottom&&(d.bottom=this);this.prev=d.top;d.top&&(d.top.next=this);d.top=this;this.next=null};bO=bN[e];bO.rotate= function(a,c,d){if(this.removed)return this;if(a==null){if(this._.rt.cx)return[this._.rt.deg,this._.rt.cx,this._.rt.cy][v](q);return this._.rt.deg}a=r(a)[s](b);if(a[w]-1){c=S(a[1]);d=S(a[2])}a=S(a[0]);c!=null?this._.rt.deg=a:this._.rt.deg+=a;d==null&&(c=null);this._.rt.cx=c;this._.rt.cy=d;this.setBox(this.attrs,c,d);this.Group.style.rotation=this._.rt.deg;return this};bO.setBox= function(a,b,c){if(this.removed)return this;var d=this.Group.style,e=this.shape&&this.shape.style||this.node.style;a=a||{};for(var g in a)a[f](g)&&(this.attrs[g]=a[g]);b=b||this._.rt.cx;c=c||this._.rt.cy;var h=this.attrs,i,j,k,l;switch(this.type){case"circle":i=h.cx-h.r;j=h.cy-h.r;k=l=h.r*2;break;case"ellipse":i=h.cx-h.rx;j=h.cy-h.ry;k=h.rx*2;l=h.ry*2;break;case"image":i=+h.x;j=+h.y;k=h.width||0;l=h.height||0;break;case"text":this.textpath.v=["m",Q(h.x),", ",Q(h.y-2),"l",Q(h.x)+1,", ",Q(h.y-2)][v](p);i=h.x-Q(this.W/2);j=h.y-this.H/2;k=this.W;l=this.H;break;case"rect":case"path":if(this.attrs.path){var m=bn(this.attrs.path);i=m.x;j=m.y;k=m.width;l=m.height}else{i=0;j=0;k=this.paper.width;l=this.paper.height}break;default:i=0;j=0;k=this.paper.width;l=this.paper.height;break}b=b==null?i+k/2:b;c=c==null?j+l/2:c;var n=b-this.paper.width/2,o=c-this.paper.height/2,q;d.left!=(q=n+"px")&&(d.left=q);d.top!=(q=o+"px")&&(d.top=q);this.X=ca[f](this.type)?-n:i;this.Y=ca[f](this.type)?-o:j;this.W=k;this.H=l;if(ca[f](this.type)){e.left!=(q=-n*b_+"px")&&(e.left=q);e.top!=(q=-o*b_+"px")&&(e.top=q)}else if(this.type=="text"){e.left!=(q=-n+"px")&&(e.left=q);e.top!=(q=-o+"px")&&(e.top=q)}else{d.width!=(q=this.paper.width+"px")&&(d.width=q);d.height!=(q=this.paper.height+"px")&&(d.height=q);e.left!=(q=i-n+"px")&&(e.left=q);e.top!=(q=j-o+"px")&&(e.top=q);e.width!=(q=k+"px")&&(e.width=q);e.height!=(q=l+"px")&&(e.height=q)}};bO.hide= function(){!this.removed&&(this.Group.style.display="none");return this};bO.show= function(){!this.removed&&(this.Group.style.display="block");return this};bO.getBBox= function(){if(this.removed)return this;if(ca[f](this.type))return bn(this.attrs.path);return{x:this.X+(this.bbx||0),y:this.Y,width:this.W,height:this.H}};bO.remove= function(){if(this.removed)return;bA(this,this.paper);this.node.parentNode.removeChild(this.node);this.Group.parentNode.removeChild(this.Group);this.shape&&this.shape.parentNode.removeChild(this.shape);for(var a in this)delete this[a];this.removed=true};bO.attr= function(b,c){if(this.removed)return this;if(b==null){var d={};for(var e in this.attrs)this.attrs[f](e)&&(d[e]=this.attrs[e]);this._.rt.deg&&(d.rotation=this.rotate());(this._.sx!=1||this._.sy!=1)&&(d.scale=this.scale());d.gradient&&d.fill=="none"&&(d.fill=d.gradient)&&delete d.gradient;return d}if(c==null&&a.is(b,"string")){if(b=="translation")return cz.call(this);if(b=="rotation")return this.rotate();if(b=="scale")return this.scale();if(b==I&&this.attrs.fill=="none"&&this.attrs.gradient)return this.attrs.gradient;return this.attrs[b]}if(this.attrs&&c==null&&a.is(b,G)){var g,h={};for(e=0,g=b[w];e<g;e++)h[b[e]]=this.attr(b[e]);return h}var i;if(c!=null){i={};i[b]=c}c==null&&a.is(b,"object")&&(i=b);if(i){for(var j in this.paper.customAttributes)if(this.paper.customAttributes[f](j)&&i[f](j)&&a.is(this.paper.customAttributes[j],"function")){var k=this.paper.customAttributes[j].apply(this,[][n](i[j]));this.attrs[j]=i[j];for(var l in k)k[f](l)&&(i[l]=k[l])}i.text&&this.type=="text"&&(this.node.string=i.text);bK(this,i);i.gradient&&(({circle:1,ellipse:1})[f](this.type)||r(i.gradient).charAt()!="r")&&bI(this,i.gradient);(!ca[f](this.type)||this._.rt.deg)&&this.setBox(this.attrs)}return this};bO.toFront= function(){!this.removed&&this.Group.parentNode[l](this.Group);this.paper.top!=this&&bB(this,this.paper);return this};bO.toBack= function(){if(this.removed)return this;if(this.Group.parentNode.firstChild!=this.Group){this.Group.parentNode.insertBefore(this.Group,this.Group.parentNode.firstChild);bC(this,this.paper)}return this};bO.insertAfter= function(a){if(this.removed)return this;a.constructor==cC&&(a=a[a.length-1]);a.Group.nextSibling?a.Group.parentNode.insertBefore(this.Group,a.Group.nextSibling):a.Group.parentNode[l](this.Group);bD(this,a,this.paper);return this};bO.insertBefore= function(a){if(this.removed)return this;a.constructor==cC&&(a=a[0]);a.Group.parentNode.insertBefore(this.Group,a.Group);bE(this,a,this.paper);return this};bO.blur= function(b){var c=this.node.runtimeStyle,d=c.filter;d=d.replace(bY,p);if(+b!==0){this.attrs.blur=b;c.filter=d+q+U+".Blur(pixelradius="+(+b||1.5)+")";c.margin=a.format("-{0}px 0 0 -{0}px",Q(+b||1.5))}else{c.filter=d;c.margin=0;delete this.attrs.blur}};bP= function(a,b,c,d){var e=cd("group"),f=cd("oval"),g=f.style;e.style.cssText="position:absolute;left:0;top:0;width:"+a.width+"px;height:"+a.height+"px";e.coordsize=b$;e.coordorigin=a.coordorigin;e[l](f);var h=new bN(f,e,a);h.type="circle";bK(h,{stroke:"#000",fill:"none"});h.attrs.cx=b;h.attrs.cy=c;h.attrs.r=d;h.setBox({x:b-d,y:c-d,width:d*2,height:d*2});a.canvas[l](e);return h};function cc(b,c,d,e,f){return f?a.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z",b+f,c,d-f*2,f,-f,e-f*2,f*2-d,f*2-e):a.format("M{0},{1}l{2},0,0,{3},{4},0z",b,c,d,e,-d)}bQ= function(a,b,c,d,e,f){var g=cc(b,c,d,e,f),h=a.path(g),i=h.attrs;h.X=i.x=b;h.Y=i.y=c;h.W=i.width=d;h.H=i.height=e;i.r=f;i.path=g;h.type="rect";return h};bR= function(a,b,c,d,e){var f=cd("group"),g=cd("oval"),h=g.style;f.style.cssText="position:absolute;left:0;top:0;width:"+a.width+"px;height:"+a.height+"px";f.coordsize=b$;f.coordorigin=a.coordorigin;f[l](g);var i=new bN(g,f,a);i.type="ellipse";bK(i,{stroke:"#000"});i.attrs.cx=b;i.attrs.cy=c;i.attrs.rx=d;i.attrs.ry=e;i.setBox({x:b-d,y:c-e,width:d*2,height:e*2});a.canvas[l](f);return i};bS= function(a,b,c,d,e,f){var g=cd("group"),h=cd("image");g.style.cssText="position:absolute;left:0;top:0;width:"+a.width+"px;height:"+a.height+"px";g.coordsize=b$;g.coordorigin=a.coordorigin;h.src=b;g[l](h);var i=new bN(h,g,a);i.type="image";i.attrs.src=b;i.attrs.x=c;i.attrs.y=d;i.attrs.w=e;i.attrs.h=f;i.setBox({x:c,y:d,width:e,height:f});a.canvas[l](g);return i};bT= function(b,c,d,e){var f=cd("group"),g=cd("shape"),h=g.style,i=cd("path"),j=i.style,k=cd("textpath");f.style.cssText="position:absolute;left:0;top:0;width:"+b.width+"px;height:"+b.height+"px";f.coordsize=b$;f.coordorigin=b.coordorigin;i.v=a.format("m{0},{1}l{2},{1}",Q(c*10),Q(d*10),Q(c*10)+1);i.textpathok=true;h.width=b.width;h.height=b.height;k.string=r(e);k.on=true;g[l](k);g[l](i);f[l](g);var m=new bN(k,f,b);m.shape=g;m.textpath=i;m.type="text";m.attrs.text=e;m.attrs.x=c;m.attrs.y=d;m.attrs.w=1;m.attrs.h=1;bK(m,{font:W.font,stroke:"none",fill:"#000"});m.setBox();b.canvas[l](f);return m};bU= function(a,b){var c=this.canvas.style;a==+a&&(a+="px");b==+b&&(b+="px");c.width=a;c.height=b;c.clip="rect(0 "+a+" "+b+" 0)";return this};var cd;g.createStyleSheet().addRule(".rvml","behavior:url(#default#VML)");try{!g.namespaces.rvml&&g.namespaces.add("rvml","urn:schemas-microsoft-com:vml");cd= function(a){return g.createElement("<rvml:"+a+" class=\"rvml\">")}}catch(a){cd= function(a){return g.createElement("<"+a+" xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">")}}bV= function(){var b=by[m](0,arguments),c=b.container,d=b.height,e,f=b.width,h=b.x,i=b.y;if(!c)throw new Error("VML container not found.");var k=new j,n=k.canvas=g.createElement("div"),o=n.style;h=h||0;i=i||0;f=f||512;d=d||342;f==+f&&(f+="px");d==+d&&(d+="px");k.width=1000;k.height=1000;k.coordsize=b_*1000+q+b_*1000;k.coordorigin="0 0";k.span=g.createElement("span");k.span.style.cssText="position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";n[l](k.span);o.cssText=a.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden",f,d);if(c==1){g.body[l](n);o.left=h+"px";o.top=i+"px";o.position="absolute"}else c.firstChild?c.insertBefore(n,c.firstChild):c[l](n);bz.call(k,k,a.fn);return k};k.clear= function(){this.canvas.innerHTML=p;this.span=g.createElement("span");this.span.style.cssText="position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";this.canvas[l](this.span);this.bottom=this.top=null};k.remove= function(){this.canvas.parentNode.removeChild(this.canvas);for(var a in this)this[a]=bF(a);return true}}var ce=navigator.userAgent.match(/Version\\x2f(.*?)\s/);navigator.vendor=="Apple Computer, Inc."&&(ce&&ce[1]<4||navigator.platform.slice(0,2)=="iP")?k.safari= function(){var a=this.rect(-99,-99,this.width+99,this.height+99).attr({stroke:"none"});h.setTimeout(function(){a.remove()})}:k.safari= function(){};var cf= function(){this.returnValue=false},cg= function(){return this.originalEvent.preventDefault()},ch= function(){this.cancelBubble=true},ci= function(){return this.originalEvent.stopPropagation()},cj=(function(){{if(g.addEventListener)return function(a,b,c,d){var e=o&&u[b]?u[b]:b,g= function(e){if(o&&u[f](b))for(var g=0,h=e.targetTouches&&e.targetTouches.length;g<h;g++){if(e.targetTouches[g].target==a){var i=e;e=e.targetTouches[g];e.originalEvent=i;e.preventDefault=cg;e.stopPropagation=ci;break}}return c.call(d,e)};a.addEventListener(e,g,false);return function(){a.removeEventListener(e,g,false);return true}};if(g.attachEvent)return function(a,b,c,d){var e= function(a){a=a||h.event;a.preventDefault=a.preventDefault||cf;a.stopPropagation=a.stopPropagation||ch;return c.call(d,a)};a.attachEvent("on"+b,e);var f= function(){a.detachEvent("on"+b,e);return true};return f}}})(),ck=[],cl= function(a){var b=a.clientX,c=a.clientY,d=g.documentElement.scrollTop||g.body.scrollTop,e=g.documentElement.scrollLeft||g.body.scrollLeft,f,h=ck.length;while(h--){f=ck[h];if(o){var i=a.touches.length,j;while(i--){j=a.touches[i];if(j.identifier==f.el._drag.id){b=j.clientX;c=j.clientY;(a.originalEvent?a.originalEvent:a).preventDefault();break}}}else a.preventDefault();b+=e;c+=d;f.move&&f.move.call(f.move_scope||f.el,b-f.el._drag.x,c-f.el._drag.y,b,c,a)}},cm= function(b){a.unmousemove(cl).unmouseup(cm);var c=ck.length,d;while(c--){d=ck[c];d.el._drag={};d.end&&d.end.call(d.end_scope||d.start_scope||d.move_scope||d.el,b)}ck=[]};for(var cn=t[w];cn--;)(function(b){a[b]=bN[e][b]= function(c,d){if(a.is(c,"function")){this.events=this.events||[];this.events.push({name:b,f:c,unbind:cj(this.shape||this.node||g,b,c,d||this)})}return this};a["un"+b]=bN[e]["un"+b]= function(a){var c=this.events,d=c[w];while(d--)if(c[d].name==b&&c[d].f==a){c[d].unbind();c.splice(d,1);!c.length&&delete this.events;return this}return this}})(t[cn]);bO.hover= function(a,b,c,d){return this.mouseover(a,c).mouseout(b,d||c)};bO.unhover= function(a,b){return this.unmouseover(a).unmouseout(b)};bO.drag= function(b,c,d,e,f,h){this._drag={};this.mousedown(function(i){(i.originalEvent||i).preventDefault();var j=g.documentElement.scrollTop||g.body.scrollTop,k=g.documentElement.scrollLeft||g.body.scrollLeft;this._drag.x=i.clientX+k;this._drag.y=i.clientY+j;this._drag.id=i.identifier;c&&c.call(f||e||this,i.clientX+k,i.clientY+j,i);!ck.length&&a.mousemove(cl).mouseup(cm);ck.push({el:this,move:b,end:d,move_scope:e,start_scope:f,end_scope:h})});return this};bO.undrag= function(b,c,d){var e=ck.length;while(e--)ck[e].el==this&&(ck[e].move==b&&ck[e].end==d)&&ck.splice(e++,1);!ck.length&&a.unmousemove(cl).unmouseup(cm)};k.circle= function(a,b,c){return bP(this,a||0,b||0,c||0)};k.rect= function(a,b,c,d,e){return bQ(this,a||0,b||0,c||0,d||0,e||0)};k.ellipse= function(a,b,c,d){return bR(this,a||0,b||0,c||0,d||0)};k.path= function(b){b&&!a.is(b,F)&&!a.is(b[0],G)&&(b+=p);return bH(a.format[m](a,arguments),this)};k.image= function(a,b,c,d,e){return bS(this,a||"about:blank",b||0,c||0,d||0,e||0)};k.text= function(a,b,c){return bT(this,a||0,b||0,r(c))};k.set= function(a){arguments[w]>1&&(a=Array[e].splice.call(arguments,0,arguments[w]));return new cC(a)};k.setSize=bU;k.top=k.bottom=null;k.raphael=a;function co(){return this.x+q+this.y}bO.resetScale= function(){if(this.removed)return this;this._.sx=1;this._.sy=1;this.attrs.scale="1 1"};bO.scale= function(a,b,c,d){if(this.removed)return this;if(a==null&&b==null)return{x:this._.sx,y:this._.sy,toString:co};b=b||a;!(+b)&&(b=a);var e,f,g,h,i=this.attrs;if(a!=0){var j=this.getBBox(),k=j.x+j.width/2,l=j.y+j.height/2,m=B(a/this._.sx),o=B(b/this._.sy);c=+c||c==0?c:k;d=+d||d==0?d:l;var r=this._.sx>0,s=this._.sy>0,t=~(~(a/B(a))),u=~(~(b/B(b))),x=m*t,y=o*u,z=this.node.style,A=c+B(k-c)*x*(k>c==r?1:-1),C=d+B(l-d)*y*(l>d==s?1:-1),D=a*t>b*u?o:m;switch(this.type){case"rect":case"image":var E=i.width*m,F=i.height*o;this.attr({height:F,r:i.r*D,width:E,x:A-E/2,y:C-F/2});break;case"circle":case"ellipse":this.attr({rx:i.rx*m,ry:i.ry*o,r:i.r*D,cx:A,cy:C});break;case"text":this.attr({x:A,y:C});break;case"path":var G=bp(i.path),H=true,I=r?x:m,J=s?y:o;for(var K=0,L=G[w];K<L;K++){var M=G[K],N=V.call(M[0]);{if(N=="M"&&H)continue;H=false}if(N=="A"){M[G[K][w]-2]*=I;M[G[K][w]-1]*=J;M[1]*=m;M[2]*=o;M[5]=+(t+u?!(!(+M[5])):!(+M[5]))}else if(N=="H")for(var O=1,P=M[w];O<P;O++)M[O]*=I;else if(N=="V")for(O=1,P=M[w];O<P;O++)M[O]*=J;else for(O=1,P=M[w];O<P;O++)M[O]*=O%2?I:J}var Q=bn(G);e=A-Q.x-Q.width/2;f=C-Q.y-Q.height/2;G[0][1]+=e;G[0][2]+=f;this.attr({path:G});break}if(this.type in{text:1,image:1}&&(t!=1||u!=1))if(this.transformations){this.transformations[2]="scale("[n](t,",",u,")");this.node[R]("transform",this.transformations[v](q));e=t==-1?-i.x-(E||0):i.x;f=u==-1?-i.y-(F||0):i.y;this.attr({x:e,y:f});i.fx=t-1;i.fy=u-1}else{this.node.filterMatrix=U+".Matrix(M11="[n](t,", M12=0, M21=0, M22=",u,", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");z.filter=(this.node.filterMatrix||p)+(this.node.filterOpacity||p)}else if(this.transformations){this.transformations[2]=p;this.node[R]("transform",this.transformations[v](q));i.fx=0;i.fy=0}else{this.node.filterMatrix=p;z.filter=(this.node.filterMatrix||p)+(this.node.filterOpacity||p)}i.scale=[a,b,c,d][v](q);this._.sx=a;this._.sy=b}return this};bO.clone= function(){if(this.removed)return null;var a=this.attr();delete a.scale;delete a.translation;return this.paper[this.type]().attr(a)};var cp={},cq= function(b,c,d,e,f,g,h,i,j){var k=0,l=100,m=[b,c,d,e,f,g,h,i].join(),n=cp[m],o,p;!n&&(cp[m]=n={data:[]});n.timer&&clearTimeout(n.timer);n.timer=setTimeout(function(){delete cp[m]},2000);if(j!=null){var q=cq(b,c,d,e,f,g,h,i);l=~(~q)*10}for(var r=0;r<l+1;r++){if(n.data[j]>r)p=n.data[r*l];else{p=a.findDotsAtSegment(b,c,d,e,f,g,h,i,r/l);n.data[r]=p}r&&(k+=C(C(o.x-p.x,2)+C(o.y-p.y,2),0.5));if(j!=null&&k>=j)return p;o=p}if(j==null)return k},cr= function(b,c){return function(d,e,f){d=bw(d);var g,h,i,j,k="",l={},m,n=0;for(var o=0,p=d.length;o<p;o++){i=d[o];if(i[0]=="M"){g=+i[1];h=+i[2]}else{j=cq(g,h,i[1],i[2],i[3],i[4],i[5],i[6]);if(n+j>e){if(c&&!l.start){m=cq(g,h,i[1],i[2],i[3],i[4],i[5],i[6],e-n);k+=["C",m.start.x,m.start.y,m.m.x,m.m.y,m.x,m.y];if(f)return k;l.start=k;k=["M",m.x,m.y+"C",m.n.x,m.n.y,m.end.x,m.end.y,i[5],i[6]][v]();n+=j;g=+i[5];h=+i[6];continue}if(!b&&!c){m=cq(g,h,i[1],i[2],i[3],i[4],i[5],i[6],e-n);return{x:m.x,y:m.y,alpha:m.alpha}}}n+=j;g=+i[5];h=+i[6]}k+=i}l.end=k;m=b?n:c?l:a.findDotsAtSegment(g,h,i[1],i[2],i[3],i[4],i[5],i[6],1);m.alpha&&(m={x:m.x,y:m.y,alpha:m.alpha});return m}},cs=cr(1),ct=cr(),cu=cr(0,1);bO.getTotalLength= function(){if(this.type!="path")return;if(this.node.getTotalLength)return this.node.getTotalLength();return cs(this.attrs.path)};bO.getPointAtLength= function(a){if(this.type!="path")return;return ct(this.attrs.path,a)};bO.getSubpath= function(a,b){if(this.type!="path")return;if(B(this.getTotalLength()-b)<"1e-6")return cu(this.attrs.path,a).end;var c=cu(this.attrs.path,b,1);return a?cu(c,a).end:c};a.easing_formulas={linear:function(a){return a},"<":function(a){return C(a,3)},">":function(a){return C(a-1,3)+1},"<>":function(a){a=a*2;if(a<1)return C(a,3)/2;a-=2;return(C(a,3)+2)/2},backIn:function(a){var b=1.70158;return a*a*((b+1)*a-b)},backOut:function(a){a=a-1;var b=1.70158;return a*a*((b+1)*a+b)+1},elastic:function(a){if(a==0||a==1)return a;var b=0.3,c=b/4;return C(2,-10*a)*y.sin((a-c)*(2*D)/b)+1},bounce:function(a){var b=7.5625,c=2.75,d;if(a<1/c)d=b*a*a;else if(a<2/c){a-=1.5/c;d=b*a*a+0.75}else if(a<2.5/c){a-=2.25/c;d=b*a*a+0.9375}else{a-=2.625/c;d=b*a*a+0.984375}return d}};var cv=[],cw= function(){var b=+(new Date);for(var c=0;c<cv[w];c++){var d=cv[c];if(d.stop||d.el.removed)continue;var e=b-d.start,g=d.ms,h=d.easing,i=d.from,j=d.diff,k=d.to,l=d.t,m=d.el,n={},o;if(e<g){var r=h(e/g);for(var s in i)if(i[f](s)){switch(X[s]){case"along":o=r*g*j[s];k.back&&(o=k.len-o);var t=ct(k[s],o);m.translate(j.sx-j.x||0,j.sy-j.y||0);j.x=t.x;j.y=t.y;m.translate(t.x-j.sx,t.y-j.sy);k.rot&&m.rotate(j.r+t.alpha,t.x,t.y);break;case E:o=+i[s]+r*g*j[s];break;case"colour":o="rgb("+[cy(Q(i[s].r+r*g*j[s].r)),cy(Q(i[s].g+r*g*j[s].g)),cy(Q(i[s].b+r*g*j[s].b))][v](",")+")";break;case"path":o=[];for(var u=0,x=i[s][w];u<x;u++){o[u]=[i[s][u][0]];for(var y=1,z=i[s][u][w];y<z;y++)o[u][y]=+i[s][u][y]+r*g*j[s][u][y];o[u]=o[u][v](q)}o=o[v](q);break;case"csv":switch(s){case"translation":var A=r*g*j[s][0]-l.x,B=r*g*j[s][1]-l.y;l.x+=A;l.y+=B;o=A+q+B;break;case"rotation":o=+i[s][0]+r*g*j[s][0];i[s][1]&&(o+=","+i[s][1]+","+i[s][2]);break;case"scale":o=[+i[s][0]+r*g*j[s][0],+i[s][1]+r*g*j[s][1],2 in k[s]?k[s][2]:p,3 in k[s]?k[s][3]:p][v](q);break;case"clip-rect":o=[];u=4;while(u--)o[u]=+i[s][u]+r*g*j[s][u];break}break;default:var C=[].concat(i[s]);o=[];u=m.paper.customAttributes[s].length;while(u--)o[u]=+C[u]+r*g*j[s][u];break}n[s]=o}m.attr(n);m._run&&m._run.call(m)}else{if(k.along){t=ct(k.along,k.len*!k.back);m.translate(j.sx-(j.x||0)+t.x-j.sx,j.sy-(j.y||0)+t.y-j.sy);k.rot&&m.rotate(j.r+t.alpha,t.x,t.y)}(l.x||l.y)&&m.translate(-l.x,-l.y);k.scale&&(k.scale+=p);m.attr(k);cv.splice(c--,1)}}a.svg&&m&&m.paper&&m.paper.safari();cv[w]&&setTimeout(cw)},cx= function(b,c,d,e,f){var g=d-e;c.timeouts.push(setTimeout(function(){a.is(f,"function")&&f.call(c);c.animate(b,g,b.easing)},e))},cy= function(a){return z(A(a,255),0)},cz= function(a,b){if(a==null)return{x:this._.tx,y:this._.ty,toString:co};this._.tx+=+a;this._.ty+=+b;switch(this.type){case"circle":case"ellipse":this.attr({cx:+a+this.attrs.cx,cy:+b+this.attrs.cy});break;case"rect":case"image":case"text":this.attr({x:+a+this.attrs.x,y:+b+this.attrs.y});break;case"path":var c=bp(this.attrs.path);c[0][1]+=+a;c[0][2]+=+b;this.attr({path:c});break}return this};bO.animateWith= function(a,b,c,d,e){for(var f=0,g=cv.length;f<g;f++)cv[f].el.id==a.id&&(b.start=cv[f].start);return this.animate(b,c,d,e)};bO.animateAlong=cA();bO.animateAlongBack=cA(1);function cA(b){return function(c,d,e,f){var g={back:b};a.is(e,"function")?f=e:g.rot=e;c&&c.constructor==bN&&(c=c.attrs.path);c&&(g.along=c);return this.animate(g,d,f)}}function cB(a,b,c,d,e,f){var g=3*b,h=3*(d-b)-g,i=1-g-h,j=3*c,k=3*(e-c)-j,l=1-j-k;function m(a){return((i*a+h)*a+g)*a}function n(a,b){var c=o(a,b);return((l*c+k)*c+j)*c}function o(a,b){var c,d,e,f,j,k;for(e=a,k=0;k<8;k++){f=m(e)-a;if(B(f)<b)return e;j=(3*i*e+2*h)*e+g;if(B(j)<0.000001)break;e=e-f/j}c=0;d=1;e=a;if(e<c)return c;if(e>d)return d;while(c<d){f=m(e);if(B(f-a)<b)return e;a>f?c=e:d=e;e=(d-c)/2+c}return e}return n(a,1/(200*f))}bO.onAnimation= function(a){this._run=a||0;return this};bO.animate= function(c,d,e,g){var h=this;h.timeouts=h.timeouts||[];if(a.is(e,"function")||!e)g=e||null;if(h.removed){g&&g.call(h);return h}var i={},j={},k=false,l={};for(var m in c)if(c[f](m)){if(X[f](m)||h.paper.customAttributes[f](m)){k=true;i[m]=h.attr(m);i[m]==null&&(i[m]=W[m]);j[m]=c[m];switch(X[m]){case"along":var n=cs(c[m]),o=ct(c[m],n*!(!c.back)),p=h.getBBox();l[m]=n/d;l.tx=p.x;l.ty=p.y;l.sx=o.x;l.sy=o.y;j.rot=c.rot;j.back=c.back;j.len=n;c.rot&&(l.r=S(h.rotate())||0);break;case E:l[m]=(j[m]-i[m])/d;break;case"colour":i[m]=a.getRGB(i[m]);var q=a.getRGB(j[m]);l[m]={r:(q.r-i[m].r)/d,g:(q.g-i[m].g)/d,b:(q.b-i[m].b)/d};break;case"path":var t=bw(i[m],j[m]);i[m]=t[0];var u=t[1];l[m]=[];for(var v=0,x=i[m][w];v<x;v++){l[m][v]=[0];for(var y=1,z=i[m][v][w];y<z;y++)l[m][v][y]=(u[v][y]-i[m][v][y])/d}break;case"csv":var A=r(c[m])[s](b),B=r(i[m])[s](b);switch(m){case"translation":i[m]=[0,0];l[m]=[A[0]/d,A[1]/d];break;case"rotation":i[m]=B[1]==A[1]&&B[2]==A[2]?B:[0,A[1],A[2]];l[m]=[(A[0]-i[m][0])/d,0,0];break;case"scale":c[m]=A;i[m]=r(i[m])[s](b);l[m]=[(A[0]-i[m][0])/d,(A[1]-i[m][1])/d,0,0];break;case"clip-rect":i[m]=r(i[m])[s](b);l[m]=[];v=4;while(v--)l[m][v]=(A[v]-i[m][v])/d;break}j[m]=A;break;default:A=[].concat(c[m]);B=[].concat(i[m]);l[m]=[];v=h.paper.customAttributes[m][w];while(v--)l[m][v]=((A[v]||0)-(B[v]||0))/d;break}}}if(k){var G=a.easing_formulas[e];if(!G){G=r(e).match(P);if(G&&G[w]==5){var H=G;G= function(a){return cB(a,+H[1],+H[2],+H[3],+H[4],d)}}else G= function(a){return a}}cv.push({start:c.start||+(new Date),ms:d,easing:G,from:i,diff:l,to:j,el:h,t:{x:0,y:0}});a.is(g,"function")&&(h._ac=setTimeout(function(){g.call(h)},d));cv[w]==1&&setTimeout(cw)}else{var C=[],D;for(var F in c)if(c[f](F)&&Z.test(F)){m={value:c[F]};F=="from"&&(F=0);F=="to"&&(F=100);m.key=T(F,10);C.push(m)}C.sort(be);C[0].key&&C.unshift({key:0,value:h.attrs});for(v=0,x=C[w];v<x;v++)cx(C[v].value,h,d/100*C[v].key,d/100*(C[v-1]&&C[v-1].key||0),C[v-1]&&C[v-1].value.callback);D=C[C[w]-1].value.callback;D&&h.timeouts.push(setTimeout(function(){D.call(h)},d))}return this};bO.stop= function(){for(var a=0;a<cv.length;a++)cv[a].el.id==this.id&&cv.splice(a--,1);for(a=0,ii=this.timeouts&&this.timeouts.length;a<ii;a++)clearTimeout(this.timeouts[a]);this.timeouts=[];clearTimeout(this._ac);delete this._ac;return this};bO.translate= function(a,b){return this.attr({translation:a+" "+b})};bO[H]= function(){return"Raphaëls object"};a.ae=cv;var cC= function(a){this.items=[];this[w]=0;this.type="set";if(a)for(var b=0,c=a[w];b<c;b++){if(a[b]&&(a[b].constructor==bN||a[b].constructor==cC)){this[this.items[w]]=this.items[this.items[w]]=a[b];this[w]++}}};cC[e][L]= function(){var a,b;for(var c=0,d=arguments[w];c<d;c++){a=arguments[c];if(a&&(a.constructor==bN||a.constructor==cC)){b=this.items[w];this[b]=this.items[b]=a;this[w]++}}return this};cC[e].pop= function(){delete this[this[w]--];return this.items.pop()};for(var cD in bO)bO[f](cD)&&(cC[e][cD]=(function(a){return function(){for(var b=0,c=this.items[w];b<c;b++)this.items[b][a][m](this.items[b],arguments);return this}})(cD));cC[e].attr= function(b,c){if(b&&a.is(b,G)&&a.is(b[0],"object"))for(var d=0,e=b[w];d<e;d++)this.items[d].attr(b[d]);else for(var f=0,g=this.items[w];f<g;f++)this.items[f].attr(b,c);return this};cC[e].animate= function(b,c,d,e){(a.is(d,"function")||!d)&&(e=d||null);var f=this.items[w],g=f,h,i=this,j;e&&(j= function(){!(--f)&&e.call(i)});d=a.is(d,F)?d:j;h=this.items[--g].animate(b,c,d,j);while(g--)this.items[g]&&!this.items[g].removed&&this.items[g].animateWith(h,b,c,d,j);return this};cC[e].insertAfter= function(a){var b=this.items[w];while(b--)this.items[b].insertAfter(a);return this};cC[e].getBBox= function(){var a=[],b=[],c=[],d=[];for(var e=this.items[w];e--;){var f=this.items[e].getBBox();a[L](f.x);b[L](f.y);c[L](f.x+f.width);d[L](f.y+f.height)}a=A[m](0,a);b=A[m](0,b);return{x:a,y:b,width:z[m](0,c)-a,height:z[m](0,d)-b}};cC[e].clone= function(a){a=new cC;for(var b=0,c=this.items[w];b<c;b++)a[L](this.items[b].clone());return a};a.registerFont= function(a){if(!a.face)return a;this.fonts=this.fonts||{};var b={w:a.w,face:{},glyphs:{}},c=a.face["font-family"];for(var d in a.face)a.face[f](d)&&(b.face[d]=a.face[d]);this.fonts[c]?this.fonts[c][L](b):this.fonts[c]=[b];if(!a.svg){b.face["units-per-em"]=T(a.face["units-per-em"],10);for(var e in a.glyphs)if(a.glyphs[f](e)){var g=a.glyphs[e];b.glyphs[e]={w:g.w,k:{},d:g.d&&"M"+g.d[Y](/[mlcxtrv]/g,function(a){return({l:"L",c:"C",x:"z",t:"m",r:"l",v:"c"})[a]||"M"})+"z"};if(g.k)for(var h in g.k)g[f](h)&&(b.glyphs[e].k[h]=g.k[h])}}return a};k.getFont= function(b,c,d,e){e=e||"normal";d=d||"normal";c=+c||({normal:400,bold:700,lighter:300,bolder:800})[c]||400;if(!a.fonts)return;var g=a.fonts[b];if(!g){var h=new RegExp("(^|\\s)"+b[Y](/[^\w\d\s+!~.:_-]/g,p)+"(\\s|$)","i");for(var i in a.fonts)if(a.fonts[f](i)){if(h.test(i)){g=a.fonts[i];break}}}var j;if(g)for(var k=0,l=g[w];k<l;k++){j=g[k];if(j.face["font-weight"]==c&&(j.face["font-style"]==d||!j.face["font-style"])&&j.face["font-stretch"]==e)break}return j};k.print= function(c,d,e,f,g,h,i){h=h||"middle";i=z(A(i||0,1),-1);var j=this.set(),k=r(e)[s](p),l=0,m=p,n;a.is(f,e)&&(f=this.getFont(f));if(f){n=(g||16)/f.face["units-per-em"];var o=f.face.bbox.split(b),q=+o[0],t=+o[1]+(h=="baseline"?o[3]-o[1]+ +f.face.descent:(o[3]-o[1])/2);for(var u=0,v=k[w];u<v;u++){var x=u&&f.glyphs[k[u-1]]||{},y=f.glyphs[k[u]];l+=u?(x.w||f.w)+(x.k&&x.k[k[u]]||0)+f.w*i:0;y&&y.d&&j[L](this.path(y.d).attr({fill:"#000",stroke:"none",translation:[l,0]}))}j.scale(n,n,q,t).translate(c-q,d-t)}return j};a.format= function(b,c){var e=a.is(c,G)?[0][n](c):arguments;b&&a.is(b,F)&&e[w]-1&&(b=b[Y](d,function(a,b){return e[++b]==null?p:e[b]}));return b||p};a.ninja= function(){i.was?h.Raphael=i.is:delete Raphael;return a};a.el=bO;a.st=cC[e];i.was?h.Raphael=a:Raphael=a})()
/**
 * ====================================================================
 * About Sarissa: http://dev.abiss.gr/sarissa
 * ====================================================================
 * Sarissa cross browser XML library - IE XPath Emulation 
 * @version 0.9.9.5
 * @author: Copyright 2004-2008 Emmanouil Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 *
 * This script depends on sarissa.js and provides an API for remote MediaWiki
 * JSON API calls.
 * 
 * @author: Copyright 2003-2008 Emmanouil Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 * ====================================================================
 * Licence
 * ====================================================================
 * Sarissa is free software distributed under the GNU GPL version 2 (see <a href="gpl.txt">gpl.txt</a>) or higher, 
 * GNU LGPL version 2.1 (see <a href="lgpl.txt">lgpl.txt</a>) or higher and Apache Software License 2.0 or higher 
 * (see <a href="asl.txt">asl.txt</a>). This means you can choose one of the three and use that if you like. If 
 * you make modifications under the ASL, i would appreciate it if you submitted those.
 * In case your copy of Sarissa does not include the license texts, you may find
 * them online in various formats at <a href="http://www.gnu.org">http://www.gnu.org</a> and 
 * <a href="http://www.apache.org">http://www.apache.org</a>.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Class that can be used to perform queries against a MediaWiki instance 
 * @constructor
 * @requires Sarissa
 * @param {String} apiUrl the base API URL, e.g. <a href="http://en.wikipedia.org/w/api.php" title="Link to Wikipedia's MediaWiki API Instance">http://en.wikipedia.org/w/api.php</a>
 * @param {Function} callback the callback function to use
 */ 
function SarissaMediaWikiContext(apiUrl, arrLanguages){
	this.baseUrl = apiUrl;
	this.format = "json";
	this.languages = arrLanguages;
};


/**
 * Asynchronously obtain an article from the Wiki, then pass it to the given 
 * callback function as JSON data. This method does any required URL encoding for you.
 * @param {String} sFor the article name
 * @param {int} iLimit the maximum number of results to retreive
 */ 
SarissaMediaWikiContext.prototype.doArticleGet = function(sFor, callback){
	Sarissa.setRemoteJsonCallback(
		this.baseUrl + 
			//"?action=query&redirects&format=" + 
			"?action=parse&redirects&format=" +
			this.format + 
			"&page" + 
			encodeURIComponent(sFor), 
		callback);
};

/**
 * Asynchronously obtain an article's backlinks from the Wiki, then pass those to the given 
 * callback function as JSON data. This method does any required URL encoding for you.
 * @param {String} sFor the article name
 * @param {int} iLimit the maximum number of results to retreive
 * @param {Function} callback the callback function to use
 */ 
SarissaMediaWikiContext.prototype.doBacklinksGet = function(sFor, iLimit, callback){
	Sarissa.setRemoteJsonCallback(
		this.baseUrl + 
			"?&generator=backlinks&format=" + 
			this.format + 
			"&gbllimit=" + 
			iLimit + 
			"&gbltitle" + 
			encodeURIComponent(sFor), 
		callback);
};

/**
 * Asynchronously perform a Wiki Search, passing the results to the given 
 * callback function as JSON data. This method does any required URL encoding for you.
 * @param {String} sFor the terms to look for
 * @param {int} iLimit the maximum number of results to retreive
 * @param {Function} callback the callback function to use
 */ 
SarissaMediaWikiContext.prototype.doSearch = function(sFor, iLimit, callback){
	Sarissa.setRemoteJsonCallback(
		this.baseUrl + 
			"?action=query&list=search&srsearch=" + 
			encodeURIComponent(sFor) + 
			"&srwhat=text&srnamespace=0&format=" +
			this.format + 
			"&srlimit=" + 
			iLimit, 
		callback);
};

/**
 * Asynchronously obtain the articles belonging to a category from the Wiki, 
 * then pass those to the given callback function as JSON data. This method 
 * does any required URL encoding for you.
 * @param {String} sFor the article name
 * @param {int} iLimit the maximum number of results to retreive
 * @param {Function} callback the callback function to use
 */ 
SarissaMediaWikiContext.prototype.doCategorySearch = function(sFor, iLimit, callback){
	Sarissa.setRemoteJsonCallback(
		this.baseUrl + 
			"?format=" + 
			this.format + 
			"&list=categorymembers&action=query&cmlimit=" + 
			iLimit + 
			"&cmtitle=Category:" + 
			encodeURIComponent(sFor), 
		callback);
};
/**
 * Asynchronously obtain the Wiki categories an article belongs to, 
 * then pass those to the given callback function as JSON data. This method 
 * does any required URL encoding for you.
 * @param {String} sFor the article name
 * @param {int} iLimit the maximum number of results to retreive
 * @param {Function} callback the callback function to use
 */ 
SarissaMediaWikiContext.prototype.doArticleCategoriesGet = function(sFor, iLimit, callback){
	Sarissa.setRemoteJsonCallback(
		this.baseUrl + 
			"?format=" + 
			this.format + 
			"&action=query&prop=categories&titles=" + 
			encodeURIComponent(sFor), 
		callback);
};




/*
 * ====================================================================
 * About Sarissa: http://dev.abiss.gr/sarissa
 * ====================================================================
 * Sarissa table utils are dependent on sarissa.js and are used for 
 * stuff like table sorting.
 * @version 0.9.9.5
 * @author: Copyright 2004-2008 Emmanouil Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 * ====================================================================
 * Licence
 * ====================================================================
 * Sarissa is free software distributed under the GNU GPL version 2 (see <a href="gpl.txt">gpl.txt</a>) or higher, 
 * GNU LGPL version 2.1 (see <a href="lgpl.txt">lgpl.txt</a>) or higher and Apache Software License 2.0 or higher 
 * (see <a href="asl.txt">asl.txt</a>). This means you can choose one of the three and use that if you like. If 
 * you make modifications under the ASL, i would appreciate it if you submitted those.
 * In case your copy of Sarissa does not include the license texts, you may find
 * them online in various formats at <a href="http://www.gnu.org">http://www.gnu.org</a> and 
 * <a href="http://www.apache.org">http://www.apache.org</a>.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * Sort the table data based on the column corresponding to the given TH element (clickedElem).
 * @memberOf Sarissa
 * @param {Node} clickedElem the table heading (<code>th</code>) initiating the sort.
 * @param {Function} iFunc the custom sort function if needed. Default (null) is case-sensitive sort.
 * You can also use <code>Sarissa.SORT_IGNORE_CASE</code>, <code>Sarissa.SORT_DATE_US</code>, 
 * and <code>Sarissa.SORT_DATE_EU</code>
 * @param {boolean} bSkipCache whether to skip the data cache and read table data all over again. Setting this
 * to <code>true</code> means the cache for the table, if it exists, will not be updated either. Defaul is <code>false</code>
 * @param {Function} oCallbac a callback function to be executed when the table is 
 * sorted and updated. The callback function may be used for effects for example. The parameters 
 * passed to the callback are the table as a DOM node and the sort column index (zero based <code>int</code>)
 * @requires Sarissa sarissa.js
 */
Sarissa.sortHtmlTableData = function(clickedElem, iFunc, bSkipCache, oCallbac){
	// get the table
	var oTbl = clickedElem.parentNode.parentNode;
	while(oTbl.nodeName.toLowerCase() != "table"){
	    oTbl = oTbl.parentNode;
	}
	// we need a table ID for the cache
	if(!oTbl.id){
		oTbl.id = "SarissaTable"+ (Sarissa.tableIdGenCount++);
	}
	// the column to sort on
	var iColIndex = clickedElem.cellIndex;
	var matrix;
	// use the cache if available and permitted
	if(!bSkipCache && Sarissa.tableDataCache[oTbl.id]){
		matrix = Sarissa.tableDataCache[oTbl.id];
	}
	else{
		// read table, skip any rows containing headings, cache if permitted
		matrix = this.getArrayFromTableData(oTbl, null, null, "th");
		if(!bSkipCache){
			Sarissa.tableDataCache[oTbl.id] = matrix;
		}
	}
	// init state persistence as needed
	if(!Sarissa.tableColumnSortStates[oTbl.id]){
		Sarissa.tableColumnSortStates[oTbl.id] = [];
	}
	// build a array to sort from the specific column data, adding 
	// original index info as a suffix
	var sortedColumn = [];
	for(var i=0; i < matrix.length;i++){
		sortedColumn[i] = Sarissa.stripTags(matrix[i][iColIndex]) + "_mbns_" + i;
	}
	// sort the array
	if(iFunc){
		sortedColumn.sort(iFunc);
	}
	else{
		sortedColumn.sort();
	}
	// persist column state
	var sortOrder = Sarissa.tableColumnSortStates[oTbl.id][iColIndex];
	if(sortOrder != "asc"){
		Sarissa.tableColumnSortStates[oTbl.id][iColIndex] = "asc";
	}
	else{
		sortedColumn.reverse();
		Sarissa.tableColumnSortStates[oTbl.id][iColIndex] = "desc";
	}
	// create the sorted matrix based on sortedColumn
	var sortedMatrix = [];
	for(var j=0; j < matrix.length; j++){
		var indexItem = sortedColumn[j];
		var iRow = indexItem.substring(indexItem.indexOf("_mbns_")+6, indexItem.length);
		sortedMatrix[j] = [];
		for(var k=0; k < matrix[j].length; k++){
			sortedMatrix[j][k] = matrix[iRow][k];
		}
	}
	// update table data, skipping rows with headings
	this.updateTableData(oTbl, sortedMatrix, null, null, "th");
	if(oCallbac){
		oCallbac(oTbl, iColIndex);	
	}
};

/**
 * Used for generating table IDs, which are required for the cache and sort state persistance 
 * @memberOf Sarissa
 * @private
 */
Sarissa.tableIdGenCount = 0;

/**
 * Used for persisting sort state per table column
 * @memberOf Sarissa
 * @private
 */
Sarissa.tableColumnSortStates = [];

/**
 * Used for caching table data.
 * @memberOf Sarissa
 */
Sarissa.tableDataCache = [];

/**
 * Keep track of the cache size. The length property is not for associative arrays 
 * and I really dont want to add 50 lines and implement a PseudoHashMap right now :-)
 * @memberOf Sarissa
 * @private
 */
Sarissa.tableDataCacheSize = 0;

/**
 * The table data cache size, used for sorting HTML tables. You can change it, default is 5 (tables). When a  
 * table is cached exceeding the cache size, the oldest entry is disgarded from the cache.
 * @memberOf Sarissa
 */
Sarissa.tableDataCacheMaxSize = 5;

/**
 * Updates the cache, discards oldest entry if cache size is exceeded.
 * @memberOf Sarissa
 * @private
 */
Sarissa.tableDataCachePut = function(sTableId, oArr){
	if(Sarissa.tableDataCacheSize.length >= Sarissa.tableDataCacheMaxSize){
		Sarissa.tableDataCache.shift();
		Sarissa.tableDataCacheSize--;
	}
	Sarissa.tableDataCache[sTableId] = oArr;
	Sarissa.tableDataCacheSize++;
};
/**
 * Updates the cache of a specific table by reposition a column in the cached data.
 * This is usefull if you use DHTML to visually reposition columns and need to 
 * synchronize the cache.
 * @memberOf Sarissa
 * @private
 */
Sarissa.tableDataCacheMoveColumn = function(sTableId, oldColumnIndex, newColumnIndex){	
	var oldMatrix = Sarissa.tableDataCache[sTableId];
	var newMatrix = [];
	// iterate rows
	var oldRow, movedColumn, newRow;
	for(var i=0; i<oldMatrix.length; i++){
		oldRow = oldMatrix[i];
		movedColumn = oldRow.splice(oldColumnIndex, 1);
		newRow = [];
		// reposition column value
		for(var j=0;j<oldArr.length;J++){
			if(j == newColumnIndex){
				newRow.put(movedColumn);
			}
			newRow.put(oldRow[j]);
		}
		newMatrix[i] = newRow;
	}
	Sarissa.tableDataCache[sTableId] = newMatrix;
};

/**
 * Function for case-insensitive sorting or simple comparison. Can be used as 
 * a parameter to <code>Array.sort()</code>.
 * @memberOf Sarissa
 * @param a a string
 * @param b a string
 * @return -1, 0 or 1 depending on whether <code>a</code> is "less than", equal or "greater than" <code>b</code>
 */
Sarissa.SORT_IGNORE_CASE = function(a, b){
  var strA = a.toLowerCase(),
      strB = b.toLowerCase();
  if(strA < strB) return -1;
  else if(strA > strB) return 1;
  else return 0;
};

/**
 * Function for comparing US dates. Can be used as 
 * a parameter to <code>Array.sort()</code>.
 * @memberOf Sarissa
 * @param a a string
 * @param b a string
 * @return -1, 0 or 1 depending on whether <code>a</code> is "less than", equal or "greater than" <code>b</code>
 */
Sarissa.SORT_DATE_US = function(a, b){
	var datA = new Date(a.substring(0, a.lastIndexOf("_mbns_"))),
		datB = new Date(b.substring(0, b.lastIndexOf("_mbns_")));
	if(datA < datB)	return -1;
	else if(datA > datB) return 1;
    else return 0;
    
};

/**
 * Function for comparing EU dates. Can be used as 
 * a parameter to <code>Array.sort()</code>.
 * @memberOf Sarissa
 * @param a a string
 * @param b a string
 * @return -1, 0 or 1 depending on whether <code>a</code> is "less than", equal or "greater than" <code>b</code>
 */
Sarissa.SORT_DATE_EU = function(a, b){
	var strA = a.substring(0, a.lastIndexOf("_mbns_")).split("/"), 
		strB = b.substring(0, b.lastIndexOf("_mbns_")).split("/"),
		datA = new Date(strA[2], strA[1], strA[0]), 
		datB = new Date(strB[2], strB[1], strB[0]);
	if(datA < datB) return -1;
	else if(datA > datB) return 1;
    else return 0;
};

/**
 * Get the data of the given element as a two-dimensional array. The 
 * given XML or HTML Element must match the structure of an HTML table, 
 * although element names may be different.
 * @memberOf Sarissa
 * @param oElem an HTML or XML table. The method works out of the box 
 * for <code>table</code>, <code>tbody</code>, <code>thead</code> 
 * or <code>tfooter</code> elements. For custom XML tables, the 
 * <code>sRowName</code> <code>sCellName</code> must be used.
 * @param sRowName the row element names. Default is <code>tr</code>
 * @param sCellName the row element names. Default is <code>td</code>
 * @param sHeadingName the heading element names. If you use this, rows with 
 * headings will be <strong>skipped</strong>. To skip headings when reading 
 * HTML tables use <code>th</code>
 * @param bStripTags whether to strip markup from cell contents. Default is <code>false</code>
 * @return a two-dimensional array with the data found in the given element's rows
 */
Sarissa.getArrayFromTableData = function(oElem, sRowName, sCellName, sHeadingName, bStripTags){
	if(!sRowName){
		sRowName = "tr"
	}
	if(!sCellName){
		sCellName = "td"
	}
	if(!sHeadingName){
		sHeadingName = "th"
	}
	var rows = oElem.getElementsByTagName(sRowName);
	var matrix = [];
	for(var i=0, j=0; i < rows.length; i++) {
		// skip rows with headings
		var row = rows[i];
		if((!sHeadingName) || row.getElementsByTagName(sHeadingName).length == 0){
			matrix[j] = [];
			var cells = row.getElementsByTagName(sCellName);
			for(var k=0; k < cells.length; k++){
				matrix[j][k] = bStripTags ? Sarissa.stripTags(cells[k].innerHTML) : cells[k].innerHTML;
			}
			j++;
		}
	}
	return matrix;
};

/**
 * Update the data of the given element using the giventwo-dimensional array as a source. The 
 * given XML or HTML Element must match the structure of an HTML table.
 * @memberOf Sarissa
 * @param oElem an HTML or XML table. The method works out of the box 
 * for <code>table</code>, <code>tbody</code>, <code>thead</code> 
 * or <code>tfooter</code> elements. For custom XML tables, the 
 * <code>sRowName</code> <code>sCellName</code> must be used.
 * @param sRowName the row element names. Default is <code>tr</code>
 * @param sCellName the row element names. Default is <code>td</code>
 * @param sHeadingName the heading element names. If you use this, rows with 
 * headings will be <strong>skipped</strong>. To skip headings when reading 
 * HTML tables use <code>th</code>
 */
Sarissa.updateTableData = function(oElem, newData, sRowName, sCellName, sHeadingName){
	if(!sRowName){
		sRowName = "tr"
	}
	if(!sCellName){
		sCellName = "td"
	}
	var rows = oElem.getElementsByTagName(sRowName);
	for(var i=0, j=0; i < newData.length && j < rows.length; j++){
		// skip rows with headings
		var row = rows[j];
		if((!sHeadingName) || row.getElementsByTagName(sHeadingName).length == 0){
			var cells = row.getElementsByTagName(sCellName);
			for(var k=0; k < cells.length; k++){
				cells[k].innerHTML = newData[i][k];
			}
			i++;
		}
	}
};



/*
 * ====================================================================
 * About Sarissa: http://dev.abiss.gr/sarissa
 * ====================================================================
 * Sarissa is an ECMAScript library acting as a cross-browser wrapper for native XML APIs.
 * The library supports Gecko based browsers like Mozilla and Firefox,
 * Internet Explorer (5.5+ with MSXML3.0+), Konqueror, Safari and Opera
 * @version 0.9.9.5
 * @author: Copyright 2004-2008 Emmanouil Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 * ====================================================================
 * Licence
 * ====================================================================
 * Sarissa is free software distributed under the GNU GPL version 2 (see <a href="gpl.txt">gpl.txt</a>) or higher, 
 * GNU LGPL version 2.1 (see <a href="lgpl.txt">lgpl.txt</a>) or higher and Apache Software License 2.0 or higher 
 * (see <a href="asl.txt">asl.txt</a>). This means you can choose one of the three and use that if you like. If 
 * you make modifications under the ASL, i would appreciate it if you submitted those.
 * In case your copy of Sarissa does not include the license texts, you may find
 * them online in various formats at <a href="http://www.gnu.org">http://www.gnu.org</a> and 
 * <a href="http://www.apache.org">http://www.apache.org</a>.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/**
 * <p>Sarissa is a utility class. Provides "static" methods for DOMDocument, 
 * DOM Node serialization to XML strings and other utility goodies.</p>
 * @constructor
 * @static
 */
function Sarissa(){}
Sarissa.VERSION = "0.9.9.5";
Sarissa.PARSED_OK = "Document contains no parsing errors";
Sarissa.PARSED_EMPTY = "Document is empty";
Sarissa.PARSED_UNKNOWN_ERROR = "Not well-formed or other error";
Sarissa.IS_ENABLED_TRANSFORM_NODE = false;
Sarissa.REMOTE_CALL_FLAG = "gr.abiss.sarissa.REMOTE_CALL_FLAG";
/** @private */
Sarissa._lastUniqueSuffix = 0;
/** @private */
Sarissa._getUniqueSuffix = function(){
	return Sarissa._lastUniqueSuffix++;
};
/** @private */
Sarissa._SARISSA_IEPREFIX4XSLPARAM = "";
/** @private */
Sarissa._SARISSA_HAS_DOM_IMPLEMENTATION = document.implementation && true;
/** @private */
Sarissa._SARISSA_HAS_DOM_CREATE_DOCUMENT = Sarissa._SARISSA_HAS_DOM_IMPLEMENTATION && document.implementation.createDocument;
/** @private */
Sarissa._SARISSA_HAS_DOM_FEATURE = Sarissa._SARISSA_HAS_DOM_IMPLEMENTATION && document.implementation.hasFeature;
/** @private */
Sarissa._SARISSA_IS_MOZ = Sarissa._SARISSA_HAS_DOM_CREATE_DOCUMENT && Sarissa._SARISSA_HAS_DOM_FEATURE;
/** @private */
Sarissa._SARISSA_IS_SAFARI = navigator.userAgent.toLowerCase().indexOf("safari") != -1 || navigator.userAgent.toLowerCase().indexOf("konqueror") != -1;
/** @private */
Sarissa._SARISSA_IS_SAFARI_OLD = Sarissa._SARISSA_IS_SAFARI && (parseInt((navigator.userAgent.match(/AppleWebKit\/(\d+)/)||{})[1], 10) < 420);
/** @private */
Sarissa._SARISSA_IS_IE = document.all && window.ActiveXObject && navigator.userAgent.toLowerCase().indexOf("msie") > -1  && navigator.userAgent.toLowerCase().indexOf("opera") == -1;
/** @private */
Sarissa._SARISSA_IS_OPERA = navigator.userAgent.toLowerCase().indexOf("opera") != -1;
if(!window.Node || !Node.ELEMENT_NODE){
    Node = {ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5,  ENTITY_NODE: 6, PROCESSING_INSTRUCTION_NODE: 7, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_TYPE_NODE: 10, DOCUMENT_FRAGMENT_NODE: 11, NOTATION_NODE: 12};
}

//This breaks for(x in o) loops in the old Safari
if(Sarissa._SARISSA_IS_SAFARI_OLD){
	HTMLHtmlElement = document.createElement("html").constructor;
	Node = HTMLElement = {};
	HTMLElement.prototype = HTMLHtmlElement.__proto__.__proto__;
	HTMLDocument = Document = document.constructor;
	var x = new DOMParser();
	XMLDocument = x.constructor;
	Element = x.parseFromString("<Single />", "text/xml").documentElement.constructor;
	x = null;
}
if(typeof XMLDocument == "undefined" && typeof Document !="undefined"){ XMLDocument = Document; } 

// IE initialization
if(Sarissa._SARISSA_IS_IE){
    // for XSLT parameter names, prefix needed by IE
    Sarissa._SARISSA_IEPREFIX4XSLPARAM = "xsl:";
    // used to store the most recent ProgID available out of the above
    var _SARISSA_DOM_PROGID = "";
    var _SARISSA_XMLHTTP_PROGID = "";
    var _SARISSA_DOM_XMLWRITER = "";
    /**
     * Called when the sarissa.js file is parsed, to pick most recent
     * ProgIDs for IE, then gets destroyed.
     * @memberOf Sarissa
     * @private
     * @param idList an array of MSXML PROGIDs from which the most recent will be picked for a given object
     * @param enabledList an array of arrays where each array has two items; the index of the PROGID for which a certain feature is enabled
     */
    Sarissa.pickRecentProgID = function(idList){
        // found progID flag
        var bFound = false, e;
        var o2Store;
        for(var i=0; i < idList.length && !bFound; i++){
            try{
                var oDoc = new ActiveXObject(idList[i]);
                o2Store = idList[i];
                bFound = true;
            }catch (objException){
                // trap; try next progID
                e = objException;
            }
        }
        if (!bFound) {
            throw "Could not retrieve a valid progID of Class: " + idList[idList.length-1]+". (original exception: "+e+")";
        }
        idList = null;
        return o2Store;
    };
    // pick best available MSXML progIDs
    _SARISSA_DOM_PROGID = null;
    _SARISSA_THREADEDDOM_PROGID = null;
    _SARISSA_XSLTEMPLATE_PROGID = null;
    _SARISSA_XMLHTTP_PROGID = null;
    // commenting the condition out; we need to redefine XMLHttpRequest 
    // anyway as IE7 hardcodes it to MSXML3.0 causing version problems 
    // between different activex controls 
    //if(!window.XMLHttpRequest){
    /**
     * Emulate XMLHttpRequest
     * @constructor
     */
    XMLHttpRequest = function() {
        if(!_SARISSA_XMLHTTP_PROGID){
            _SARISSA_XMLHTTP_PROGID = Sarissa.pickRecentProgID(["Msxml2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"]);
        }
        return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
    };
    //}
    // we dont need this anymore
    //============================================
    // Factory methods (IE)
    //============================================
    // see non-IE version
    Sarissa.getDomDocument = function(sUri, sName){
        if(!_SARISSA_DOM_PROGID){
        	try{
        		_SARISSA_DOM_PROGID = Sarissa.pickRecentProgID(["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"]);
        	}catch(e){
        		_SARISSA_DOM_PROGID = "noActiveX";
        	}
        }

        // Not sure how far IE can carry this but try to do something useful when ActiveX is disabled
        var oDoc = _SARISSA_DOM_PROGID == "noActiveX" ? document.createElement("xml") : new ActiveXObject(_SARISSA_DOM_PROGID);
        // set validation off, make sure older IEs dont choke (no time or IEs to test ;-)
        try{
        	oDoc.validateOnParse = false; 
        	oDoc.resolveExternals = "false";
        	oDoc.setProperty("ProhibitDTD", false);
        }catch(e){}
        
        // if a root tag name was provided, we need to load it in the DOM object
        if (sName){
            // create an artifical namespace prefix 
            // or reuse existing prefix if applicable
            var prefix = "";
            if(sUri){
                if(sName.indexOf(":") > 1){
                    prefix = sName.substring(0, sName.indexOf(":"));
                    sName = sName.substring(sName.indexOf(":")+1); 
                }else{
                    prefix = "a" + Sarissa._getUniqueSuffix();
                }
            }
            // use namespaces if a namespace URI exists
            if(sUri){
                oDoc.loadXML('<' + prefix+':'+sName + " xmlns:" + prefix + "=\"" + sUri + "\"" + " />");
            } else {
                oDoc.loadXML('<' + sName + " />");
            }
        }
        return oDoc;
    };
    // see non-IE version   
    Sarissa.getParseErrorText = function(oDoc) {
        var parseErrorText = Sarissa.PARSED_OK;
        if(oDoc && oDoc.parseError && oDoc.parseError.errorCode && oDoc.parseError.errorCode != 0){
            parseErrorText = "XML Parsing Error: " + oDoc.parseError.reason + 
                "\nLocation: " + oDoc.parseError.url + 
                "\nLine Number " + oDoc.parseError.line + ", Column " + 
                oDoc.parseError.linepos + 
                ":\n" + oDoc.parseError.srcText +
                "\n";
            for(var i = 0;  i < oDoc.parseError.linepos;i++){
                parseErrorText += "-";
            }
            parseErrorText +=  "^\n";
        }
        else if(oDoc.documentElement === null){
            parseErrorText = Sarissa.PARSED_EMPTY;
        }
        return parseErrorText;
    };
    // see non-IE version
    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
        oDoc.setProperty("SelectionLanguage", "XPath");
        oDoc.setProperty("SelectionNamespaces", sNsSet);
    };
    /**
     * A class that reuses the same XSLT stylesheet for multiple transforms.
     * @constructor
     */
    XSLTProcessor = function(){
        if(!_SARISSA_XSLTEMPLATE_PROGID){
            _SARISSA_XSLTEMPLATE_PROGID = Sarissa.pickRecentProgID(["Msxml2.XSLTemplate.6.0", "MSXML2.XSLTemplate.3.0"]);
        }
        this.template = new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
        this.processor = null;
    };
    /**
     * Imports the given XSLT DOM and compiles it to a reusable transform
     * <b>Note:</b> If the stylesheet was loaded from a URL and contains xsl:import or xsl:include elements,it will be reloaded to resolve those
     * @param {DOMDocument} xslDoc The XSLT DOMDocument to import
     */
    XSLTProcessor.prototype.importStylesheet = function(xslDoc){
        if(!_SARISSA_THREADEDDOM_PROGID){
            _SARISSA_THREADEDDOM_PROGID = Sarissa.pickRecentProgID(["MSXML2.FreeThreadedDOMDocument.6.0", "MSXML2.FreeThreadedDOMDocument.3.0"]);
        }
        xslDoc.setProperty("SelectionLanguage", "XPath");
        xslDoc.setProperty("SelectionNamespaces", "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
        // convert stylesheet to free threaded
        var converted = new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
        // make included/imported stylesheets work if exist and xsl was originally loaded from url
        try{
            converted.resolveExternals = true; 
            converted.setProperty("AllowDocumentFunction", true); 
            converted.setProperty("AllowXsltScript", true);
        }
        catch(e){
            // Ignore. "AllowDocumentFunction" and "AllowXsltScript" is only supported in MSXML 3.0 SP4+ and 3.0 SP8+ respectively.
        } 
        if(xslDoc.url && xslDoc.selectSingleNode("//xsl:*[local-name() = 'import' or local-name() = 'include']") != null){
            converted.async = false;
            converted.load(xslDoc.url);
        } 
        else {
            converted.loadXML(xslDoc.xml);
        }
        converted.setProperty("SelectionNamespaces", "xmlns:xsl='http://www.w3.org/1999/XSL/Transform'");
        var output = converted.selectSingleNode("//xsl:output");
        //this.outputMethod = output ? output.getAttribute("method") : "html";
        if(output) {
            this.outputMethod = output.getAttribute("method");
        } 
        else {
            delete this.outputMethod;
        } 
        this.template.stylesheet = converted;
        this.processor = this.template.createProcessor();
        // for getParameter and clearParameters
        this.paramsSet = [];
    };

    /**
     * Transform the given XML DOM and return the transformation result as a new DOM document
     * @param {DOMDocument} sourceDoc The XML DOMDocument to transform
     * @return {DOMDocument} The transformation result as a DOM Document
     */
    XSLTProcessor.prototype.transformToDocument = function(sourceDoc){
        // fix for bug 1549749
        var outDoc;
        if(_SARISSA_THREADEDDOM_PROGID){
            this.processor.input=sourceDoc;
            outDoc=new ActiveXObject(_SARISSA_DOM_PROGID);
            this.processor.output=outDoc;
            this.processor.transform();
            return outDoc;
        }
        else{
            if(!_SARISSA_DOM_XMLWRITER){
                _SARISSA_DOM_XMLWRITER = Sarissa.pickRecentProgID(["Msxml2.MXXMLWriter.6.0", "Msxml2.MXXMLWriter.3.0", "MSXML2.MXXMLWriter", "MSXML.MXXMLWriter", "Microsoft.XMLDOM"]);
            }
            this.processor.input = sourceDoc;
            outDoc = new ActiveXObject(_SARISSA_DOM_XMLWRITER);
            this.processor.output = outDoc; 
            this.processor.transform();
            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
            oDoc.loadXML(outDoc.output+"");
            return oDoc;
        }
    };
    
    /**
     * Transform the given XML DOM and return the transformation result as a new DOM fragment.
     * <b>Note</b>: The xsl:output method must match the nature of the owner document (XML/HTML).
     * @param {DOMDocument} sourceDoc The XML DOMDocument to transform
     * @param {DOMDocument} ownerDoc The owner of the result fragment
     * @return {DOMDocument} The transformation result as a DOM Document
     */
    XSLTProcessor.prototype.transformToFragment = function(sourceDoc, ownerDoc) {
        this.processor.input = sourceDoc;
        this.processor.transform();
        var s = this.processor.output;
        var f = ownerDoc.createDocumentFragment();
        var container;
        if (this.outputMethod == 'text') {
            f.appendChild(ownerDoc.createTextNode(s));
        } else if (ownerDoc.body && ownerDoc.body.innerHTML) {
            container = ownerDoc.createElement('div');
            container.innerHTML = s;
            while (container.hasChildNodes()) {
                f.appendChild(container.firstChild);
            }
        }
        else {
            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
            if (s.substring(0, 5) == '<?xml') {
                s = s.substring(s.indexOf('?>') + 2);
            }
            var xml = ''.concat('<my>', s, '</my>');
            oDoc.loadXML(xml);
            container = oDoc.documentElement;
            while (container.hasChildNodes()) {
                f.appendChild(container.firstChild);
            }
        }
        return f;
    };
    
    /**
     * Set global XSLT parameter of the imported stylesheet. This method should 
     * only be used <strong>after</strong> the importStylesheet method for the 
     * context XSLTProcessor instance.
     * @param {String} nsURI The parameter namespace URI
     * @param {String} name The parameter base name
     * @param {String} value The new parameter value
     */
     XSLTProcessor.prototype.setParameter = function(nsURI, name, value){
         // make value a zero length string if null to allow clearing
         value = value ? value : "";
         // nsURI is optional but cannot be null
         if(nsURI){
             this.processor.addParameter(name, value, nsURI);
         }else{
             this.processor.addParameter(name, value);
         }
         // update updated params for getParameter
         nsURI = "" + (nsURI || "");
         if(!this.paramsSet[nsURI]){
             this.paramsSet[nsURI] = [];
         }
         this.paramsSet[nsURI][name] = value;
     };
    /**
     * Gets a parameter if previously set by setParameter. Returns null
     * otherwise
     * @param {String} name The parameter base name
     * @param {String} value The new parameter value
     * @return {String} The parameter value if reviously set by setParameter, null otherwise
     */
    XSLTProcessor.prototype.getParameter = function(nsURI, name){
        nsURI = "" + (nsURI || "");
        if(this.paramsSet[nsURI] && this.paramsSet[nsURI][name]){
            return this.paramsSet[nsURI][name];
        }else{
            return null;
        }
    };
    
    /**
     * Clear parameters (set them to default values as defined in the stylesheet itself)
     */
    XSLTProcessor.prototype.clearParameters = function(){
        for(var nsURI in this.paramsSet){
            for(var name in this.paramsSet[nsURI]){
                if(nsURI!=""){
                    this.processor.addParameter(name, "", nsURI);
                }else{
                    this.processor.addParameter(name, "");
                }
            }
        }
        this.paramsSet = [];
    };
}else{ /* end IE initialization, try to deal with real browsers now ;-) */
    if(Sarissa._SARISSA_HAS_DOM_CREATE_DOCUMENT){
        /**
         * <p>Ensures the document was loaded correctly, otherwise sets the
         * parseError to -1 to indicate something went wrong. Internal use</p>
         * @private
         */
        Sarissa.__handleLoad__ = function(oDoc){
            Sarissa.__setReadyState__(oDoc, 4);
        };
        /**
        * <p>Attached by an event handler to the load event. Internal use.</p>
        * @private
        */
        _sarissa_XMLDocument_onload = function(){
            Sarissa.__handleLoad__(this);
        };
        /**
         * <p>Sets the readyState property of the given DOM Document object.
         * Internal use.</p>
         * @memberOf Sarissa
         * @private
         * @param oDoc the DOM Document object to fire the
         *          readystatechange event
         * @param iReadyState the number to change the readystate property to
         */
        Sarissa.__setReadyState__ = function(oDoc, iReadyState){
            oDoc.readyState = iReadyState;
            oDoc.readystate = iReadyState;
            if (oDoc.onreadystatechange != null && typeof oDoc.onreadystatechange == "function") {
                oDoc.onreadystatechange();
            }
        };
        
        Sarissa.getDomDocument = function(sUri, sName){
            var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
            if(!oDoc.onreadystatechange){
            
                /**
                * <p>Emulate IE's onreadystatechange attribute</p>
                */
                oDoc.onreadystatechange = null;
            }
            if(!oDoc.readyState){
                /**
                * <p>Emulates IE's readyState property, which always gives an integer from 0 to 4:</p>
                * <ul><li>1 == LOADING,</li>
                * <li>2 == LOADED,</li>
                * <li>3 == INTERACTIVE,</li>
                * <li>4 == COMPLETED</li></ul>
                */
                oDoc.readyState = 0;
            }
            oDoc.addEventListener("load", _sarissa_XMLDocument_onload, false);
            return oDoc;
        };
        if(window.XMLDocument){
            // do nothing
        }// TODO: check if the new document has content before trying to copynodes, check  for error handling in DOM 3 LS
        else if(Sarissa._SARISSA_HAS_DOM_FEATURE && window.Document && !Document.prototype.load && document.implementation.hasFeature('LS', '3.0')){
    		//Opera 9 may get the XPath branch which gives creates XMLDocument, therefore it doesn't reach here which is good
            /**
            * <p>Factory method to obtain a new DOM Document object</p>
            * @memberOf Sarissa
            * @param {String} sUri the namespace of the root node (if any)
            * @param {String} sUri the local name of the root node (if any)
            * @returns {DOMDOcument} a new DOM Document
            */
            Sarissa.getDomDocument = function(sUri, sName){
                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
                return oDoc;
            };
        }
        else {
            Sarissa.getDomDocument = function(sUri, sName){
                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
                // looks like safari does not create the root element for some unknown reason
                if(oDoc && (sUri || sName) && !oDoc.documentElement){
                    oDoc.appendChild(oDoc.createElementNS(sUri, sName));
                }
                return oDoc;
            };
        }
    }//if(Sarissa._SARISSA_HAS_DOM_CREATE_DOCUMENT)
}
//==========================================
// Common stuff
//==========================================
if(!window.DOMParser){
    if(Sarissa._SARISSA_IS_SAFARI){
        /**
         * DOMParser is a utility class, used to construct DOMDocuments from XML strings
         * @constructor
         */
        DOMParser = function() { };
        /** 
        * Construct a new DOM Document from the given XMLstring
        * @param {String} sXml the given XML string
        * @param {String} contentType the content type of the document the given string represents (one of text/xml, application/xml, application/xhtml+xml). 
        * @return {DOMDocument} a new DOM Document from the given XML string
        */
        DOMParser.prototype.parseFromString = function(sXml, contentType){
            var xmlhttp = new XMLHttpRequest();
            xmlhttp.open("GET", "data:text/xml;charset=utf-8," + encodeURIComponent(sXml), false);
            xmlhttp.send(null);
            return xmlhttp.responseXML;
        };
    }else if(Sarissa.getDomDocument && Sarissa.getDomDocument() && Sarissa.getDomDocument(null, "bar").xml){
        DOMParser = function() { };
        DOMParser.prototype.parseFromString = function(sXml, contentType){
            var doc = Sarissa.getDomDocument();
            try{
            	doc.validateOnParse = false; 
            	doc.setProperty("ProhibitDTD", false);
            }catch(e){}
            doc.loadXML(sXml);
            return doc;
        };
    }
}

if((typeof(document.importNode) == "undefined") && Sarissa._SARISSA_IS_IE){
    try{
        /**
        * Implementation of importNode for the context window document in IE.
        * If <code>oNode</code> is a TextNode, <code>bChildren</code> is ignored.
        * @param {DOMNode} oNode the Node to import
        * @param {boolean} bChildren whether to include the children of oNode
        * @returns the imported node for further use
        */
        document.importNode = function(oNode, bChildren){
            var tmp;
            if (oNode.nodeName=='#text') {
                return document.createTextNode(oNode.data);
            }
            else {
                if(oNode.nodeName == "tbody" || oNode.nodeName == "tr"){
                    tmp = document.createElement("table");
                }
                else if(oNode.nodeName == "td"){
                    tmp = document.createElement("tr");
                }
                else if(oNode.nodeName == "option"){
                    tmp = document.createElement("select");
                }
                else{
                    tmp = document.createElement("div");
                }
                if(bChildren){
                    tmp.innerHTML = oNode.xml ? oNode.xml : oNode.outerHTML;
                }else{
                    tmp.innerHTML = oNode.xml ? oNode.cloneNode(false).xml : oNode.cloneNode(false).outerHTML;
                }
                return tmp.getElementsByTagName("*")[0];
            }
        };
    }catch(e){ }
}
if(!Sarissa.getParseErrorText){
    /**
     * <p>Returns a human readable description of the parsing error. Usefull
     * for debugging. Tip: append the returned error string in a &lt;pre&gt;
     * element if you want to render it.</p>
     * <p>Many thanks to Christian Stocker for the initial patch.</p>
     * @memberOf Sarissa
     * @param {DOMDocument} oDoc The target DOM document
     * @returns {String} The parsing error description of the target Document in
     *          human readable form (preformated text)
     */
    Sarissa.getParseErrorText = function(oDoc){
        var parseErrorText = Sarissa.PARSED_OK;
        if((!oDoc) || (!oDoc.documentElement)){
            parseErrorText = Sarissa.PARSED_EMPTY;
        } else if(oDoc.documentElement.tagName == "parsererror"){
            parseErrorText = oDoc.documentElement.firstChild.data;
            parseErrorText += "\n" +  oDoc.documentElement.firstChild.nextSibling.firstChild.data;
        } else if(oDoc.getElementsByTagName("parsererror").length > 0){
            var parsererror = oDoc.getElementsByTagName("parsererror")[0];
            parseErrorText = Sarissa.getText(parsererror, true)+"\n";
        } else if(oDoc.parseError && oDoc.parseError.errorCode != 0){
            parseErrorText = Sarissa.PARSED_UNKNOWN_ERROR;
        }
        return parseErrorText;
    };
}
/**
 * Get a string with the concatenated values of all string nodes under the given node
 * @param {DOMNode} oNode the given DOM node
 * @param {boolean} deep whether to recursively scan the children nodes of the given node for text as well. Default is <code>false</code>
 * @memberOf Sarissa 
 */
Sarissa.getText = function(oNode, deep){
    var s = "";
    var nodes = oNode.childNodes;
    // opera fix, finds no child text node for attributes so we use .value
    if (oNode.nodeType == Node.ATTRIBUTE_NODE && nodes.length == 0) {
        return oNode.value;
    }
    // END opera fix
    for(var i=0; i < nodes.length; i++){
        var node = nodes[i];
        var nodeType = node.nodeType;
        if(nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE){
            s += node.data;
        } else if(deep === true && (nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE || nodeType == Node.DOCUMENT_FRAGMENT_NODE)){
            s += Sarissa.getText(node, true);
        }
    }
    return s;
};
if(!window.XMLSerializer && Sarissa.getDomDocument && Sarissa.getDomDocument("","foo", null).xml){
    /**
     * Utility class to serialize DOM Node objects to XML strings
     * @constructor
     */
    XMLSerializer = function(){};
    /**
     * Serialize the given DOM Node to an XML string
     * @param {DOMNode} oNode the DOM Node to serialize
     */
    XMLSerializer.prototype.serializeToString = function(oNode) {
        return oNode.xml;
    };
}

/**
 * Strips tags from the given markup string. If the given string is 
 * <code>undefined</code>, <code>null</code> or empty, it is returned as is. 
 * @memberOf Sarissa
 * @param {String} s the string to strip the tags from
 */
Sarissa.stripTags = function(s) {
    return s?s.replace(/<[^>]+>/g,""):s;
};
/**
 * <p>Deletes all child nodes of the given node</p>
 * @memberOf Sarissa
 * @param {DOMNode} oNode the Node to empty
 */
Sarissa.clearChildNodes = function(oNode) {
    // need to check for firstChild due to opera 8 bug with hasChildNodes
    while(oNode.firstChild) {
        oNode.removeChild(oNode.firstChild);
    }
};
/**
 * <p> Copies the childNodes of nodeFrom to nodeTo</p>
 * <p> <b>Note:</b> The second object's original content is deleted before 
 * the copy operation, unless you supply a true third parameter</p>
 * @memberOf Sarissa
 * @param {DOMNode} nodeFrom the Node to copy the childNodes from
 * @param {DOMNode} nodeTo the Node to copy the childNodes to
 * @param {boolean} bPreserveExisting whether to preserve the original content of nodeTo, default is false
 */
Sarissa.copyChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
    if(Sarissa._SARISSA_IS_SAFARI && nodeTo.nodeType == Node.DOCUMENT_NODE){ // SAFARI_OLD ??
    	nodeTo = nodeTo.documentElement; //Apparently there's a bug in safari where you can't appendChild to a document node
    }
    
    if((!nodeFrom) || (!nodeTo)){
        throw "Both source and destination nodes must be provided";
    }
    if(!bPreserveExisting){
        Sarissa.clearChildNodes(nodeTo);
    }
    var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
    var nodes = nodeFrom.childNodes;
    var i;
    if(typeof(ownerDoc.importNode) != "undefined")  {
        for(i=0;i < nodes.length;i++) {
            nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
        }
    } else {
        for(i=0;i < nodes.length;i++) {
            nodeTo.appendChild(nodes[i].cloneNode(true));
        }
    }
};

/**
 * <p> Moves the childNodes of nodeFrom to nodeTo</p>
 * <p> <b>Note:</b> The second object's original content is deleted before 
 * the move operation, unless you supply a true third parameter</p>
 * @memberOf Sarissa
 * @param {DOMNode} nodeFrom the Node to copy the childNodes from
 * @param {DOMNode} nodeTo the Node to copy the childNodes to
 * @param {boolean} bPreserveExisting whether to preserve the original content of nodeTo, default is
 */ 
Sarissa.moveChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
    if((!nodeFrom) || (!nodeTo)){
        throw "Both source and destination nodes must be provided";
    }
    if(!bPreserveExisting){
        Sarissa.clearChildNodes(nodeTo);
    }
    var nodes = nodeFrom.childNodes;
    // if within the same doc, just move, else copy and delete
    if(nodeFrom.ownerDocument == nodeTo.ownerDocument){
        while(nodeFrom.firstChild){
            nodeTo.appendChild(nodeFrom.firstChild);
        }
    } else {
        var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
        var i;
        if(typeof(ownerDoc.importNode) != "undefined") {
           for(i=0;i < nodes.length;i++) {
               nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
           }
        }else{
           for(i=0;i < nodes.length;i++) {
               nodeTo.appendChild(nodes[i].cloneNode(true));
           }
        }
        Sarissa.clearChildNodes(nodeFrom);
    }
};

/** 
 * <p>Serialize any <strong>non</strong> DOM object to an XML string. All properties are serialized using the property name
 * as the XML element name. Array elements are rendered as <code>array-item</code> elements, 
 * using their index/key as the value of the <code>key</code> attribute.</p>
 * @memberOf Sarissa
 * @param {Object} anyObject the object to serialize
 * @param {String} objectName a name for that object, to be used as the root element name
 * @param {String} indentSpace Optional, the indentation space to use, default is an empty 
 *        string. A single space character is added in any recursive call.
 * @param {noolean} skipEscape Optional, whether to skip escaping characters that map to the 
 *        five predefined XML entities. Default is <code>false</code>.
 * @return {String} the XML serialization of the given object as a string
 */
Sarissa.xmlize = function(anyObject, objectName, indentSpace, skipEscape){
    indentSpace = indentSpace?indentSpace:'';
    var s = indentSpace  + '<' + objectName + '>';
    var isLeaf = false;
    if(!(anyObject instanceof Object) || anyObject instanceof Number || anyObject instanceof String || anyObject instanceof Boolean || anyObject instanceof Date){
        s += (skipEscape ? Sarissa.escape(anyObject) : anyObject);
        isLeaf = true;
    }else{
        s += "\n";
        var isArrayItem = anyObject instanceof Array;
        for(var name in anyObject){
        	// do not xmlize functions 
        	if (anyObject[name] instanceof Function){
        		continue;
        	} 
            s += Sarissa.xmlize(anyObject[name], (isArrayItem?"array-item key=\""+name+"\"":name), indentSpace + " ");
        }
        s += indentSpace;
    }
    return (s += (objectName.indexOf(' ')!=-1?"</array-item>\n":"</" + objectName + ">\n"));
};

/** 
 * Escape the given string chacters that correspond to the five predefined XML entities
 * @memberOf Sarissa
 * @param {String} sXml the string to escape
 */
Sarissa.escape = function(sXml){
    return sXml.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
};

/** 
 * Unescape the given string. This turns the occurences of the predefined XML 
 * entities to become the characters they represent correspond to the five predefined XML entities
 * @memberOf Sarissa
 * @param  {String}sXml the string to unescape
 */
Sarissa.unescape = function(sXml){
    return sXml.replace(/&apos;/g,"'").replace(/&quot;/g,"\"").replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&amp;/g,"&");
};

/** @private */
Sarissa.updateCursor = function(oTargetElement, sValue) {
    if(oTargetElement && oTargetElement.style && oTargetElement.style.cursor != undefined ){
        oTargetElement.style.cursor = sValue;
    }
};

/**
 * Asynchronously update an element with response of a GET request on the given URL.  Passing a configured XSLT 
 * processor will result in transforming and updating oNode before using it to update oTargetElement.
 * You can also pass a callback function to be executed when the update is finished. The function will be called as 
 * <code>functionName(oNode, oTargetElement);</code>
 * @memberOf Sarissa
 * @param {String} sFromUrl the URL to make the request to
 * @param {DOMElement} oTargetElement the element to update
 * @param {XSLTProcessor} xsltproc (optional) the transformer to use on the returned
 *                  content before updating the target element with it
 * @param {Function} callback (optional) a Function object to execute once the update is finished successfuly, called as <code>callback(sFromUrl, oTargetElement)</code>. 
 *        In case an exception is thrown during execution, the callback is called as called as <code>callback(sFromUrl, oTargetElement, oException)</code>
 * @param {boolean} skipCache (optional) whether to skip any cache
 */
Sarissa.updateContentFromURI = function(sFromUrl, oTargetElement, xsltproc, callback, skipCache) {
    try{
        Sarissa.updateCursor(oTargetElement, "wait");
        var xmlhttp = new XMLHttpRequest();
        xmlhttp.open("GET", sFromUrl, true);
        xmlhttp.onreadystatechange = function() {
            if (xmlhttp.readyState == 4) {
            	try{
            		var oDomDoc = xmlhttp.responseXML;
	            	if(oDomDoc && Sarissa.getParseErrorText(oDomDoc) == Sarissa.PARSED_OK){
		                Sarissa.updateContentFromNode(xmlhttp.responseXML, oTargetElement, xsltproc);
        				if(callback){
		                	callback(sFromUrl, oTargetElement);
		                }
	            	}
	            	else{
	            		throw Sarissa.getParseErrorText(oDomDoc);
	            	}
            	}
            	catch(e){
            		if(callback){
			        	callback(sFromUrl, oTargetElement, e);
			        }
			        else{
			        	throw e;
			        }
            	}
            }
        };
        if (skipCache) {
             var oldage = "Sat, 1 Jan 2000 00:00:00 GMT";
             xmlhttp.setRequestHeader("If-Modified-Since", oldage);
        }
        xmlhttp.send("");
    }
    catch(e){
        Sarissa.updateCursor(oTargetElement, "auto");
        if(callback){
        	callback(sFromUrl, oTargetElement, e);
        }
        else{
        	throw e;
        }
    }
};

/**
 * Update an element's content with the given DOM node. Passing a configured XSLT 
 * processor will result in transforming and updating oNode before using it to update oTargetElement.
 * You can also pass a callback function to be executed when the update is finished. The function will be called as 
 * <code>functionName(oNode, oTargetElement);</code>
 * @memberOf Sarissa
 * @param {DOMNode} oNode the URL to make the request to
 * @param {DOMElement} oTargetElement the element to update
 * @param {XSLTProcessor} xsltproc (optional) the transformer to use on the given 
 *                  DOM node before updating the target element with it
 */
Sarissa.updateContentFromNode = function(oNode, oTargetElement, xsltproc) {
    try {
        Sarissa.updateCursor(oTargetElement, "wait");
        Sarissa.clearChildNodes(oTargetElement);
        // check for parsing errors
        var ownerDoc = oNode.nodeType == Node.DOCUMENT_NODE?oNode:oNode.ownerDocument;
        if(ownerDoc.parseError && ownerDoc.parseError.errorCode != 0) {
            var pre = document.createElement("pre");
            pre.appendChild(document.createTextNode(Sarissa.getParseErrorText(ownerDoc)));
            oTargetElement.appendChild(pre);
        }
        else {
            // transform if appropriate
            if(xsltproc) {
                oNode = xsltproc.transformToDocument(oNode);
            }
            // be smart, maybe the user wants to display the source instead
            if(oTargetElement.tagName.toLowerCase() == "textarea" || oTargetElement.tagName.toLowerCase() == "input") {
                oTargetElement.value = new XMLSerializer().serializeToString(oNode);
            }
            else {
                // ok that was not smart; it was paranoid. Keep up the good work by trying to use DOM instead of innerHTML
                try{
                    oTargetElement.appendChild(oTargetElement.ownerDocument.importNode(oNode, true));
                }
                catch(e){
                    oTargetElement.innerHTML = new XMLSerializer().serializeToString(oNode);
                }
            }
        }
    }
    catch(e) {
    	throw e;
    }
    finally{
        Sarissa.updateCursor(oTargetElement, "auto");
    }
};


/**
 * Creates an HTTP URL query string from the given HTML form data
 * @memberOf Sarissa
 * @param {HTMLFormElement} oForm the form to construct the query string from
 */
Sarissa.formToQueryString = function(oForm){
    var qs = "";
    for(var i = 0;i < oForm.elements.length;i++) {
        var oField = oForm.elements[i];
        var sFieldName = oField.getAttribute("name") ? oField.getAttribute("name") : oField.getAttribute("id"); 
        // ensure we got a proper name/id and that the field is not disabled
        if(sFieldName && 
            ((!oField.disabled) || oField.type == "hidden")) {
            switch(oField.type) {
                case "hidden":
                case "text":
                case "textarea":
                case "password":
                    qs += sFieldName + "=" + encodeURIComponent(oField.value) + "&";
                    break;
                case "select-one":
                    qs += sFieldName + "=" + encodeURIComponent(oField.options[oField.selectedIndex].value) + "&";
                    break;
                case "select-multiple":
                    for (var j = 0; j < oField.length; j++) {
                        var optElem = oField.options[j];
                        if (optElem.selected === true) {
                            qs += sFieldName + "[]" + "=" + encodeURIComponent(optElem.value) + "&";
                        }
                     }
                     break;
                case "checkbox":
                case "radio":
                    if(oField.checked) {
                        qs += sFieldName + "=" + encodeURIComponent(oField.value) + "&";
                    }
                    break;
            }
        }
    }
    // return after removing last '&'
    return qs.substr(0, qs.length - 1); 
};


/**
 * Asynchronously update an element with response of an XMLHttpRequest-based emulation of a form submission. <p>The form <code>action</code> and 
 * <code>method</code> attributess will be followed. Passing a configured XSLT processor will result in 
 * transforming and updating the server response before using it to update the target element.
 * You can also pass a callback function to be executed when the update is finished. The function will be called as 
 * <code>functionName(oNode, oTargetElement);</code></p>
 * <p>Here is an example of using this in a form element:</p>
 * <pre name="code" class="xml">
 * &lt;div id="targetId"&gt; this content will be updated&lt;/div&gt;
 * &lt;form action="/my/form/handler" method="post" 
 *     onbeforesubmit="return Sarissa.updateContentFromForm(this, document.getElementById('targetId'));"&gt;<pre>
 * <p>If JavaScript is supported, the form will not be submitted. Instead, Sarissa will
 * scan the form and make an appropriate AJAX request, also adding a parameter 
 * to signal to the server that this is an AJAX call. The parameter is 
 * constructed as <code>Sarissa.REMOTE_CALL_FLAG = "=true"</code> so you can change the name in your webpage
 * simply by assigning another value to Sarissa.REMOTE_CALL_FLAG. If JavaScript is not supported
 * the form will be submitted normally.
 * @memberOf Sarissa
 * @param {HTMLFormElement} oForm the form submition to emulate
 * @param {DOMElement} oTargetElement the element to update
 * @param {XSLTProcessor} xsltproc (optional) the transformer to use on the returned
 *                  content before updating the target element with it
 * @param {Function} callback (optional) a Function object to execute once the update is finished successfuly, called as <code>callback(oNode, oTargetElement)</code>. 
 *        In case an exception occurs during excecution and a callback function was provided, the exception is cought and the callback is called as 
 *        <code>callback(oForm, oTargetElement, exception)</code>
 */
Sarissa.updateContentFromForm = function(oForm, oTargetElement, xsltproc, callback) {
    try{
    	Sarissa.updateCursor(oTargetElement, "wait");
        // build parameters from form fields
        var params = Sarissa.formToQueryString(oForm) + "&" + Sarissa.REMOTE_CALL_FLAG + "=true";
        var xmlhttp = new XMLHttpRequest();
        var bUseGet = oForm.getAttribute("method") && oForm.getAttribute("method").toLowerCase() == "get"; 
        if(bUseGet) {
            xmlhttp.open("GET", oForm.getAttribute("action")+"?"+params, true);
        }
        else{
            xmlhttp.open('POST', oForm.getAttribute("action"), true);
            xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xmlhttp.setRequestHeader("Content-length", params.length);
            xmlhttp.setRequestHeader("Connection", "close");
        }
        xmlhttp.onreadystatechange = function() {
        	try{
	            if (xmlhttp.readyState == 4) {
	            	var oDomDoc = xmlhttp.responseXML;
	            	if(oDomDoc && Sarissa.getParseErrorText(oDomDoc) == Sarissa.PARSED_OK){
		                Sarissa.updateContentFromNode(xmlhttp.responseXML, oTargetElement, xsltproc);
        				if(callback){
		                	callback(oForm, oTargetElement);
		                }
	            	}
	            	else{
	            		throw Sarissa.getParseErrorText(oDomDoc);
	            	}
	            }
        	}
        	catch(e){
        		if(callback){
        			callback(oForm, oTargetElement, e);
        		}
        		else{
        			throw e;
        		}
        	}
        };
        xmlhttp.send(bUseGet?"":params);
    }
    catch(e){
        Sarissa.updateCursor(oTargetElement, "auto");
        if(callback){
        	callback(oForm, oTargetElement, e);
        }
        else{
        	throw e;
        }
    }
    return false;
};

/**
 * Get the name of a function created like:
 * <pre>function functionName(){}</pre>
 * If a name is not found, attach the function to 
 * the window object with a new name and return that
 * @param {Function} oFunc the function object
 */
Sarissa.getFunctionName = function(oFunc){
	if(!oFunc || (typeof oFunc != 'function' )){
		throw "The value of parameter 'oFunc' must be a function";
	}
	if(oFunc.name) { 
		return oFunc.name; 
	} 
	// try to parse the function name from the defintion 
	var sFunc = oFunc.toString(); 
	alert("sFunc: "+sFunc);
	var name = sFunc.substring(sFunc.indexOf('function') + 8 , sFunc.indexOf('(')); 
	if(!name || name.length == 0 || name == " "){
		// attach to window object under a new name
		name = "SarissaAnonymous" + Sarissa._getUniqueSuffix();
		window[name] = oFunc;
	}
	return name;
};

/**
 *
 */
Sarissa.setRemoteJsonCallback = function(url, callback, callbackParam) {
	if(!callbackParam){
		callbackParam = "callback";
	}
	var callbackFunctionName = Sarissa.getFunctionName(callback);
	//alert("callbackFunctionName: '" + callbackFunctionName+"', length: "+callbackFunctionName.length);
	var id = "sarissa_json_script_id_" + Sarissa._getUniqueSuffix(); 
	var oHead = document.getElementsByTagName("head")[0];
	var scriptTag = document.createElement('script');
	scriptTag.type = 'text/javascript';
	scriptTag.id = id;
	scriptTag.onload = function(){
		// cleanUp
		// document.removeChild(scriptTag);
	};
	if(url.indexOf("?") != -1){
		url += ("&" + callbackParam + "=" + callbackFunctionName);
	}
	else{
		url += ("?" + callbackParam + "=" + callbackFunctionName);
	}
	scriptTag.src = url;
  	oHead.appendChild(scriptTag);
  	return id;
};

            // added by Brent to support backwards compatibility
            var _XMLSerializer = new XMLSerializer();
            Sarissa.serialize = function(x){
            return _XMLSerializer.serializeToString(x)
            }
//   EOF

/**
 * ====================================================================
 * About
 * ====================================================================
 * Sarissa cross browser XML library - IE XPath Emulation 
 * @version 0.9.9.5
 * @author: Copyright 2004-2007 Emmanouil Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 *
 * This script emulates Internet Explorer's selectNodes and selectSingleNode
 * for Mozilla. Associating namespace prefixes with URIs for your XPath queries
 * is easy with IE's setProperty. 
 * USers may also map a namespace prefix to a default (unprefixed) namespace in the
 * source document with Sarissa.setXpathNamespaces
 *
 * ====================================================================
 * Licence
 * ====================================================================
 * Sarissa is free software distributed under the GNU GPL version 2 (see <a href="gpl.txt">gpl.txt</a>) or higher, 
 * GNU LGPL version 2.1 (see <a href="lgpl.txt">lgpl.txt</a>) or higher and Apache Software License 2.0 or higher 
 * (see <a href="asl.txt">asl.txt</a>). This means you can choose one of the three and use that if you like. If 
 * you make modifications under the ASL, i would appreciate it if you submitted those.
 * In case your copy of Sarissa does not include the license texts, you may find
 * them online in various formats at <a href="http://www.gnu.org">http://www.gnu.org</a> and 
 * <a href="http://www.apache.org">http://www.apache.org</a>.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
 * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
if(Sarissa._SARISSA_HAS_DOM_FEATURE && document.implementation.hasFeature("XPath", "3.0")){
    /**
     * <p>SarissaNodeList behaves as a NodeList but is only used as a result to <code>selectNodes</code>,
     * so it also has some properties IEs proprietery object features.</p>
     * @private
     * @constructor
     * @argument i the (initial) list size
     */
    SarissaNodeList = function(i){
        this.length = i;
    };
    /** 
     * <p>Set an Array as the prototype object</p> 
     * @private
     */
    SarissaNodeList.prototype = [];
    /** 
     * <p>Inherit the Array constructor </p> 
     * @private
     */
    SarissaNodeList.prototype.constructor = Array;
    /**
     * <p>Returns the node at the specified index or null if the given index
     * is greater than the list size or less than zero </p>
     * <p><b>Note</b> that in ECMAScript you can also use the square-bracket
     * array notation instead of calling <code>item</code>
     * @argument i the index of the member to return
     * @returns the member corresponding to the given index
     * @private
     */
    SarissaNodeList.prototype.item = function(i) {
        return (i < 0 || i >= this.length)?null:this[i];
    };
    /**
     * <p>Emulate IE's expr property
     * (Here the SarissaNodeList object is given as the result of selectNodes).</p>
     * @returns the XPath expression passed to selectNodes that resulted in
     *          this SarissaNodeList
     * @private
     */
    SarissaNodeList.prototype.expr = "";
    /** dummy, used to accept IE's stuff without throwing errors */
    if(window.XMLDocument && (!XMLDocument.prototype.setProperty)){
        XMLDocument.prototype.setProperty  = function(x,y){};
    }
    /**
    * <p>Programmatically control namespace URI/prefix mappings for XPath
    * queries.</p>
    * <p>This method comes especially handy when used to apply XPath queries
    * on XML documents with a default namespace, as there is no other way
    * of mapping that to a prefix.</p>
    * <p>Using no namespace prefix in DOM Level 3 XPath queries, implies you
    * are looking for elements in the null namespace. If you need to look
    * for nodes in the default namespace, you need to map a prefix to it
    * first like:</p>
    * <pre>Sarissa.setXpathNamespaces(oDoc, "xmlns:myprefix'http://mynsURI'");</pre>
    * <p><b>Note 1 </b>: Use this method only if the source document features
    * a default namespace (without a prefix), otherwise just use IE's setProperty
    * (moz will rezolve non-default namespaces by itself). You will need to map that
    * namespace to a prefix for queries to work.</p>
    * <p><b>Note 2 </b>: This method calls IE's setProperty method to set the
    * appropriate namespace-prefix mappings, so you dont have to do that.</p>
    * @param oDoc The target XMLDocument to set the namespace mappings for.
    * @param sNsSet A whilespace-seperated list of namespace declarations as
    *            those would appear in an XML document. E.g.:
    *            <code>&quot;xmlns:xhtml=&apos;http://www.w3.org/1999/xhtml&apos;
    * xmlns:&apos;http://www.w3.org/1999/XSL/Transform&apos;&quot;</code>
    * @throws An error if the format of the given namespace declarations is bad.
    */
    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
        //oDoc._sarissa_setXpathNamespaces(sNsSet);
        oDoc._sarissa_useCustomResolver = true;
        var namespaces = sNsSet.indexOf(" ")>-1?sNsSet.split(" "):[sNsSet];
        oDoc._sarissa_xpathNamespaces = [];
        for(var i=0;i < namespaces.length;i++){
            var ns = namespaces[i];
            var colonPos = ns.indexOf(":");
            var assignPos = ns.indexOf("=");
            if(colonPos > 0 && assignPos > colonPos+1){
                var prefix = ns.substring(colonPos+1, assignPos);
                var uri = ns.substring(assignPos+2, ns.length-1);
                oDoc._sarissa_xpathNamespaces[prefix] = uri;
            }else{
                throw "Bad format on namespace declaration(s) given";
            }
        }
    };
    /**
    * @private Flag to control whether a custom namespace resolver should
    *          be used, set to true by Sarissa.setXpathNamespaces
    */
    XMLDocument.prototype._sarissa_useCustomResolver = false;
    /** @private */
    XMLDocument.prototype._sarissa_xpathNamespaces = [];
    /**
    * <p>Extends the XMLDocument to emulate IE's selectNodes.</p>
    * @argument sExpr the XPath expression to use
    * @argument contextNode this is for internal use only by the same
    *           method when called on Elements
    * @returns the result of the XPath search as a SarissaNodeList
    * @throws An error if no namespace URI is found for the given prefix.
    */
    XMLDocument.prototype.selectNodes = function(sExpr, contextNode, returnSingle){
        var nsDoc = this;
        var nsresolver;
        if(this._sarissa_useCustomResolver){
            nsresolver = function(prefix){
                var s = nsDoc._sarissa_xpathNamespaces[prefix];
                if(s){
                    return s;
                }
                else {
                    throw "No namespace URI found for prefix: '" + prefix+"'";
                }
            };
        }
        else{
            nsresolver = this.createNSResolver(this.documentElement);
        }
        var result = null;
        if(!returnSingle){
            var oResult = this.evaluate(sExpr,
                (contextNode?contextNode:this),
                nsresolver,
                XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            var nodeList = new SarissaNodeList(oResult.snapshotLength);
            nodeList.expr = sExpr;
            for(var i=0;i<nodeList.length;i++){
                nodeList[i] = oResult.snapshotItem(i);
            }
            result = nodeList;
        }
        else {
            result = this.evaluate(sExpr,
                (contextNode?contextNode:this),
                nsresolver,
                XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
        }
        return result;      
    };
    /**
    * <p>Extends the Element to emulate IE's selectNodes</p>
    * @argument sExpr the XPath expression to use
    * @returns the result of the XPath search as an (Sarissa)NodeList
    * @throws An
    *             error if invoked on an HTML Element as this is only be
    *             available to XML Elements.
    */
    Element.prototype.selectNodes = function(sExpr){
        var doc = this.ownerDocument;
        if(doc.selectNodes){
            return doc.selectNodes(sExpr, this);
        }
        else{
            throw "Method selectNodes is only supported by XML Elements";
        }
    };
    /**
    * <p>Extends the XMLDocument to emulate IE's selectSingleNode.</p>
    * @argument sExpr the XPath expression to use
    * @argument contextNode this is for internal use only by the same
    *           method when called on Elements
    * @returns the result of the XPath search as an (Sarissa)NodeList
    */
    XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var ctx = contextNode?contextNode:null;
        return this.selectNodes(sExpr, ctx, true);
    };
    /**
    * <p>Extends the Element to emulate IE's selectSingleNode.</p>
    * @argument sExpr the XPath expression to use
    * @returns the result of the XPath search as an (Sarissa)NodeList
    * @throws An error if invoked on an HTML Element as this is only be
    *             available to XML Elements.
    */
    Element.prototype.selectSingleNode = function(sExpr){
        var doc = this.ownerDocument;
        if(doc.selectSingleNode){
            return doc.selectSingleNode(sExpr, this);
        }
        else{
            throw "Method selectNodes is only supported by XML Elements";
        }
    };
    Sarissa.IS_ENABLED_SELECT_NODES = true;
}
/**  
  * @fileoverview deCarta Namespaces, GLOBALS and Credentials.
  * In general, declare all namespaces here. Trade off slight monolithicness for
  * a quick index to the namespaces that have been declared.
  * Do not change the name of this file without changing the build script. The
  * build script places this file first to prevent any potential reference
  * problems.
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */

//-------------------------------------------------------- Namespaces

/**
 * @namespace Entry point for deCarta library classes, methods and variables.
 * Currently used to group deCarta private classes and functions. Due to the
 * age of the deCarta.js mapping library and the more modern concept of the
 * JavaScript "namespace" pattern, the library code might never be fully
 * refactored under here. We have opened up this namespace to prevent further
 * collisions in the global JavaScript namespace.
 * @description The deCarta namespace.
 */
var deCarta = {};

//-------------------------------------------------------- GLOBALS

/**
 * GLOBALS is constructed on load of the deCarta.js library.
 * @class The GLOBALS class is a static singleton, constructed on load of the 
 * deCarta.js library. It mainly contains reference information.<br /><br />
 * @see Map#panWest
 * @constructor
 */
function GLOBALS() {}
/**
 * Used internally by various map elements for map type checks: consider this
 * value read only.
 * Also used as the default label for the MapTypeController hybrid view
 * (satellite images with road and area labels overlaid) button.
 * @private 
 * @type string
 * @default "HYBRID"
 */
 GLOBALS.HYBRID    =  "HYBRID";
/** 
 * Used internally by various map elements for map type checks: consider this
 * value read only.
 * Also used as the default label for the MapTypeController street view button.
 * @private
 * @type string
 * @default "STREET"
 */
 GLOBALS.STREET    =  "STREET";
/**
 * Used internally by various map elements for map type checks: consider this
 * value read only.
 * Also used as the default label for the MapTypeController satellite imagery
 * view button.
 * @private 
 * @type string
 * @default "SATELLITE"
 */
 GLOBALS.SATELLITE =  "SATELLITE";
 
 /** 
  * Sets number of pixels to slide the map when the pan functions are 
  * called. The default value is 300.
  * @type int 
  */
 GLOBALS.PAN_PIXEL_DISTANCE = 300;
 /**
  * The default length/width of the square map tile size. Units are pixels.
  * The default value of 256 is, as of this writing, still extremely important
  * if compatibility with underlying GlobeXplorer/Digital Globe imagery is
  * to be maintained.
  * @private
  * @type integer
  * @default 256
  */
 GLOBALS.DEFAULT_MAP_TILE_SIZE = 256;
 /**
  * The default width of a map view on the page.
  * @private
  * @type string
  * @default "800px"
  */
 GLOBALS.DEFAULT_MAP_WIDTH = "800px";
 /**
  * The default height of a map view on the page.
  * @private
  * @type string
  * @default "500px"
  */
 GLOBALS.DEFAULT_MAP_HEIGHT = "500px";
 /**
  * The official
  * version number for this deCarta JavaScript API library.
  * @type string
  */
 // Internal note: The token in the string will be replaced by the
 // JSAPI ant build script during build time.
 GLOBALS.API_VERSION = "5.1";
 
 /**
  * Tech support debugging revision number. Not documented, but useful
  * for referencing which version is being used. Must have SVN properties
  * set--in other words, don't turn them off--for this to be useful.
  * @private
  * @type string
  */
 GLOBALS.API_BUILD = "$LastChangedRevision: 74609 $";
 
 /**
  * An additional notation on what flavor of build this is. This can also
  * be used as a flag.
  * @private
  * @type string
  */
 // Internal note: The token in the string will be replaced by the
 // JSAPI ant build script during build time.
 GLOBALS.API_RELEASECLASS = "RELEASE";

/**
 * Flag that can allow all or prevent any new HTML DOM events from being
 * initiated by any object associated with the deCarta.js.
 * @type boolean
 * @default true
 */
GLOBALS.ALLOWDOMEVENTS = true;

 /**
  * Allows for JSON debugging output to screen.
  * @private
  * @type boolean
  * @default false
  */
 GLOBALS.DEBUG_JSON=false;

 /**
  * Use fixed session ID for stateless map tiles. This will help for client side caching.
  * @type int
  * @default 1
  */
// GLOBALS.TILE_SESSION_ID=1;
 GLOBALS.TILE_SESSION_ID=Math.round(Math.random()*100000);
 
//-------------------------------------------------------- Credentials



/**
  Credentials is constructed on load of the deCarta.js library.
  @class The Credentials class is a static singleton, constructed on load of the
  deCarta.js library. The JavaScript API requires certain global variables. The
  Credentials object exposes a select set of these global variables. In
  practice, it shouldn't be necessary to directly modify the various Credentials
  fields. However, accessing these fields directly convenient and hence we
  expose them through here. <br /><br />
  @constructor
 */
function Credentials() {}


/**
  * URL to the DDS Web Services with no trailing slash.
  * @type String
  */
 // Internal Note: designed to be replaced during the build process, see build.xml
 Credentials.url="http://ws.decarta.com/openls/openls";

/**
 * Name of the JSONServlet that the DDS JSAPI will communicate with.
 * No slashes, just the name of the resource.
 * This is the name that will replace the 'openls' resource should the
 * {@link Credentials.url} URL be pointing to that.
 * @type String
 * @default JSON
 */
Credentials.jsonServletName = "JSON";

 /**
  * Credentials used for default authentication.
  * For explicity authentication of separate JSAPI objects, use the associated
  * authenticate functions.
  * @type String
  * @default ""
  */
 Credentials.clientName = "";

/**
  * Credentials used for authentication.
  * For explicity authentication of separate JSAPI objects, use the associated
  * authenticate functions.
  * @type String
  * @default ""
  */
 Credentials.clientPassword = "";

/**
  * DDS Web Services configuration that controls the type of data (if
  * more than one type is available) and the display of the map images.
  * @type String
  */
 // Internal Note: designed to be replaced during the build process, see build.xml
 Credentials.configuration = "global-decarta"; // data set and image settings

/**
  * The configuration to use to generate the road and labels to be
  * overlaid on top of the hybrid map images.
  * @private
  * @type String
  */
 // Internal Note: designed to be replaced during the build process, see build.xml
 Credentials.transparentConfiguration = "transparent-tile"; // data set and image settings

/**
  * The default display setting for a MapTypeController. Unless someone
  * has a immediate access to satellite imagery and a good hybrid map
  * style, you'll probably not want to change this.
  * Possible values:<br/>
  * "STREET"<br/>
  * "HYBRID"<br/>
  * "SATELLITE"<br/>
  * @private
  * @type String
  * @default "STREET"
  */
 Credentials.mapType = "STREET";

/**
  * The default ISOCountryCode. This currently has little use.
  * @private
  * @type String
  */
 Credentials.ISOCountryCode = "US";

/**
  * Toggles access to traffic (true = on, false = off; default = false);
  * <B>NOTE:</B> Traffic queries should only be made against servers /
  * configurations that are hosting traffic data. When on: traffic flow
  * gets rendered onto the map tiles and routes will take the current
  * traffic stats into consideration. Depending on how good, or bad, the
  * traffic is, routes might have better or worse estimated travel times.
  * When the traffic gets too bad, the entire route might take an
  * alternate path if a better one can be found.
  * @type boolean
  */
 Credentials.trafficEnabled = false;

 /**
  * Release number used to validate this JavaScript API against the
  * DDS Web Services back end.
  * @private 
  * @type String
  */
 // Internal note: This token is replaced at build time. See build.xml.
 Credentials.rel = "5.1";

 /**
  * Set this to the Digital Globe access key for Satellite images to
  * enable satellite and hybrid maps.
  * @type boolean
  * @default null
  */
 Credentials.dgkey = "";

 /**
  * digital globe key for v2 service
  *
  */
 Credentials.CONNECTID="";

 /**
  * This is the path to the images used by this API-- pins, zoom
  * controls, tile place holders, info windows.  The API needs to have
  * this path set correctly.  If the images do not resolve certain
  * features will not work properly.	The default is the relative
  * path to "img/".
  * @type String
  */
 Credentials.imgPath = "img/";

 /**
  * If you use satellite imagery this is the path or URL to the place
  * holder tile image (default is "img/tile.png") for areas where the
  * provider does not have coverage.
  * @type String
  */
 Credentials.errorTile = Credentials.imgPath + "tile.png";

 /**
  * The src location for an invisible PNG image. This src location is used
  * in various locations of the code during construction time of the various
  * objects and assumes that this reference will lead to a 1x1 transparent PNG
  * by default.
  * Reset this location if your transparent PNG image exists in another
  * location or goes by a different name.
  * @type string
  * @default "img/tile.png"
  */
 Credentials.transparentPNG = Credentials.imgPath + "tile.png";
 /**
  * The src location for an invisible GIF image. This src location is used
  * in various locations of the code during construction time of the various
  * objects and assumes that this reference will lead to a 1x1 transparent GIF
  * by default.
  * Reset this location if your transparent GIF image exists in another
  * location or goes by a different name.
  * @type string
  * @default "img/x.gif"
  */
 Credentials.transparentGIF = Credentials.imgPath + "x.gif";

 /**
  * The src location for the default InfoWindow close button.
  * This default should be reset prior to initializing an InfoWindow.
  * Setting this to a falsey value will prevent InfoWindows from being
  * built with close buttons.
  * @type string
  * @default "img/close.png"
  */
 Credentials.infoWindowCloseButton = Credentials.imgPath + "close.png";

/**
 * The image default for a {@link Pin} not provided an {@link Icon}.
 * @type string
 * @default "img/greenDot.png"
 */
Credentials.pinIconPath = Credentials.imgPath + "greenDot.png";

/**
 * The image default for a {@link ZoomController} unselected zoom levels.
 * @type string
 * @default "img/zoom.png"
 */
Credentials.zoomUnselectedIconPath = Credentials.imgPath + "zoom.png";
/**
 * The image default for the {@link ZoomController} selected zoom level.
 * @type string
 * @default "img/zoomChecked.png"
 */
Credentials.zoomSelectedIconPath = Credentials.imgPath + "zoomChecked.png";
/**
 * The image default for the {@link ZoomController} zoom out button.
 * @type string
 * @default "img/zoomBottom.png"
 */
Credentials.zoomOutIconPath = Credentials.imgPath + "zoomBottom.png";
/**
 * The image default for the {@link ZoomController} zoom in button.
 * @type string
 * @default "img/zoomTop.png"
 */
Credentials.zoomInIconPath = Credentials.imgPath + "zoomTop.png";

/**
 * There is support for both mercator spherical and mercator ellipsoidal. 
 * @type string
 * @default "EPSG:3395" (ellipsoidal) 
 */
Credentials.projection = /*'EPSG:3857',*/'EPSG:3395'; 
/**
 * @fileoverview Pull content into dom.
 * deCarta confidential and proprietary
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class Collection of static functions used for loading dynamic content from
 * over the network.
 * @private
 */
deCarta.AJAXContentLoader = {}
/**
 * Asynchronously load an external document and make the content accessible.
 * Default operation uses an XMLHTTPRequest and requires two arguments: 
 * url and callback.
 * @example
 * // Default call, using XMLHTTPRequest
 * // myCallback will be passed 1 argument, which is either the plain text
 * // version of the document that has been loaded, or null if there was a
 * // problem loading the document
 * deCarta.AJAXContentLoader.load("http://example.com/l33t.html", myCallback);
 * // Or we can customize this to use an iFrame
 * var prefs = {}
 * // Case sensitive mode setting
 * prefs.mode = "iframe";
 * // Need a location to append our iframe loader to
 * prefs.dom = document.getElementById("myelement");
 * // Can now use an iframe as a loader
 * deCarta.AJAXContentLoader.load(url, null, prefs);
 * // Or, you may pass in a callback that, if possible on your browser,
 * // will be attached as the onload event handler
 * deCarta.AJAXContentLoader.load(url, callback, prefs);
 * @param {string} url The location of the document to load.
 * @param {function} callback For default XHR operation, the callback
 * is required. The callback is optional for the iframe load.
 * @param {object} [prefs] An object used to configure non-default
 * load preferences.
 * @param {string} [prefs.mode='xhr'] Mode to use for file retrieval. The only valid
 * value at the moment is "iframe", any other value will default to XMLHttpRequest.
 * @param {string} [prefs.height='0px'] CSS height of the resulting iframe (if
 * in iframe mode).
 * @param {string} [prefs.width='0px'] CSS width of the resulting iframe (if
 * in iframe mode).
 */
deCarta.AJAXContentLoader.load = function(url, callback, prefs){
    
    if( prefs && prefs.mode == "iframe" ) {
        var iframe = document.createElement("iframe");
        iframe.style.width=prefs.height || '0px';
        iframe.style.height=prefs.width || '0px';
        iframe.style.border="0px";
        iframe.src=url;
        if ( typeof(callback) == "function" ) {
            iframe.onload = callback;
        }
        prefs.dom.appendChild(iframe);
    }else{
        // xhr
        if (!Utilities.ie){
            // for testing local files
            try { 
                netscape.security.PrivilegeManager.enablePrivilege("UniversalPreferencesWrite UniversalBrowserWrite UniversalPreferencesRead UniversalBrowserRead");
            } catch (e) {}
        }
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onreadystatechange = function(){
            if ( xhr.readyState == 4 ) {
                if ( xhr.status == 200 ) {
                    callback(xhr.responseText);
                } else {
                    callback(xhr.responseText);
                }
            }
        }
        xhr.send(null);        
    }
};

/**
  * @fileoverview AbstractSearchCriteria class file.
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * AbstractSearchCriteria object.
 * @class AbstractSearchCriteria is the super class for the the various search
 * systems  {@link SearchCriteria}, {@link CorridorSearchCriteria} 
 * @see SearchCriteria
 * @see CorridorSearchCriteria
 * @constructor
 */
function AbstractSearchCriteria() {
    

    /**
     * POIs must have this sub-string located in their name to be returned.
     * Example, 'pizza' or 'parking'.
     * @type String
     */
    this.queryString = "";
    /**
     * The maximum number of POIs to return, cannot exceed 100.
     * @type int
     * @default 10
     */
    this.maximumResponses = 10;
    /**
     * If the DDS Web Services has an external POI database, look in the
     * database defined by this name. Unless instructed to do otherwise, leave
     * this parameter set to null.
     * This can also be set to query the deCarta NavSearch
     * database by using a string prefixed with "search:deCarta:". The target
     * name, as defined by the DDS Web Services configuration, needs to be
     * appended to this string following the second colon.
     * @type String
     * @default null
     */
    this.database = null;
    /**
     * The direction, either "Ascending" or "Descending", in which to return
     * results. The POIs are sorted by their sortCriteria.
     * This is part of the NavSearch capability built into the
     * DDS Web Services.
     * @type string
     * @default "Ascending"
     */
    this.sortDirection = "Ascending";
    /**
     * The criteria on which to sort.
     * This is part of the NavSearch capability built into the
     * DDS Web Services.
     * @type string
     * @default "Distance"
     */
    this.sortCriteria = "Distance";
    /**
     * The criteria on which to rank results.
     * This is part of the NavSearch capability built into the
     * DDS Web Services.
     * @type string
     * @default null
     */
    this.rankCriteria = null;
    /**
     * Whether or not to aggregate found POIs into collections.
     * This is part of the NavSearch capability built into the
     * DDS Web Services.
     * @type boolean
     * @default false
     */
    this.allowAggregates = false;
    /**
     * If true, the POIList will be empty retrieving all of the POI's from the
     * index.
     * @type boolean
     * @default false
     * @private
     */
    this.retrieveAll = false;
    /**
     * Optional object of custom name/value pairs for filtering the response.
     * If you are using the database search, you can optionally search by either
     * category or name with these two configurations:
     * <pre>

        // searches by name:

        { POIName : "Tommy's Joynt" }

        // searches by category:
    
        { CATEGORY : "Restaurant" } // common categories: ATM, Attraction, Bar,Nightlife, Cinema, Coffee, Hotel, Museum, Petrol, Restaurant, Shopping, Theater, Transport

       </pre>
     *
     * @type Object
     */
    this.properties = {};
    /**
     * Enforces units of distance to describe the found POIs in.
     * @type UOM
     * @default null
     */
    this.defaultUOM = null;

}
/**
 * @class General class for managing ads.  This class communicates with our
 * our proxy server which hides the credentials and formats the XML response
 * to JSON.  Presently we support 3 ad networks:
 *
 * NAVTEQ:
 <pre>
    var _lon = Math.floor((map.getCenterPosition().getLon()*1000000));
    var _lat = Math.floor((map.getCenterPosition().getLat()*1000000));
    var provider = "NAVTEQ";
    var params = {
        Keywords : "hotels,bars,atm,cafe",
        maxStorefronts : "10",
        maxads: "8",
        latitude : _lat,
        bannersizes : "103",
        iconsizes : "3",
        longitude : _lon
    }
    deCarta.AdManager.requestAds(provider,params,function(json){
    console.log(json);
    });
 </pre>

 * ADMARVEL:
 <pre>
    function getAdMarvelAds(){
        var _lon = map.getCenterPosition().getLon();
        var _lat = map.getCenterPosition().getLat();
        var provider = "ADMARVEL";
        var params = {
            GEOLOCATION : _lat+","+_lon,
            TYPE : "banner"
            KEYWORDS : "food wine entertainment"
        }
        deCarta.AdManager.requestAds(provider,params,function(json){
            console.log(json);
        })
    }
 </pre>

 * ADFONIC:
 <pre>
    function getAdfonicAds(){
        var provider = "ADFONIC";
        var params = {}
        deCarta.AdManager.requestAds(provider,params,function(json){
            console.log(json);
        })
    }
 </pre>

 * @constructor
 */
deCarta.AdManager = {
    url : "http://mobile-dev.decarta.com/adproxies/AdController",
//    url : "http://localhost:8081/ad_proxies/AdController",
    callbacks : [],
    scriptCounter : 0,
    scriptTagId : "deCartaAdScript",
    requestAds : function(provider, parameters, callback){
        // Create the request id
        var id = deCarta.AdManager.scriptCounter++;
        // Create the script tag
        var scriptObj = document.createElement("script");
        // set type, source and id for script tag
        scriptObj.setAttribute("type", "text/javascript");
        scriptObj.setAttribute("id", deCarta.AdManager.scriptTagId+id);

        var DECARTAADID = "?DECARTAADID="+id;
        var ADPROVIDER = "&ADPROVIDER="+provider;
        
        deCarta.AdManager.callbacks[id] = callback;

        var completeURL=deCarta.AdManager.url+DECARTAADID+ADPROVIDER;
        for(var p in parameters){
            if(parameters.hasOwnProperty(p)){
                completeURL+= "&"+p+"="+escape(parameters[p]);
            }
        }
        scriptObj.setAttribute("src", completeURL);
        document.getElementsByTagName("head").item(0).appendChild(scriptObj);
        deCarta.AdManager.scriptObj=scriptObj;
    },
    callback:function(json){
        var id = parseInt(json.DECARTAADID);
        var scriptObj = document.getElementById(deCarta.AdManager.scriptTagId+id)
        if(scriptObj){
            document.getElementsByTagName("head").item(0).removeChild(scriptObj);
        }
        deCarta.AdManager.callbacks[id](json);
    }
};

/**
 * @fileoverview Address representing structured address
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class The Address class holds structured address information. Structured 
 * address information is pre-parsed and assigned an appropriate field within the
 * class; there is no confusion over whether the number is a postal code or a 
 * block address number. This class is used mainly to return values from a 
 * {@link Geocoder#reverseGeocode} request.
 * @description Build a structured Address object.
 * @param {String} buildingNumber optional Address number for this location.
 * @param {String} street optional Name and designation of the street (ie Main 
 * St) for this location.
 * @param {String} countrySubdivision optional Sub-country administrative 
 * division (ie the state, province, or region) for this location.
 * @param {String} countrySecondarySubdivision optional County (or equivalent) 
 * for this location.
 * @param {String} municipality optional City, town, village, or equivalent for 
 * this location.
 * @param {String} postalCode optional Postal code, postcode, ZIP code, or 
 * equivalent numerical code for this location.
 * @param {String} municipalitySubdivision optional Recognized neighborhood, 
 * borough, or equivalent for this location.
 * @param {Locale} locale optional What parsing rules should be used to improve 
 * the address match rate. Default is equivalent to a Locale of "en" (English) 
 * language and "US" (United States) country parsing.
 * @see FreeFormAddress
 * @constructor
 */
function Address (buildingNumber, street, countrySubdivision, countrySecondarySubdivision, municipality, postalCode, municipalitySubdivision, locale) {

    

    //************************* Public fields
    /** 
     * Address number for this location.
     * @type String 
     * @default ""
     */
    // The building number could be 0, I guess
    if ( buildingNumber || buildingNumber == 0 ) {
        this.buildingNumber = buildingNumber;
    } else {
        this.buildingNumber = "";
    }
    /**
     * If this address is a landmark, for example 'Big Ben'.
     * @type String
     * @default ""
     */
    this.landmark = "";
    /**
     * Name and designation of the street (ie Main St) for this 
     * location.
     * @type String 
     * @default ""
     */
    this.street = street || "";
    /**
     * A single line combining street and building number.
     * This field will only be used when making structured geocoding requests
     * to the server.
     * A non-empty street AND building number field will cause this field
     * to be ignored when forming the request to the server.
     * If a structured Address is returned in the response of a
     * {@link Geocoder#geocode} request, this field will be unused in favor
     * of the more explicit buildingNumber and street fields.
     * @type String
     * @default ""
     */
    this.streetNameAndNumber = "";
    /**
     * If available, the posted speed limit at this particular address along
     * the given street. The speed limit will be returned as a string, e.g.
     * "35mph".
     * @type String
     * @default ""
     */
    this.speedLimit = "";
    /**
     * The country code for a reverse-geocoded address.
     * Any value set for this property for a structured address that will
     * be used for geocoding will be ignored. In the case of geocoding, use
     * {@link Address#locale}.
     * Property not set through the constructor.
     * @type String
     * @default ""
     * @see Address#locale
     */
    this.countryCode = "";
    /**
     * Sub-country administrative division (ie the state, province, 
     * or region) for this location.
     * @type String 
     * @default ""
     */
    this.countrySubdivision = countrySubdivision || "";
    /** 
     * County (or equivalent) for this location.
     * @type String
     * @default ""
     */
    this.countrySecondarySubdivision = countrySecondarySubdivision || "";
    /**
     * MCD or CCD (or equivalent) for this location.
     * This will usually be empty.
     * @type String
     * @default ""
     */
    this.countryTertiarySubdivision = "";
    /** 
     * City, town, village, or equivalent for this location.
     * @type String 
     * @default ""
     */
    this.municipality = municipality || "";
    /** 
     * Postal code, postcode, ZIP code, or equivalent numerical code
     * for this location.
     * @type String
     * @default ""
     */
    this.postalCode = postalCode || "";
    /**
     * Recognized neighborhood, borough, or equivalent for this 
     * location.
     * @type String
     * @default ""
     */
    this.municipalitySubdivision = municipalitySubdivision || "";
    /**
     * Parsing rules to be used with this FreeFormAddress object.
     * @type Locale 
     * @default new Locale("en", "US");
     */
    this.locale = locale || new Locale("en","US");

    //*************************Private or hidden fields
    /**
     * Designation that this is a structured address.
     * @type string
     * @default "Structured"
     * @private
     */
    this.type = "Structured";

}// End Address Contructor


/**
 * Retrieve the address number for this location.
 * @return {String} buildingNumber field of the Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.getBuildingNumber = function(){
    return this.buildingNumber;
};
/**
 * Set the address number for this location.
 * @param {string} buildingNumber required Sets a new building number for this
 * address.
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.setBuildingNumber = function( buildingNumber ){
    this.buildingNumber = buildingNumber;
};

/**
 * Retrieve the name and designation of the street (ie Main St)
 * for this location.
 * @return {String} street field of the Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.getStreet = function(){
    return this.street;
};
/**
 * Set the name and designation of the street (ie Main St)
 * for this location.
 * @param {string} street required the new street name.
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.setStreet = function( street ){
    this.street = street;
};


/**
 * Retrieve the sub-country administrative division (ie the 
 * state, province, or region) for this location object.
 * @return {String} countrySubdivision field of the Address
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.getCountrySubdivision = function(){
    return this.countrySubdivision;
};
/**
 * Set the sub-country administrative division (ie the 
 * state, province, or region) for this location object.
 * @param {string} countrySubdivision required set a new countrySubdivision field.
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.setCountrySubdivision = function( countrySubdivision ){
    this.countrySubdivision = countrySubdivision;
};

/**
 * Retrieve the county (or equivalent) for this location.
 * @return {String} countrySecondarySubdivision field of the 
 * Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */		
Address.prototype.getCountrySecondarySubdivision = function(){
    return this.countrySecondarySubdivision;
};
/**
 * Set the county (or equivalent) for this location.
 * @param {string} countrySecondarySubdivision required set this field of the 
 * Address object.
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */		
Address.prototype.setCountrySecondarySubdivision = function( countrySecondarySubdivision ){
    this.countrySecondarySubdivision = countrySecondarySubdivision;
};

/**
 * Retrieve the city, town, village, or equivalent for this 
 * location.
 * @return {String} municipality field of the Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.getMunicipality = function(){
    return this.municipality;
};
/**
 * Set the city, town, village, or equivalent for this 
 * location.
 * @param {String} municipality set this field of the Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.setMunicipality = function( municipality ){
    this.municipality = municipality;
};


/**
 * Retrieve the recognized neighborhood, borough, or equivalent for this 
 * location.
 * @return {String} municipalitySubdivision field of this Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.getMunicipalitySubdivision = function(){
    return this.municipalitySubdivision;
};
/**
 * Set the recognized neighborhood, borough, or equivalent for this 
 * location.
 * @param {String} municipalitySubdivision required set this field of this 
 * Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.setMunicipalitySubdivision = function( municipalitySubdivision ){
    this.municipalitySubdivision = municipalitySubdivision;
};

/**
 * Retrieve the postal code, postcode, ZIP code, or equivalent 
 * numerical code for this location.
 * @return {String} postalCode field of the Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.getPostalCode = function(){
    return this.postalCode;
};
/**
 * Set the postal code, postcode, ZIP code, or equivalent 
 * numerical code for this location.
 * @param {String} postalCode required set this field of the Address object
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.setPostalCode = function( postalCode ){
    this.postalCode = postalCode;
};


/**
 * Retrieve the locale associated with this structured address.
 * @return {Locale} the locale object that governs how this address should
 * be geocoded.
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.getLocale = function() {
    return this.locale;
};
/**
 * Set the locale associated with this structured address.
 * @param {Locale} locale set the locale object that governs how this address 
 * should be geocoded.
 * @deprecated does not offer any benefit over directly accessing object fields.
 * Use equivalent field.
 * @private
 */
Address.prototype.setLocale = function( locale ) {
    this.locale = locale;
};


/**
 * Concatenates the buildingNumber, street, municipality, countrySubdivision
 * and postalCode fields, in that order and returns that string.
 * @return {String} the Address object as a single, space-delimited, 
 * unpunctuated, string.
 */
 Address.prototype.toString = function(){

    var retval = "";
    if ( this.buildingNumber != "" )
        retval += this.buildingNumber + " ";
    if ( this.street != "" )
        retval += this.street + " ";
    if ( this.municipality != "" )
        retval += this.municipality + " ";
    if ( this.countrySubdivision != "" )
        retval += this.countrySubdivision + " ";
    if ( this.postalCode != "" && typeof this.postalCode != 'object')
        retval += this.postalCode;
    return retval;
};
/**
 * @fileoverview Contents of the animator class.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class Constructs a new animator class. One animator class can handle one
 * type of animation on an array of JSAPI objects. The animation performed
 * here is specific to map based objects that need to be animated around specific
 * map based coordinates (lat/lon and equivalent screen position) rather than
 * the simpler HTML DOM (top/left/right/bottom) coordinates.
 * Objects can only be queued for one animation at a time, but via the use
 * of callbacks multiple animations can be chained.
 * @description Construct a new deCarta Animator.
 * @constructor
 * @private
 */
deCarta.Animator = function() {};

/**
 * The batch of objects of which to apply a particular animation to.
 * Treat this property as read only.
 * @type array
 * @default null
 */
deCarta.Animator.prototype.objsToAnimate = null;

/**
 * The type of objects that will be animated.
 * Treat this property as read only.
 * @type string
 * @default null
 */
deCarta.Animator.prototype.objsType = null;

/**
 * The scope of the animation. Animations right now occur within the scope
 * of a {@link Map}.
 * @type Object
 * @default null
 */
deCarta.Animator.prototype.scopeObj = null;

/**
 * Animation "on-end" callback function. If a function is tied in, it will
 * be passed the remnants of the Animator object, giving the callback access
 * to all properties before the original Animator object itself gets disposed
 * of.
 * @type function
 * @default null
 */
deCarta.Animator.prototype.onendCallback = null;

/**
 * The actual animation function that will be performed.
 * @private
 * @type function
 * @default null
 */
deCarta.Animator.prototype.animation = null;

/**
 * Identification of the current setTimeout running on this batch of objects.
 * Null if the animation is not currently happening (either not started or
 * has just ended).
 * @type number
 * @default null
 */
deCarta.Animator.prototype.animationId = null;

/**
 * Accepts either a single or an array of deCarta JSAPI objects to be animated.
 * The advantage of using arrays of objects is that only 1 setTimeout loop will
 * be created for the entire batch of objects.
 * decarta JSAPI objects that can be animated: {@link Pin}.
 * @example
 * // Object animation
 * // Create a Pin object
 * var p = new Pin(...);
 * // Be sure to set up the pin object completely before passing it to
 * // the animator.
 * EventRegistry(p, "click", eventCallBack);
 * // Make all of the rest of the pins you wish to animate and add to an array
 * // or for single animations just add the Pin to an animator
 * var a = new deCarta.Animator();
 * a.addObjsToAnim(p);
 * @param {Object or Array} objsToAnimate required Either singular allowable object
 * or an array of objects to animate. When multiple objects need to be animated
 * at the same time in the same way, arrays will cut down on the number of
 * running setTimeOut queues.
 * @throws {Exception} If objects passed in are not of a valid type.
 * @see Pin
 */
deCarta.Animator.prototype.setObjsToAnimate = function(objsToAnimate) {
    
    if ( !deCarta.Array.isArray(objsToAnimate) ) {
        // Add singular objects to an array. Allows one set of logic to
        // sort everything out.
        objsToAnimate = [objsToAnimate];
    }
    // counter
    var i;
    // Objects must have a type property
    var objsType = objsToAnimate[0].type;
    // The valid deCarta types that can be animated.
    var validTypes = ["pin"];
    var numValidTypes = validTypes.length;
    for ( i = 0; i < numValidTypes; i++ ) {
        if ( objsType == validTypes[i] ) {
            // valid type, break out
            break;
        }
    }
    if ( i >= numValidTypes ) {
        throw new Exception("requesting to animate invalid object type: " + this.objsType );
    }
    var numObjs = objsToAnimate.length;
    // Check that all types are valid
    for ( i = 0; i < numObjs; i++ ) {
        // Use the local vare for speed
        if ( objsToAnimate[i].type != objsType ) {
            throw new Exception("obj index: "+ i +" is of invalid type: "+ objsToAnimate[i].type );
        }
    }
    // We made it here, set properties we need for later
    this.objsType = objsType;
    this.objsToAnimate = objsToAnimate;
};

/**
 * Sets the scope of the animation. In the deCarta JSAPI, most animation will
 * occur within the frame of reference relative to a Map. A Map object, in this
 * case, defines where the animation will occur.
 * @param {Object} scopeObj required The Map object that provides the scope
 * for the animation.
 */
deCarta.Animator.prototype.setScopeObj = function(scopeObj) {
    
    // Plug and pray
    this.scopeObj = scopeObj;
};

/**
 * Defines a function to be executed at the end of the animation sequence.
 * The callback function will be passed one argument, and that is a reference
 * to this Animator object before.
 * @param {function} callback required
 * @throws {Exception} if arg is not a function.
 */
deCarta.Animator.prototype.setOnendCallback = function(callback) {
    
    if ( typeof callback != 'function' ) {
        throw new Exception("deCarta.Animator.setOnendCallback: callback not a function");
    }
    this.onendCallback = callback;
};

/**
 * Set the type of animation that will be performed.
 */
deCarta.Animator.prototype.setAnimation = function(animation) {

};

/**
 * @fileoverview Additional, array centric functions to avoid the need to
 * extend the native JS Array object.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @namespace Container for the deCarta JS Array utilities.
 * @description deCarta specific array functions.
 * @private
 */
deCarta.Array = {};

/**
 * Used to test if one of the arguments is an array.
 * @param {object} potentialArray required Object to check for Array-ness.
 * @returns {boolean} true if an instance of Array, false if not.
 */
deCarta.Array.isArray = function( potentialArray ) {
    
    return Object.prototype.toString.call(potentialArray) === '[object Array]';
};

/**
 * Returns the first index at which a given element can be found in the array,
 * or -1 if it is not present.
 * Provides indexOf functionality in JS where it might not exist.
 * Equality checking is very shallow, and only reliably works on primitives.
 * @param {Array} array An array to search through.
 * @param {Object} el The element to search for in the array.
 * @param {Number} [from=0] The index to begin searching from.
 * @return {number|-1} index of the type-exact match of the element, or -1
 * if no element could be found.
 */
deCarta.Array.indexOf = function( array, el, from ) {
    
    
    var length = array.length;

    // set starting index
    from = (!from || isNaN(from)) ? 0 : from;
    from = (from <= 0) ? 0 : from;
    from = (from >= length-1) ? length-1 : from;

    for (; from < length; from++)
    {
        if (array[from] === el) {
            return from;
        }
    }
    return -1;
};

/** 
 * @fileoverview BoundingBox represented by latitude and longitude coordinates at a
 * rectangle's top right corner (maximum) and bottom left corner (minimum).
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */  
/**
 * @class The BoundingBox class marks a rectangular geography. The extents are 
 * marked by two {@link Position}s located at the upper-right (maximum) and 
 * lower-left (minimum) locations.
 * @description Build a BoundingBox object. As long as minPos and maxPos are valid
 * Position objects, the constructor will correctly set the minPosition and maxPosition
 * fields of the resulting BoundingBox.
 * @param {Position} minPos required bottom left position.
 * @param {Position} maxPos required top right position.
 * @throws {Exception} If invalid arguments prevent construction of a 
 * BoundingBox object.
 * @throws {Exception} If minPos.lat > maxPos.lat
 * @see Position
 * @constructor
 */
function BoundingBox(minPos,maxPos){
    
    if( !(minPos && (minPos.lat || minPos.lat == 0) && (minPos.lon || minPos.lon == 0)) ||
        !(maxPos && (maxPos.lat || maxPos.lat == 0) && (maxPos.lon || maxPos.lon == 0)) ) {
        throw new Exception("Error instantiating BoundingBox, invalid parameters: " + minPos + maxPos );
    }

    if(minPos.lat>maxPos.lat){
        throw new Exception("Error instantiating BoundingBox, minPos.lat should <= maxPos.lat");
    }
    /**
     * The lower-left corner of the bounding box
     * @type Position
     */
    //this.minPosition = new Position( Math.min(minPos.lat, maxPos.lat), Math.min(minPos.lon, maxPos.lon) );
    this.minPosition = new Position(minPos.lat,minPos.lon);
    /**
     * The upper-right corner of the bounding box
     * @type Position
     */
    //this.maxPosition = new Position( Math.max(minPos.lat, maxPos.lat), Math.max(minPos.lon, maxPos.lon) );
    this.maxPosition = new Position(maxPos.lat,maxPos.lon);
    /**
     * The function to get the height in degrees of the bounding box
     * @retrun  float
     */
    this.getHeightInDegrees = function(){
        return this.maxPosition.lat - this.minPosition.lat;
    }
    /**
     * The function to get the width in degrees of the bounding box
     * @retrun float
     */
    this.getWidthInDegrees = function(){
        if(this.minPosition.lon>this.maxPosition.lon) return (this.maxPosition.lon - this.minPosition.lon)+360;
        else return (this.maxPosition.lon - this.minPosition.lon);
    }
    
    /**
     * Convenience function to get the upper left corner position.
     * @return {Position} computed upper left corner of position.
     */
    this.getUpperLeftPosition = function() {
        var pos = new Position( this.maxPosition.lat, this.minPosition.lon );
        return pos;
    };
    /**
     * Convenience function to get the upper left corner position.
     * @return {Position} computed upper left corner of position.
     */
    this.getLowerRightPosition = function() {
        var pos = new Position( this.minPosition.lat, this.maxPosition.lon );
        return pos;
    };

    /**
     * Retrieve the upper-right corner of the bounding box.
     * @return {Position} same as accessing the maxPosition field of the
     * BoundingBox directly
     */
    this.getMaxPosition = function(){
        
        return this.maxPosition;
    };
    /**
     * Correctly reset the maximum position, or upper right corner, of this
     * bounding box. Will reset the minPosition if necessary to reflect the
     * newly requested maximum position. Use this function when you want to
     * enforce correctness of the BoundingBox object. Directly access the
     * properties when you don't need this added level of protection.
     * @param {Position} newMaxPosition required Correctly resets the maximum
     * position of the bounding box relative to this position and the existing
     * minPosition (lower left corner).
     * @throws {Exception} if newMaxPosition is invalid.
     */
    this.setMaxPosition = function( newMaxPosition ) {
        
        //        if (!(newMaxPosition && (newMaxPosition.lat || newMaxPosition.lat == 0) && (newMaxPosition.lon || newMaxPosition.lon == 0)))  {
        //            throw new Exception("setMaxPosition: Error, invalid parameter : " + newMaxPosition );
        //        }
        //        var oldMinPosition = new Position( this.minPosition.lat, this.minPosition.lon );
        //        this.maxPosition.lat = Math.max( oldMinPosition.lat, newMaxPosition.lat );
        //        this.maxPosition.lon = Math.max( oldMinPosition.lon, newMaxPosition.lon );
        //
        //        this.minPosition.lat = Math.min( oldMinPosition.lat, newMaxPosition.lat );
        //        this.minPosition.lon = Math.min( oldMinPosition.lon, newMaxPosition.lon );
        if(this.minPosition.lat>newMaxPosition.lat){
            throw new Exception("Error setting maxPosition, minPos.lat should <= maxPos.lat");
        }
        this.maxPosition=new Position(newMaxPosition.lat,newMaxPosition.lon);
    };
    /**
     * Retrieve the lower-left corner of the bounding box.
     * @return {Position} same as accessing the minPosition field of the
     * BoundingBox directly.
     */
    this.getMinPosition = function(){
        
        return 	this.minPosition;
    };
    /**
     * Correctly reset the minimum position, or lower left corner, of this
     * bounding box. Will reset the maxPosition if necessary to reflect the
     * newly requested minimum position. Use this function when you want to
     * enforce correctness of the BoundingBox object. Directly access the
     * properties when you don't need this added level of protection.
     * @param {Position} newMinPosition required Correctly resets the minimum
     * position of the bounding box relative to this position and the existing
     * maxPosition (upper right corner).
     * @throws {Exception} if newMinPosition is invalid.
     */
    this.setMinPosition = function( newMinPosition ) {
        
        //        if (!(newMinPosition && (newMinPosition.lat || newMinPosition.lat == 0) && (newMinPosition.lon || newMinPosition.lon == 0)))  {
        //            throw new Exception("setMaxPosition: Error, invalid parameter : " + newMinPosition );
        //        }
        //        var oldMaxPosition = new Position( this.maxPosition.lat, this.maxPosition.lon );
        //        this.maxPosition.lat = Math.max( oldMaxPosition.lat, newMinPosition.lat );
        //        this.maxPosition.lon = Math.max( oldMaxPosition.lon, newMinPosition.lon );
        //
        //        this.minPosition.lat = Math.min( oldMaxPosition.lat, newMinPosition.lat );
        //        this.minPosition.lon = Math.min( oldMaxPosition.lon, newMinPosition.lon );
        if(newMinPosition.lat>this.maxPosition.lat){
            throw new Exception("Error setting minPosition, minPos.lat should <= maxPos.lat");
        }
        this.minPosition = new Position(newMinPosition.lat,newMinPosition.lon);
    };
    /**
     * Retrieve the center position of the bounding box.
     * @return {Position} calculated center point of the BoundingBox
     */
    this.getCenterPosition = function(){
        
        var centerLat = parseFloat(this.maxPosition.lat - ((this.maxPosition.lat - this.minPosition.lat)/2));
        var centerLng = parseFloat(this.maxPosition.lon - ((this.maxPosition.lon - this.minPosition.lon)/2));
        if(this.maxPosition.lon<this.minPosition.lon){
            centerLng=centerLng+180;
          
        }
        return new Position(centerLat,centerLng);
    };
	
    /**
     * Retrieves radius of the bounding box. Given that the bounding box is a
     * rectangle, this is the rough approximation of radius that will cover 
     * the entire area represented. It's not a true representation because it
     * takes the longer of either the height or width, it does not take the
     * distance to the corner of the bounding box.
     * @private
     * @return {float} Aproximate number of kilometers needed to circumscribe
     * this bounding box.
     */
    this.getRadius = function(){
        
        if (this.getHeightInDegrees() > this.getWidthInDegrees())
            return (this.getHeightInDegrees()*111.111)/2;
        else 
            return (this.getWidthInDegrees()*111.111)/2;
    };


    /**
     * Check if a given Position is within the BoundingBox.
     * @param {Position} pos required coordinate to test
     * @return {Boolean} true if located within the BoundingBox, false if 
     * located outside of the BoundingBox
     */
    this.contains = function(pos){
        
        var maxLon=this.maxPosition.lon;
        var posLon=pos.lon;
        if(this.minPosition.lon>0 && this.maxPosition.lon<this.minPosition.lon){
            maxLon=maxLon+360;
            if(pos.lon<this.minPosition.lon) posLon=posLon+360;
        }
        if(this.minPosition.lon<0 && this.maxPosition.lon<this.minPosition.lon){
            maxLon=maxLon+360;
            if(pos.lon<this.minPosition.lon) posLon=posLon+360;
        }

        if( pos.lat >= this.minPosition.lat &&
            posLon >= this.minPosition.lon &&
            pos.lat <= this.maxPosition.lat &&
            posLon <= maxLon)
            return true;
        else
            return false;
    };

    /**
     * Check if this bbox contains the bbox in parameter. Even if they tangient, still return true.
     * @param {BoundingBox} bbox
     */
    this.containsBoundingBox = function(bbox){
        
        if(!bbox) return true;
        var tlp=new Position(bbox.maxPosition.lat,bbox.minPosition.lon);
        var blp=bbox.minPosition;
        var trp=bbox.maxPosition;
        var brp=new Position(bbox.minPosition.lat,bbox.maxPosition.lon);

        if(this.contains(tlp) && this.contains(blp) && this.contains(trp) && this.contains(brp)){
            //we need to consider if this contains the four points of bbox, but the bbox is going on back of the earth
            if(new BoundingBox(this.minPosition,trp).contains(blp)) return true;

        }
        return false;

    }

    /**
     * find the overlapped bounding box
     * @param {BoundingBox} bbox bouding box to compare
     * @return {BoundingBox} return null or the overlapped bounding box
     */
    this.getOverlapBoundingBox = function(bbox){
        

        //var tl=new Position(this.maxPosition.lat,this.minPosition.lon);
        var bl=this.minPosition;
        var tr=this.maxPosition;
        //var br=new Position(this.minPosition.lat,this.maxPosition.lon);

        //var tlp=new Position(bbox.maxPosition.lat,bbox.minPosition.lon);
        var blp=bbox.minPosition;
        var trp=bbox.maxPosition;
        //var brp=new Position(bbox.minPosition.lat,bbox.maxPosition.lon);

        //test if the two bbox seperate by lat
        if(bl.lat>=trp.lat || blp.lat>=tr.lat) return null;
        //test if seperate by lon
        var bbox1=new BoundingBox(new Position(-90,bl.lon),new Position(90,tr.lon));
        var bbox2=new BoundingBox(new Position(-90,blp.lon),new Position(90,trp.lon));
        if(!bbox1.contains(blp) && !bbox1.contains(trp) && !bbox2.contains(bl) && !bbox2.contains(tr))
            return null;

        //if(this.contains(bbox)) return new BoundingBox(bbox.minPosition,bbox.maxPosition);
        //if(bbox.contains(this)) return new BoundingBox(this.minPosition,this.maxPosition);

        //find the middle two lon valuse among the four points regarding lon value
        var lon1=0,lon2=0;
        if(bbox1.contains(blp)) {
            lon1=blp.lon;
            if(bbox2.contains(bl)){
                //when bbox2 go on back of the earth and contains bl, it has two overlays, but we only return one
                lon2=tr.lon;
            }
            else if(bbox1.contains(trp)){
                lon2=trp.lon;
            }
            else lon2=tr.lon;
        }else if(bbox2.contains(bl)){
            lon1=bl.lon;
            if(bbox2.contains(tr)) lon2=tr.lon;
            else lon2=trp.lon;
        }

        var lats=[bl.lat,tr.lat,blp.lat,trp.lat];
        sort(lats);

        return new BoundingBox(new Position(lats[1],lon1),new Position(lats[2],lon2));
        

        function sort(nums){
            var i=0,j=0;
            for(i=0;i<nums.length-1;i++){
                for(j=0;j<nums.length-i-1;j++){
                    if(nums[j]>nums[j+1]){
                        var tmp=nums[j];
                        nums[j]=nums[j+1];
                        nums[j+1]=tmp;
                    }

                }

            }
        }

    };
    /**
     * Check if a given pos is within the BoundingBox extended to triple it's
     * width and height. The center 9-square bounding box pattern is the
     * original BoundingBox.
     * @param {Position} pos required coordinate to test
     * @return {Boolean} true if located within the extended BoundingBox, false 
     * if located outside of the BoundingBox
     */
    this.extendedContains = function(pos){
        

        var minPos=new Position(this.minPosition.lat-this.getHeightInDegrees(),this.minPosition.lon-this.getWidthInDegrees());
        var maxPos=new Position(this.maxPosition.lat+this.getHeightInDegrees(),this.maxPosition.lon+this.getWidthInDegrees());

        var maxLon=maxPos.lon;
        var posLon=pos.lon;
        if(minPos.lon>0 && maxPos.lon<minPos.lon){
            maxLon=maxLon+360;
            if(pos.lon<minPos.lon) posLon=posLon+360;
        }
        if(minPos.lon<0 && maxPos.lon<minPos.lon){
            maxLon=maxLon+360;
            if(pos.lon<minPos.lon) posLon=posLon+360;
        }


        if( pos.lat > minPos.lat &&
            posLon > minPos.lon &&
            pos.lat < maxPos.lat &&
            posLon < maxLon)
            return true;
        else
            return false;
    };
    /**
     * Evaluate if this BoundingBox is the same as the passed in BoundingBox.
     * @param {BoundingBox} bbox required bounding box to evaluate for equality
     * @return {Boolean} true if the two BoundingBoxes are equal, false if not
     */
    this.equals = function(bbox){
        
        if (bbox && this.minPosition.toString()==bbox.getMinPosition().toString() && this.maxPosition.toString()==bbox.getMaxPosition().toString())
            return true;
        else
            return false;
    };
	
    /**
     * Concatenate the minPosition and maxPosition of this BoundingBox and 
     * return as a String.
     * @return {String} the BoundingBox object as a single, space delimited 
     * string of positions.
     */
    this.toString = function(){
        return this.minPosition.toString()+" "+this.maxPosition.toString();
    };
}

/**
 * @fileoverview The CopyrightMessage that almost always needs to be customized
 * and displayed on a map.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class deCarta does not require products to contain a copyright. Most content
 * providers require mapping applications to dispaly a copyright with specific
 * information on their maps. The CopyrightMessage object is an easy way to display
 * any required rights information on your map application. This class can
 * be extended, or overridden, to change the default behavior of the positioning
 * and styling.
 * @description Construct a new CopyrightMessage object.
 * @param {string} message required Text to display on the map.
 * HTML structure and escaped characters can be included as this text will be
 * injected (innerHTML) into an HTML DOM object on the page.
 * @constructor
 * @see Map#addCopyrightMessage
 * @see Credentials
 */
deCarta.CopyrightMessage = function( message ) { this.init( message ); }

// ------------------------------------------------------------- Fields
/**
 * The map this particular CopyrightMessage is associated with.
 * @type Map
 * @default null
 * @private
 */
deCarta.CopyrightMessage.prototype.map = null;
/**
 * General identifcation for this map control. Part of the general map control
 * interface. Treat as a read-only property.
 * @type string
 * @default "CopyrightMessage"
 * @private
 */
deCarta.CopyrightMessage.prototype.type = "CopyrightMessage";
/**
 * The on page div displaying the instance of this copyright.
 * @type DOM Element (div)
 * @default null
 * @private
 */
deCarta.CopyrightMessage.prototype.frame = null;
/**
 * The CSS class that applies to instances of this class. Also functions as the
 * id of the on screen frame.
 * @type string
 * @default "decarta-copyright"
 * @private
 */
deCarta.CopyrightMessage.prototype.cssClass = "decarta-copyright";
/**
 * A reference copy of the message to display, mainly to allow a delay between
 * initializiation of the object, configuration, and finally addition to the
 * map.
 * @type string
 * @default null
 * @private
 */
deCarta.CopyrightMessage.prototype.message = null;
// ------------------------------------------------------------- Methods
/**
 * Initialize settings needed for the CopyrightMessage object. All building
 * of the CopyrightMessage happens after it is associated with a map. Please see
 * the class constructor for definition of the parameters.
 * @private
 */
deCarta.CopyrightMessage.prototype.init = function( message ) {
    
    // Initialize the CSS styling for the CopyrightMessage

    // Store the message to allow tailoring of the CopyrightMessage object
    this.message = message;
};
/**
 * Build the on page DOM elements, and associated event handling, that form
 * the CopyrightMessage. Does not place the CopyrightMessage onto the map.
 * @private
 */
deCarta.CopyrightMessage.prototype.build = function() {
    
    
    this.frame = document.createElement("DIV");
    this.frame.id = this.cssClass;
    this.frame.className = this.cssClass;
    // Inject the message
    this.frame.innerHTML = this.message;
    // disable the accidental selection of copyright text
    Utilities.setUnselectable( this.frame );
};



/**
 * Interface used by the Map to grab the correct DOM object to append to the
 * page. This is only called when this object is added to the map.
 * @returns {DOM Element} The DOM element representation of the CopyrightMessage
 * that should be appended to the map object.
 * @private
 */
deCarta.CopyrightMessage.prototype.appendThis = function() {
    
    // Lazy create the frame
    if (!this.frame) {
        this.build();
    }

    return this.frame;
};

/**
 * Interface for the Map object to remove the CopyrightMessage from the DOM.
 * @returns {DOM Element} The DOM element representation of the CopyrightMessage
 * that should be removed from the map object.
 * @private
 */
deCarta.CopyrightMessage.prototype.removeThis = function() {
    
    this.map = null;

    //@todo add any cleanup to this function, should we wish to.
    
    return this.frame;
};

/**
 * Repositions the CopyrightMessage relative to the associated Map instance.
 * To be called after the CopyrightMessage has been associated with a Map
 * and usually only needed when the Map has been resized. Part of the general
 * map control interface.
 * @param {DOMDimensions} ddim required Dimenions of map against which to
 * position this control.
 * @private
 */
deCarta.CopyrightMessage.prototype.position = function( ddim ) {
    
    // @todo throw an exception if there is no this.map

    // Place the map control in the default location
    this.frame.style.top = ( ddim.height - 20 ) + "px";
    this.frame.style.left = "1px";
};


/**
  * @fileoverview CorridorSearchCriteria class file.
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * Construct a new CorridorSearchCriteria object.
 * @class Used by the {@link POIQuery}, CorridorSearchCriteria .
 * @param searchTerm required String returned from RouteQuery to search along
 * @param routeId required routeId returned from RouteQuery to search along
 * @param opts optional arguments
 * <pre>
 * {
 *      type : "distance", // distance || euclideanDistance || drivetime (default distance)
 *      distance : 50, // used with type=="distance || euclideanDistance" number of METERS off route (default 50)
 *      duration : 5 // used with type=="drivetime" number of MINUTES off route (default 5)
 * }
 * </pre>
 * @see SearchCriteria
 * @see RouteQuery
 * @see POIQuery
 * @see POI
 * @extends AbstractSearchCriteria
 * @constructor
 */
function CorridorSearchCriteria( searchTerm, routeId, opts ) {
    
    if(!routeId){
        alert("CorridorSearchCriteria requires routeId");
        return;
    }
    this.routeId=routeId;

    // defaults
    this.type="distance";
    this.duration=5;//MINUTES
    this.distance=500;//METERS

    if(opts){
        if(opts.type && (opts.type==="distance" || opts.type==="euclideanDistance" || opts.type==="drivetime") ){
            this.type=opts.type;
        } else if(opts.type && !(opts.type==="distance" || opts.type==="euclideanDistance" || opts.type==="drivetime") ){
            alert("allowed values for the CorridorSearchCriteria.type distance || euclideanDistance || drivetime ");
        }
        if(opts.duration && parseInt(opts.duration)>0){
            this.duration=parseInt(opts.duration);
        }
        if(opts.distance && parseInt(opts.distance)>0){
            this.distance=parseInt(opts.distance);
        }
    }
}
// Extend class, first prototype, then reset the constructor
CorridorSearchCriteria.prototype = new AbstractSearchCriteria();
CorridorSearchCriteria.prototype.constructor = AbstractSearchCriteria;
/**
 * @fileoverview DDSShape class and extensions
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class A DDSShape, and the subclasses {@link DDSCircle}, {@link DDSLine} and
 * {@link DDSPolygon}, is used to visually display an overlay on an initialized
 * {@link Map}. To use, simply create the shape, sometimes referred to as
 * overlays, and add the shape to an instance of a Map with
 * {@link Map#addOverlay}. Shapes can be drawn by either the client or by the
 * server. When shapes are drawn by the server, they are drawn directly on the
 * map image tiles, which can aid in print handling. When shapes are drawn by
 * the client, they do not require a refresh of the map to display or remove
 * from the display. Note: Only the extended classes of DDSShape can be drawn
 * on a Map. This class merely provides common methods shared by all shapes.
 * @description Construct a new DDSShape object.
 * @constructor
 * @see Map#addOverlay
 * @see Map#setShapeRendering
 */
function DDSShape(){
    
    /**
     * RGB value for borderColor.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type string
     * @default "(0.0.0)"
     */
    this.borderColor = "(0.0.0)";
    /**
     * Red integer value from borderColor. Valid values from 0 to 255.
     * Is set through the {@link DDSShape#setBorderColor} method.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0
     */
    this.borderColorRed = 0;
    /**
     * Green integer value from borderColor. Valid values from 0 to 255.
     * Is set through the {@link DDSShape#setBorderColor} method.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0
     */
    this.borderColorGreen = 0;
    /**
     * Blue integer value from borderColor. Valid values from 0 to 255.
     * Is set through the {@link DDSShape#setBorderColor} method.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0
     */
    this.borderColorBlue = 0;
    /**
     * Draw style for map shapes.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type string
     * @default "SOLID"
     */
    this.borderStyle="SOLID";
    /**
     * Number of pixels wide to draw a line or width of
     * the border of a 2d shape.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type string
     * @default "2"
     */
    this.borderWidth="2";
    /**
     * If the shape has area, this color will be used to fill the internals
     * of the shape.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type string
     * @default "(0.0.0)"
     */
    this.fillColor="(0.0.0)";
    /**
     * Red integer value from fillColor. Valid values from 0 to 255.
     * Is set through the {@link DDSShape#setFillColor} method.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0
     */
    this.fillColorRed = 0;
    /**
     * Blue integer value from fillColor. Valid values from 0 to 255.
     * Is set through the {@link DDSShape#setFillColor} method.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0
     */
    this.fillColorBlue = 0;
    /**
     * Green integer value from fillColor. Valid values from 0 to 255.
     * Is set through the {@link DDSShape#setFillColor} method.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0
     */
    this.fillColorGreen = 0;
    /**
     * Unique shape id, mainly used for identification and removal of
     * shapes.
     * @private
     * @type integer
     * @default null
     */
    this.id = null;
    /**
     * Percantage opacity of shape on the map. "100" is opaque, "0" is
     * transparent.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type string
     * @default "65"
     * @deprecated use the distinct strokeOpacity and fillOpacity methods/props
     */
    this.opacity = "65";
    /**
     * Percentage opacity of shape on the map, expressed as a float. 1 is
     * opaque, 0 is transparent.
     * Is set through the {@link DDSShape#setOpacity} method.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0.65
     */
    this.opacityFloat = 0.65;
    /**
     * Percentage opacity of the path of the shape on the map. "100" is
     * opaque, "0" is transparent. Effects the outline of a DDSPolygon, the
     * outline of a DDSCircle, or the opacity of a DDSLine. Note: if this
     * value is not set, opacity settings will fall back to the setting in
     * the general opacity field.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type string
     * @default "65"
     */
    this.strokeOpacity = "65";
    /**
     * Percentage opacity of line stroke of the shape, expressed as a float. 1 is
     * opaque, 0 is transparent.
     * Is set either through the {@link DDSShape#setOpacity} method, where we
     * assume the app needs a general opacity, or specifically through
     * {@link DDSShape#setStrokeOpacity}.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0.65
     */
    this.strokeOpacityFloat = 0.65;
    /**
     * Percentage opacity of the fill of the shape on the map. "100" is
     * opaque, "0" is transparent. Effects the area of a DDSPolygon, and the
     * area of a DDSCircle. Does not effect a DDSLine. Note: if this
     * value is not set, opacity settings will fall back to the setting in
     * the general opacity field.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type string
     * @default "65"
     */
    this.fillOpacity = "65";
    /**
     * Percentage opacity of shape fill, expressed as a float. 1 is
     * opaque, 0 is transparent.
     * Is set either through the {@link DDSShape#setOpacity} method, where we
     * assume the app needs a general opacity, or specifically through
     * {@link DDSShape#setFillOpacity}.
     * Treat as a read only property.
     * @private
     * @type number
     * @default 0.65
     */
    this.fillOpacityFloat = 0.65;
    /**
     * Reference to the map this shape is attached to. One to one
     * relationship allowed for shapes.
     * @private
     * @type Map
     * @default null
     */
    this.map = null;
    /**
     * The visibility state of this overlay. This property is not watched;
     * changing this to false will not automatically hide the overlay on the
     * map. To hide a batch of polygons at once, it is recommended to set this
     * property to false on each polygon that you wish hidden and then call
     * {@link Map#redraw} (for client side rendering) or {@link Map#reDrawMap}
     * (for server side rendering).
     * @type boolean
     * @default true
     * @see Map#getOverlays
     * @see DDSShape#hide
     * @see DDSShape#show
     */
    this.isVisible = true;
    /**
     * Client side or server side rendering can be set per shape.
     * If this property is not set, it will be rendered according to the
     * default setting of the map (e.g. "server" or "client").
     * Setting this value to "server" or "client" will force this shape to
     * be rendered appropriately, despite the current map rendering settings.
     * @type string
     * @default null
     */
    this.rendering = null;

    /**
     * @private
     * A object contains all event:lisener pairs. We should add event using addEventListener
     * function.
     */
    this.eventListenerMap = null;

    /**
     * raphael object created using raphael API method like paper.circle(...). We should use this object
     * if we want to do some rendering operation to the shape, such as:
     * raphael_element.attr({fillColor:"red"});
     */
    this.raphael_element = null;

    /**
     * Indicate the name of this shape.
     */
    this.title="";
    /**
     * Generic description of this shape.
     */
    this.description="";
    //
    /**
     *Extendable properties to contain any application specific property. We can set saved=true/false here to
     *indicate if the shaep is saved. By this way we can know if we need to delete a shape or just ignore
     *the change when we click cancel button in the ShapeDrawingTool. It can also contain application
     *specific informaton. In Geofencing project, this object contains properties,
     *restrictedActiveTimes, and violationType fields.In ExclusionZone project, this object
     *contains properties, restrictedActiveTimes fields.
     *This field is initialized to empty object in Circle, DDSLine, and DDSPolygon's constructor.
     *@type object
     */
    this.customProperties=null;


    /**
     * @private
     * Cache index of the minPosition of the boundingbox. It's changed by zoom level because of
     * generalization.
     */
    this.generalizedMinLonIndex=[];
    
    /**
     *@private if this shape pass event to map
     */
    this.passEventToMap=false;

}
/**
 * Method used to perform point in shape checks (geofencing). Descendent classes
 * will override the base setting with an appropriate point in shape
 * method, or the method doesn't exist for the class (is null by default).
 * @function
 */
DDSShape.prototype.inside = null;
/**
 * Set the color of the overlay outline. For {@link DDSLine} we recommend using
 * the {@link DDSLine#setColor} method.
 * @param {String} borderColor required An RGB value in the format of
 * "(255.255.255)".
 * @throws {Exception} If the borderColor is not in the right format, an
 * Exception will be thrown.
 */
DDSShape.prototype.setBorderColor = function(borderColor){
    
    if(!borderColor.match(/\([0-9]+\.[0-9]+\.[0-9]+\)/)){
        throw new Exception("Error setting RGB value in DDSShape.setBorderColor. Please use format (255.255.255)");
        return;
    }
    // Store as a string and...
    this.borderColor = borderColor;
    // ...grab individual RGB values as numbers
    var rgb = borderColor.replace("(","").replace(")","").split(".");
    this.borderColorRed = parseInt(rgb[0], 10);
    this.borderColorGreen = parseInt(rgb[1], 10);
    this.borderColorBlue = parseInt(rgb[2], 10);
};
/**
 * Return the color of the overlay outline. To set a new value for the outline
 * color, use {@link DDSShape#setBorderColor}.
 * @returns {String} The RGB value of the outline color.
 */
DDSShape.prototype.getBorderColor = function(){
    
    return this.borderColor;
};

/**
 * Sets the style of the overlay outline. This will only work on shapes that
 * are drawn on the server side.
 * @param {String} borderStyle required A string describing the style of the
 * overlay outline. Valid settings are "SOLID", "DASH", "DOT", "DASHDOTDOT",
 * "ALTBLACKDASH", "RAIL", and "NONE".
 * @throws {Exception} If the borderStyle is not a valid value, throw an Exception.
 */
DDSShape.prototype.setBorderStyle = function(borderStyle){
    
    if(borderStyle=="SOLID" || borderStyle=="DASH" || borderStyle=="DOT" || borderStyle=="DASHDOTDOT" || borderStyle=="ALTBLACKDASH" || borderStyle=="RAIL" || borderStyle=="NONE"){
        this.borderStyle=borderStyle;
    } else {
        throw new Exception("Error setting border style value in DDSShape.setBorderStyle. Please use format SOLID, DASH, DOT, DASHDOTDOT, ALTBLACKDASH, RAIL, NONE");
        return;
    }
};
/**
 * Return the style over the overlay outline. To set a new style for the outline,
 * see {@link DDSShape#setBorderStyle}.
 * @returns {String} The current outline style.
 */
DDSShape.prototype.getBorderStyle = function(){
    
    return this.borderStyle;
};
/**
 * Sets the width of the outline, in pixels, for the overlay.
 * @param {String} borderWidth required Pixel width for the border.
 */
DDSShape.prototype.setBorderWidth = function(borderWidth){
    
    this.borderWidth=borderWidth;
};
/**
 * Return the pixel width of the overlay outline. To set a new pixel width for
 * the outline, see {@link DDSShape#setBorderWidth}.
 * @returns {String} The current border width.
 */
DDSShape.prototype.getBorderWidth = function(){
    
    return this.borderWidth;
};
/**
 * Set the fill color of the overlay. For {@link DDSLine} we recommend using
 * the {@link DDSLine#setColor} method.
 * @param {String} fillColor required An RGB value in the of format "(255.255.255)".
 * @throws {Exception} If the fillColor is not in the right format, an Exception
 * will be thrown.
 */
DDSShape.prototype.setFillColor = function(fillColor){
    
    if(!fillColor.match(/\([0-9]+\.[0-9]+\.[0-9]+\)/)){
        throw new Exception("Error setting RGB value in DDSShape.setColor. Please use format (255.255.255)");
        return;
    }
    // Store as a string...
    this.fillColor=fillColor;
    // ...grab individual RGB values as numbers
    var rgb = fillColor.replace("(","").replace(")","").split(".");
    this.fillColorRed = parseInt(rgb[0], 10);
    this.fillColorGreen = parseInt(rgb[1], 10);
    this.fillColorBlue = parseInt(rgb[2], 10);
};
/**
 * Return the fill color of the overlay.
 * @returns {String} The RGB value of the fill color.
 */
DDSShape.prototype.getFillColor = function(){
    
    return this.fillColor;
};
///**
// * @param {String} id
// */
//DDSShape.prototype.setId = function(id){
//	this.id=id;
//}
/**
 * Returns the unique id of the overlay.
 * @returns {String} The id for this overlay.
 * @see Map#removeOverlayById
 */
DDSShape.prototype.getId = function(){
    
    return this.id;
};

DDSShape.prototype.getTitle = function(){
    
    return this.title;
};

DDSShape.prototype.setTitle = function(title){
    
    this.title=title;
};

DDSShape.prototype.getDescription = function(){
    
    return this.description;
};

DDSShape.prototype.setDescription = function(desc){
    
    this.description=desc;
};
/**
 * Sets the general opacity level for the shape, and overwrites any previous
 * changes made in setStrokeOpacity or setFillOpacity.
 * @param {String} opacity required The opacity from 0 (completely transparent)
 * to 100 (completely visible).
 * @throws {Exception} if argument is an invalid opacity setting.
 * @deprecated use the distinct setStrokeOpacity and setFillOpacity methods.
 */
DDSShape.prototype.setOpacity = function(opacity){
    

    var opacityPercent = parseInt(opacity, 10) / 100;
    if ( isNaN(opacityPercent) ) {
        throw new Exception("DDSShape.prototype.setOpacity: invalid argument of: " + opacity);
    }

    // Assume general opacity settings...
    this.opacity = opacity;
    //... also calculate float percentages ...
    this.opacityFloat = opacityPercent;
    this.strokeOpacityFloat = opacityPercent;
    this.fillOpacityFloat = opacityPercent;
};
/**
 * Return the current opacity level for this shape.
 * @returns {String} The opacity level, from 0 (completely transparent) to 100
 * (completely visible).
 * @deprecated use the distinct getStrokeOpacity and getFillOpacity methods.
 */
DDSShape.prototype.getOpacity = function(){
    
    return this.opacity;
};
/**
 * Set the opacity for the path of the object. If this is not used, the
 * general opacity settings will be used for determining opacity of the path.
 * Note this only effects shapes drawn on the client side. Printable, or server
 * drawn shapes, use the generic opacity setting and the setting affects the
 * entire shape.
 * @param {String} opacity required The opacity from 0 (completely transparent)
 * to 100 (completely visible).
 * @throws {Exception} if argument is an invalid opacity setting.
 */
DDSShape.prototype.setStrokeOpacity = function(opacity) {
    

    var opacityPercent = parseInt(opacity, 10) / 100;
    if ( isNaN(opacityPercent) ) {
        throw new Exception("DDSShape.prototype.setStrokeOpacity: invalid argument of: " + opacity);
    }

    // Assume general opacity settings...
    this.strokeOpacity = opacity;
    //... also calculate float percentages ...
    this.strokeOpacityFloat = opacityPercent;
};
/**
 * Return the current opacity level for path of this shape.
 * @returns {String} The opacity level, from 0 (completely transparent) to 100
 * (completely visible). If an empty string is returned, the opacity of the
 * has not yet been set.
 */
DDSShape.prototype.getStrokeOpacity = function(){
    
    return this.strokeOpacity;
};
/**
 * Set the opacity for the area fill of the object. If this is not used, the
 * general opacity settings will be used for determining opacity of the fill.
 * Fill opacity is not used for a DDSLine and will thusly be ignored. Note
 * this only effects shapes drawn on the client side. Printable, or server
 * drawn shapes, use the generic opacity setting and the setting affects the
 * entire shape.
 * @param {String} opacity required The opacity from 0 (completely transparent)
 * to 100 (completely visible).
 * @throws {Exception} if argument is an invalid opacity setting.
 */
DDSShape.prototype.setFillOpacity = function(opacity) {
    

    var opacityPercent = parseInt(opacity, 10) / 100;
    if ( isNaN(opacityPercent) ) {
        throw new Exception("DDSShape.prototype.setStrokeOpacity: invalid argument of: " + opacity);
    }

    // Assume general opacity settings...
    this.fillOpacity = opacity;
    //... also calculate float percentages ...
    this.fillOpacityFloat = opacityPercent;
};
/**
 * Return the current opacity level for path of this shape.
 * @returns {String} The opacity level, from 0 (completely transparent) to 100
 * (completely visible). If an empty string is returned, the opacity of the
 * has not yet been set.
 */
DDSShape.prototype.getFillOpacity = function(){
    
    return this.fillOpacity;
};
/**
 * Hide this shape and, if it is associated with a map and this is a state change,
 * force the display of shapes to be updated auotmatically. In general, this
 * function should be used to hide shapes on a map. However, if many, many
 * shapes need to be hidden at once, it is recommended that all shapes be marked
 * for hiding via the isVisible property (set to false) and then call a
 * {@link Map#redraw} assuming that client side rendering is being performed. If
 * more than one shape needs to updated and server side shape rendering is
 * being used, it is highly recommended to change the isVisible property only
 * and then manually call {@link Map#reDrawMap} when you wish to re-render the
 * shapes.
 * @see DDSShape#show
 * @see DDSShape#isVisible
 */
DDSShape.prototype.hide = function() {
    
    // Don't force unnecessary redraws
    if ( this.isVisible == true ) {
        this.isVisible = false;
        if ( this.map ) {
            if ( this.map.getShapeRendering() == "client" ) {
                //this.map.redraw();
                if(this.raphael_element) this.raphael_element.hide();
            }
            else {
                // server side full redraw
                this.map.reDrawMap();
            }
        }
    }
};
/**
 * Show this shape and, if it is associated with a map and this is a state change,
 * force the display of shapes to be updated auotmatically. In general, this
 * function should be used to show shapes on a map. However, if many, many
 * shapes need to be made visible at once, it is recommended that all shapes be marked
 * visible via the isVisible property (set to true) and then call a
 * {@link Map#redraw} assuming that client side rendering is being performed. If
 * more than one shape needs to updated and server side shape rendering is
 * being used, it is highly recommended to change the isVisible property only
 * and then manually call {@link Map#reDrawMap} when you wish to re-render the
 * shapes.
 * @see DDSShape#show
 * @see DDSShape#isVisible
 */
DDSShape.prototype.show = function() {
    
    // Don't force unnecessary redraws
    if ( this.isVisible == false ) {
        this.isVisible = true;
        if ( this.map ) {
            if ( this.map.getShapeRendering() == "client" ) {
                //this.map.redraw();
                if(this.raphael_element) this.raphael_element.show();
                else this.map.drawShape(this);
            }
            else {
                // server side full redraw
                this.map.reDrawMap();
            }
        }
    }
};
/**
 * Figures out if this shape is identical to shape passed in as an argument.
 * @param {DDSShape} obj required The shape to compare this to.
 * @returns {Boolean} 'true' if id's are equal, 'false' if not.
 */
DDSShape.prototype.equals = function(obj){
    
    if(obj && this.id==obj.id)
        return true;
    else
        return false;
};

/**
 * setup event listener on this shape
 * @private
 * @static
 * @param {string} event name such as onclick, onmouseup, etc.
 * @param {function} handler for event
 */
DDSShape.prototype.addEventListener = function(event, handler) {
    if(!this.eventListenerMap) this.eventListenerMap={};
    if(typeof handler == 'function'){
        //event is onclick, onmouseup, etc format
        this.eventListenerMap[event]=handler;
        if(this.raphael_element && this.raphael_element.node){
            this.raphael_element.node[event]= function(e){
                e = e ? e : window.event;
                var s=this.raphael.owner_shape;
                var eType=e.type;
                eType='on'+eType;
                var func=s.eventListenerMap[eType];
                func(s);
            };
        }
    }

};

/**
 * Static function borrowed by the DDSPolygon and the DDSLine to convert positions
 * in standard coordinates to Mercator Pixels.
 * @private
 * @static
 * @param {number} zoomLevel required The standard zoom level at which to return mercator
 * pixels.
 * @param {number} tileSize required Number of pixels tall/wide of the underlying
 * map. Required to correctly generalize the polygon.
 * @returns {Array} Mercator Pixel (in PixelPoint objects) representation of
 * the polygonal positions. Treat returned array as read only.
 */
DDSShape.getMercPixels = function(zoomLevel, tileSize) {
    

    if ( this.mercPixels[zoomLevel] ) {
        // return immediately
        return (this.mercPixels[zoomLevel]);
    }
    // else...
    // Need to create mercator pixels for this shape
    // Local copy of non-mercator positions
    var posStore = this.positions;
    var minPositionLon=this.getBoundingBox().minPosition.lon;
    var minPosIndex=0;

    // Used for the coordinate conversion
    var sl = Utilities.radsPerPixelAtZoomLevel(tileSize, zoomLevel);

    if (this.generalize) {
        // No mercator pixels, and we want to generalize
        if(this.generalized[zoomLevel]){
            posStore=this.generalized[zoomLevel];
            if(this.generalizedMinLonIndex[zoomLevel]){
                minPosIndex=this.generalizedMinLonIndex[zoomLevel];
            }else{
                var dist=Utilities.pix2lon(10,sl);
                for(var ii=0;ii<posStore.length;ii++){
                    if(Math.abs(posStore[ii].lon-minPositionLon)<=dist){
                        minPosIndex=ii;
                        this.generalizedMinLonIndex[zoomLevel]=ii;
                        break;
                    }
                }
            }

        }
        else{
            posStore = Utilities.generalize(posStore, zoomLevel, 10, tileSize);
            this.generalized[zoomLevel] = posStore;
            dist=Utilities.pix2lon(10,sl);
            for(ii=0;ii<posStore.length;ii++){
                if(Math.abs(posStore[ii].lon-minPositionLon)<=dist){
                    minPosIndex=ii;
                    this.generalizedMinLonIndex[zoomLevel]=ii;
                    break;
                }
            }

        }

    }

    // Create one mercator pixel for each position
    var numPos = posStore.length;
    var mercPixels = [];
    for( var i = minPosIndex; i <numPos; i++){
        var pos = (posStore[i]);
        //var pY = Math.round(Utilities.lat2pix(pos.lat, sl));
        var pY = Utilities.lat2pix(pos.lat, sl);
        var pX;
        if(i>minPosIndex){
            var lonPre=posStore[i-1].lon;
            var pXPre=mercPixels[i-1].x;
            var dif=pos.lon-lonPre;
            if(dif>180) dif-=360;
            else if(dif<-180) dif+=360;
            //pX=pXPre+Math.round(Utilities.lon2pix(dif, sl));
            pX=pXPre+Utilities.lon2pix(dif, sl);

        }else{
            //pX = Math.round(Utilities.lon2pix(pos.lon, sl));
            pX = Utilities.lon2pix(pos.lon, sl);
        }
        mercPixels[i] = new PixelPoint(pX, pY);
    }
    for( i = minPosIndex-1; i >=0; i--){
        pos = (posStore[i]);
        //pY = Math.round(Utilities.lat2pix(pos.lat, sl));
        pY = Utilities.lat2pix(pos.lat, sl);
        if(i<minPosIndex){
            lonPre=posStore[i+1].lon;
            pXPre=mercPixels[i+1].x;
            dif=pos.lon-lonPre;
            if(dif>180) dif-=360;
            else if(dif<-180) dif+=360;
            //pX=pXPre+Math.round(Utilities.lon2pix(dif, sl));
            pX=pXPre+Utilities.lon2pix(dif, sl);

        }
        mercPixels[i] = new PixelPoint(pX, pY);
    }

    // Save copy for later...
    this.mercPixels[zoomLevel] = mercPixels;
    // ...and return for use
    return (this.mercPixels[zoomLevel]);
};












/**
 * @class DDSCircle is an extension of DDSShape, one that is specifically geared
 * towards displaying a circle overlay at a specific coordinate on a {@link Map}.
 * @description Construct a DDSCircle object, which extends the {@link DDSShape}.
 * @param {Position} position required The location where the circle will be
 * centered.
 * @param {Radius} radius required The extent with which to draw the circle from
 * the center point.
 * @constructor
 * @extends DDSShape
 * @see Map#addOverlay
 */
function DDSCircle(position,radius){
    
    /**
     * Unique id for this shape.
     * @private
     * @type integer
     * @default random number
     */
    this.id = Math.floor(Math.random()*10000000);
    /**
     * deCarta.js classification of this shape. Do not change.
     * @private
     * @type string
     * @default "circle"
     */
    this.type="circle";
    /**
     * Reach of the circle from the center position.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type Radius
     * @default new Radius( 100, new UOM("M") )
     */
    this.radius = radius || new Radius( 100, new UOM("M") );
    /**
     * Coordinates where the circle is located.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type Position
     */
    this.position = position;
    this.customProperties={};
}
// Extend class, first prototype, then reset the constructor
DDSCircle.prototype = new DDSShape();
DDSCircle.prototype.constructor = DDSCircle;
/**
 * Moves the center point of the circle to a new location. Assuming the shape
 * has already been added to the map: If the shape rendering is set to the
 * client side, the shape will move automatically. If the shape rendering is
 * set to the server side, the Map will need to be refreshed to move the shape.
 * @param {Position} position required The new center point location for the
 * circle.
 * @see Map#setShapeRendering
 * @see Map#reDrawMap
 */
DDSCircle.prototype.setPosition = function(position){
    
    this.position=position;
    if(this.map!=null && this.map.getShapeRendering()=="client") {
        //this.map.redraw();
        this.bbox=null;
        this.map.drawShape(this);
    }
};
/**
 * Returns the center point of the circle. To change the center point, use
 * {@link DDSCircle#setPosition}.
 * @returns {Position} The center point of the circle.
 * @see DDSCircle#setPosition
 */
DDSCircle.prototype.getPosition = function(){
    
    return this.position;
};
/**
 * Sets a new radial extent for the circle. Assuming the shape has already been
 * added to the map: If the shape rendering is set to the client side, the size
 * will change automatically. If the shape rendering is set to the server side,
 * the Map will need to be refreshed to change the size.
 * @param {Radius} radius required The new radial extent for the circle.
 * @see Map#setShapeRendering
 * @see Map#reDrawMap
 */
DDSCircle.prototype.setRadius = function(radius){
    
    this.radius=radius;
    if(this.map!=null && this.map.getShapeRendering()=="client"){
        //this.map.redraw();
        this.bbox=null;
        this.map.drawShape(this);
    }
};
/**
 * Returns the radial extent for the circle. To change the radius, see {@link
 * DDSCircle#setRadius}.
 * @returns {Radius} The radial extent for the circle.
 * @see DDSCircle#setRadius
 */
DDSCircle.prototype.getRadius = function(){
    
    return this.radius;
};
/**
 * Implements a check for a position within radius.
 * @param {Position} testPos required Test to see if a position is located
 * within the circle.
 * @returns {Boolean} true if the test point is inside the polygon, false if
 * the polygon is outside the polygon.
 */
DDSCircle.prototype.inside = function( testPos ) {
    

    var diffDistance = deCarta.Math.greatCircleDist( this.position, testPos, this.radius.uom );

    // greatCircleDist math returns raw distance, so we just compare
    if ( diffDistance < this.radius.distance ) {
        // Inside
        return true;
    }
    else {
        // Not inside
        return false;
    }
};

/**
 * function to retrieve the bounding box.
 * @returns {BoundingBox} return the boundingbox for this shape
 */
DDSCircle.prototype.getBoundingBox = function() {
    if (this.bbox){
        // return immediately
        return(this.bbox);
    }
    this.bbox=Utilities.centerContextToBoundingBox(this.position, this.radius.getDegrees()*111.111);
    return this.bbox;
};








/**
 * @class DDSLine is an extension of DDSShape, one that is specifically geared
 * towards displaying a line along a path on a {@link Map}. A DDSLine is ideally
 * suited for displaying the geometry of a {@link Route}.
 * Since the DDSLine is a 1-dimensional object, we recommend using the more general
 * methods like setOpacity, and the DDSLine specific setColor, and not using the
 * inherited Border/Stroke/Fill methods.
 * @description Construct a DDSLine object, which extends the {@link DDSShape}.
 * @param {int} width optional The pixel width of the line. This can always be
 * set later.
 * @constructor
 * @extends DDSShape
 * @see Map#addOverlay
 * @see Route
 */
function DDSLine(width){
    
    /**
     * Unique identifier for this line.
     * @private
     * @type integer
     * @default random integer
     */
    this.id = Math.floor(Math.random()*10000000);
    /**
     * deCarta.js classification of this shape. Do not change.
     * @private
     * @type string
     * @default "line"
     */
    this.type = "line";
    /**
     * Should the points be generalized?
     * @private
     * @type boolean
     * @default false
     */
    this.generalize = true;
    /**
     * Two dimensional array of generalized position.
     * First dimension represents the zoom levels for
     * which this line has been generalized for. Each zoom level will contain
     * the raw, generalized positions at this particular zoom level.
     * @private
     * @type Array
     * @default []
     */
    this.generalized = [];
    /**
     * Two dimensional array of generalized Mercator pixels.
     * First dimension represents the zoom levels for which we have created
     * Mercator pixels for this line.
     * Each zoom level level will contain the Mercator Pixel points at
     * this particular zoom level.
     * These will either be generalized or not, depending on zoom level.
     * Generating the mercator pixels is an expensive step when redrawing the
     * shapes on the map, hence we store them for later use.
     * @private
     * @type Array
     * @default []
     */
    this.mercPixels = [];
    /**
     * The positions that make up this line, ordered from start to end.
     * NOTE: Irregular values can crash DDS during server side drawing.
     * @private
     * @type Array
     * @default []
     */
    this.positions = [];
    /**
     * Pixel width of this line.
     * NOTE: Irregular values can crash DDS during server side drawing.
     * @private NOTE: Irregular values can crash DDS.
     * @type integer
     * @default 2
     */
    this.width = width || 2;
    /**
     * A VR7 representation of this line. VR7s are a deCarta and DDS specific
     * string structure for holding the values of a vector.
     * NOTE: Irregular values can crash DDS during server side drawing.
     * @private
     * @type string
     * @default ""
     */
    this.VR7 = "";
    /**
     * Determines whether or not this shape should be clipped. Clipping can
     * also be turned on globally within a Map object. Clipping is expensive,
     * and is only included to skirt an issue found in Firefox and IE browsers
     * when plotting extremely long lines.
     * @private
     * @type boolean
     * @default false
     */
    this.clip = false;

    //----------------------------------------- Overrides
    this.setFillColor("(0.0.0)");
    this.setBorderWidth("0");

    this.customProperties={};
}
// Inherit from DDSShape and then correctly reset the constructor
DDSLine.prototype = new DDSShape();
DDSLine.prototype.constructor = DDSLine;
/**
 * Set the color of this line.
 * @param {String} color required An RGB value in the format of
 * "(255.255.255)".
 * @throws {Exception} If the color is not in the right format, an
 * Exception will be thrown.
 */
DDSLine.prototype.setColor = function(color){
    
    // Override all line setings using the inherited functions
    try {
        this.setBorderColor(color);
        this.setFillColor(color);
    } catch(e) {
        throw new Exception("Error setting RGB value in DDSLine.setColor. Please use format (255.255.255)");
    }
};
/**
 * Describe the line with an array of {@link Position}. The line is drawn along
 * the array of Positions from first to last. Assuming the shape has already
 * been added to the map: If the shape rendering is set to the client side, the
 * shape will be redrawn automatically. If the shape rendering is set to the
 * server side, the Map will need to be refreshed to redraw the shape.
 * @param {Array} positions required An array of Positions describing the line.
 * @see Position
 * @see Map#setShapeRendering
 * @see Map#reDrawMap
 */
DDSLine.prototype.setPositions = function(positions){
    
    this.positions=positions;
    // Dump any stored generalizations and calculations
    this.generalized = [];
    this.mercPixels = [];
    if(this.map!=null && this.map.getShapeRendering()=="client"){
        //this.map.redraw();
        this.bbox=null;
        this.map.drawShape(this);
    }
};
/**
 * Return the array of Positions that describe the line. To set a new path for
 * the line see {@link DDSLine#setPositions}.
 * @returns {Array} An array of Positions describing the path of the line.
 * @see DDSLine#setPositions
 */
DDSLine.prototype.getPositions = function(){
    
    return this.positions;
};

DDSLine.prototype.getPosition = function(){
    
    return this.getBoundingBox().getCenterPosition();
};
/**
 * Set a new width, in pixels, for the line.
 * @param {int} width required The new pixel width for the line.
 */
DDSLine.prototype.setWidth = function(width){
    
    this.width=width;
    if(this.map!=null && this.map.getShapeRendering()=="client"){
        //this.map.redraw();
        this.bbox=null;
        this.map.drawShape(this);
    }
};
/**
 * Return the width, in pixels, for the line. To set a new pixel width see
 * {@link DDSLine#setWidth}.
 * @returns {int} The width of the line in pixels.
 * @see DDSLine#setWidth
 */
DDSLine.prototype.getWidth = function(){
    
    return this.width;
};
/**
 * Set a new VR7 to describe the path of the line. Note: VR7 is a deCarta coined
 * term. It means, "A vector made up of latitude and longitude pairs. Each point
 * along the vector has 7 decimal units of precision." The format for writing a
 * VR7 is in a comma delimited string. The first item in the list is the number
 * of latitude and longitude pairs that are found in the VR7. The second item in
 * the list is the starting latitude written in integer degrees. The third item
 * in the list is the starting longitude written in integer degrees. Each
 * following pair represents the offset from the previous pair of latitude and
 * longitude. No decimal points are used to conserve space; all degrees are
 * assumed to extend to the 7th unit beyond the decimal point. Note: Unless
 * familiar with the VR7 format, use Positions to describe the line with
 * {@link DDSLine#setPositions}.
 * @param {String} VR7 required The string describing the VR7.
 * @see DDSLine#setPositions
 */
DDSLine.prototype.setVR7 = function(VR7) {
    
    this.VR7 = VR7;
};
/**
 * Return VR7 string that describes the line. Note: Unless familiar with the VR7
 * format, use Positions to describe the line with {@link DDSLine#setPositions}.
 * @returns {String} A string, in VR7 format, describing this line.
 * @see DDSLine#setPositions
 */
DDSLine.prototype.getVR7 = function(){
    
    return this.VR7;
};
/**
 * Set whether or not the line points will be generalized according to the zoom
 * level, the default is false.
 * @param {Boolean} generalize
 */
DDSLine.prototype.setGeneralize = function(generalize){
    
    this.generalize=generalize;
};
/**
 * Get whether or not the line points will be generalized according to the
 * zoom level.
 * @return {Boolean} generalize
 */
DDSLine.prototype.getGeneralize = function(){
    
    return this.generalize;
};
/**
 * Turns on, or off, whether this individual line will be clipped.
 * @param {boolean} enabled required True this line will be clipped, false
 * this line will not be.
 * @private
 */
DDSLine.prototype.setClip = function(enabled) {
    
    this.clip = (enabled) ? true : false;
};
// Only need the following for client side rendering
/**
 * Returns the positions of the line for a particular zoom level,
 * correctly generalized if requested, as Mercator pixels.
 * Mercator pixels are stored once created for a particular zoom level.
 * @private
 * @function
 * @param {number} zoomLevel required The zoomLevel at which to return Mercator
 * pixels.
 * @param {number} tileSize required Number of pixels tall/wide of the underlying
 * map. Required to correctly generalize the line.
 * @returns {Array} Mercator Pixel (in PixelPoint objects) representation of
 * the line positions. Treat returned array as read only.
 */
// Borrow the static, abstract class function.
DDSLine.prototype.getMercPixels = DDSShape.getMercPixels;
/**
 * Return an array of arrays representing a line clipped to a given rectangle.
 * The clipping works in mercator pixels, and is assumed to be used only
 * for client side rendering as a work around to problems found in the
 * Canvas implementation on IE (a. la. bootstrapping VML) and FF.
 * Will also lazy calculate the Mercator Pixels at the particular zoom level
 * preventing a separate call to the DDSShape inherited method getMercPixels.
 * @param {number} zoomLevel required The standard zoom level at which to return mercator
 * pixels.
 * @param {number} tileSize required Tile size is used scale the image, and
 * is required by the Mercator pixel math.
 * @param {BoundingBox} bbox required Area in which to clip the segments.
 * @returns {Array} An array of arrays of Mercator Pixels represented via
 * PixelPoint. Each element in the first array dimension represents a continuous
 * section of line to be rendered within the clipped area.
 * @private
 */
DDSLine.prototype.getMercPixelsClipped = function( zoomLevel, tileSize, bbox ) {
    

    // loop counter
    var i, j;

    //---------------------------------------- Begin create lineSegments to clip
    // We must work in Mercator Pixels
    var mpix = this.getMercPixels(zoomLevel, tileSize);
    var numMpix = mpix.length;
    // Quick check for boundary conditions
    if ( numMpix < 2 ) {
        // We have a single point line, exit out now
        // points aren't really drawn, who cares if they're on the map or not
        return [mpix];
    }
    // divide our points into an array of line segments, don't overrun array bounds
    var lineSegments = [];
    var ii=0;
    for ( i = 0; i < numMpix-1; i++ ) {
        // startpoint = 0; endpoint = 1
        if(mpix[i].equals(mpix[i+1]))
            continue;
        lineSegments[ii] = [];
        lineSegments[ii][0] = mpix[i];
        lineSegments[ii][1] = mpix[i+1];
        ii++;
    }
    var numLineSegments = lineSegments.length;
    //---------------------------------------- End create lineSegments to clip


    //---------------------------------------- Begin create rectangle to clip to
    // Scaling at our level
    var sl = Utilities.radsPerPixelAtZoomLevel(tileSize, zoomLevel);
    // Break the bounding box inter mercator pixel "barriers"
    var topMpixBoundary = Math.round(Utilities.lat2pix(bbox.maxPosition.lat, sl));
    var bottomMpixBoundary = Math.round(Utilities.lat2pix(bbox.minPosition.lat, sl));
    var rightMpixBoundary = Math.round(Utilities.lon2pix(bbox.maxPosition.lon, sl));
    var leftMpixBoundary = Math.round(Utilities.lon2pix(bbox.minPosition.lon, sl));
    //----------------------------------------- End create rectangle to clip to

    //--------------------------------------- Begin outcode computation
    for ( i = 0; i < numLineSegments; i++ ) {
        genOutcode( lineSegments[i] );
    }
    //--------------------------------------- End outcode computation


    //--------------------------------------- Begin segment clipping and storing
    // We are going to store each line as a separate clipped line in our output.
    // This will generate a lot of Canvas "moveto", but this clipping routine
    // is designed as a workaround/bugfix to limitations in Canvas. Ideally
    // this code will be yanked out someday... maybe....
    var clippedSegments = [];
    // Use indexes to avoid latency of push
    var clippedIndex = 0;

    // Each segment can now be checked using the following Cohen-Sutherland rules
    var outcode = "oc";
    var outcode0 = "oc0";
    var outcode1 = "oc1";
    // Codes made local here. Copy elsewhere needed.
    var TOP = 1;
    var BOTTOM = 2;
    var RIGHT = 4;
    var LEFT = 8;
    // Because we potentially need to recheck clipped segments using this
    // method, we place loop control inside
    i = 0;
    while ( i < numLineSegments ) {
        // startpoint is index 0 and "oc0", endpoint is index 1 and "oc1"
        var segment = lineSegments[i];
        // CHECK #1:
        // We can trivially accept any segment that is fully inside the bbox
        if ( !(segment[outcode0] | segment[outcode1])){
            if (!(segment[0].equals(segment[1]))) {
                clippedSegments[clippedIndex++] = segment;
            }else{

            }
            i++; // move to next segment
            continue;
        }
        // CHECK #2:
        // We can trivially ignore any segment it does not intersect the bbox
        else if ( segment[outcode0] & segment[outcode1] ) {
            // skip this segment
            i++; // move to next segment
            continue;
        }
        // CHECK #3
        // Startpoint and endpoint of a segment potentially intersect zero,
        // one or two edges of bbox. Cannot trivially accept or reject.
        else {
            // Work on each outpoint
            for ( j = 0; j < 2; j++ ) {
                // Check one point at a time
                var oc = segment[outcode+j];
                var x, y;
                if ( !oc ) {
                    // This point is inside of the bounding box, check the next
                    continue;
                }
                // We can determine where to clip according to the outcode
                if ( oc & TOP ) {
                    // Divide line at the top of bbox
                    x = segment[0].x + (segment[1].x - segment[0].x) * (topMpixBoundary - segment[0].y) / (segment[1].y - segment[0].y);
                    y = topMpixBoundary;
                }
                else if ( oc & BOTTOM ) {
                    // Divide line at the bottom of bbox
                    x = segment[0].x + (segment[1].x - segment[0].x) * (bottomMpixBoundary - segment[0].y) / (segment[1].y - segment[0].y);
                    y = bottomMpixBoundary;
                }
                if ( oc & RIGHT ) {
                    // divide at right edge of bbox
                    x = rightMpixBoundary;
                    y = segment[0].y + (segment[1].y - segment[0].y) * (rightMpixBoundary - segment[0].x) / (segment[1].x - segment[0].x);
                }
                else if ( oc & LEFT ) {
                    // divide at right edge of bbox
                    x = leftMpixBoundary;
                    y = segment[0].y + (segment[1].y - segment[0].y) * (leftMpixBoundary - segment[0].x) / (segment[1].x - segment[0].x);
                }
                // We might get NaN or Infinity for one of the values. If we do, we
                // have a single point. Quit out as it means we've collapsed the
                // the clipping to a 1 dimensional point
                if( isNaN(x) || !isFinite(x) || isNaN(y) || !isFinite(y) ) {
                    i++;
                    break;
                }
                // Create clipped pixel point. Don't overwrite the stored mercator pixel
                var clippedPoint = new PixelPoint( x, y );
                segment[j] = clippedPoint;
            }
            // Regenerate the outcode
            genOutcode(segment);
        // Re-run this segment, don't increment
        }
    }
    //--------------------------------------- End segment clipping and storing
    return clippedSegments;

    //--------------------------------------- End functional workings


    //--------------------------------------------------- Begin Inner functions
    /**
     * Generate the outcode for a line. Outer function bounding box boundaries.
     * The temporary array object that represents the line will have a summary
     * of the outcode attached to it.
     * @param {Array} seg required Array of two PixelPoints representing the
     * Mercator pixels of a line segment.
     */
    function genOutcode( seg ) {
        // A modified Cohen-Sutherland outcode check, use dictionary key
        // for "outcode". There will be two outcodes produced, "oc0" (start point)
        // and "oc1" (endpoint).
        var outcode = "oc";
        // Codes made local here. Copy elsewhere needed.
        var TOP = 1;
        var BOTTOM = 2;
        var RIGHT = 4;
        var LEFT = 8;
        for ( var k = 0; k < 2; k++ ) {
            var segPoint = seg[k];
            // Instead of using bits, we use the integer equivalents and add...
            seg[outcode+k] = 0;
            // ... horizontal check ...
            if ( segPoint.x > rightMpixBoundary ) {
                seg[outcode+k] += RIGHT;
            }
            else if ( segPoint.x < leftMpixBoundary ) {
                seg[outcode+k] += LEFT;
            }
            // ... else Inside x boundaries equivalent to adding zeros ...
            // ... vertical check ...
            if ( segPoint.y > topMpixBoundary ) {
                seg[outcode+k] = TOP;
            }
            else if ( segPoint.y < bottomMpixBoundary ) {
                seg[outcode+k] = BOTTOM;
            }
        // ... else Inside y boundaries equivalent to adding zeros.
        }
    }
//--------------------------------------------------- End Inner functions
};
// End removal of the clipping code


DDSLine.prototype.getBoundingBox = function() {
    

    if ( this.bbox ) {
        // return immediately
        return (this.bbox);
    }
    if(this.positions.length>1) this.bbox=Utilities.positionsToBoundingBox(this.positions);
    else this.bbox=new BoundingBox(this.positions[0],this.positions[0]);
    return this.bbox;
};








/**
 * @class DDSPolygon is an extension of DDSShape, one that is specifically geared
 * towards displaying enclosed shapes on a {@link Map}. When setting the
 * boundaries of a closed shape, the final point must equal the opening point.
 * @description Construct a DDSPolygon object, which extends the {@link DDSShape}.
 * @constructor
 * @extends DDSShape
 * @see Map#addOverlay
 */
function DDSPolygon(){
    
    /**
     * Unique identifier for this shape.
     * @private
     * @type integer
     * @default random integer
     */
    this.id = Math.floor(Math.random()*10000000);
    /**
     * deCarta.js classification of this shape. Do not change.
     * @private
     * @type string
     * @default "polygon"
     */
    this.type="polygon";
    /**
     * Should the points be generalized?
     * @private
     * @type boolean
     * @default false
     */
    this.generalize = true;
    /**
     * Two dimensional array of generalized position.
     * First dimension represents the zoom levels for
     * which this line has been generalized for. Each zoom level will contain
     * the raw, generalized positions at this particular zoom level.
     * @private
     * @type Array
     * @default []
     */
    this.generalized = [];
    /**
     * Two dimensional array of generalized Mercator pixels.
     * First dimension represents the zoom levels for which we have created
     * Mercator pixels for this line.
     * Each zoom level level will contain the Mercator Pixel points at
     * this particular zoom level.
     * These will either be generalized or not, depending on zoom level.
     * Generating the mercator pixels is an expensive step when redrawing the
     * shapes on the map, hence we store them for later use.
     * @private
     * @type Array
     * @default []
     */
    this.mercPixels = [];
    /**
     * Array of positions that describe the full polygon. Polygons must be
     * closed completely, e.g. the last point in the array must be the same
     * as the first point in the array to make sure the border draws entirely.
     * Note: Irregular values can crash underlying DDS when server side
     * shapes are drawn.
     * @private
     * @type Array
     * @default []
     */
    this.positions = [];
    /**
     * A VR7 representation of this polygon. VR7s are a deCarta and DDS specific
     * string structure for holding the values of a vector.
     * NOTE: Irregular values can crash DDS during server side drawing.
     * @private
     * @type string
     * @default ""
     */
    this.VR7 = "";

    this.customProperties={};
}
// Extend and then reset the constructor
DDSPolygon.prototype = new DDSShape();
DDSPolygon.prototype.constructor = DDSPolygon;
/**
 * Set the Positions that scribe the outline of the polygon. Assuming the shape
 * has already been added to the map: If the shape rendering is set to the
 * client side, the shape will be redrawn automatically. If the shape rendering
 * is set to the server side, the Map will need to be refreshed to redraw the
 * shape.
 * @param {Array} positions required An array of Positions that form the
 * corners of the Polygon. The Polygon is assumed to close between the last
 * point and the first point of the array.
 * @see Position
 * @see Map#setShapeRendering
 * @see Map#reDrawMap
 */
DDSPolygon.prototype.setPositions = function(positions){
    
    this.positions = positions;
    // Close the polygon from here. Much simpler to enforce this here than
    // in the drawing code.
    if( !this.positions[this.positions.length-1].equals(this.positions[0]) ) {
        this.positions.push(this.positions[0].clone());
    }
    // Dump any stored generalizations and calculations
    this.generalized = [];
    this.mercPixels = [];
    if(this.map!=null && this.map.getShapeRendering()=="client"){
        //this.map.redraw();
        this.bbox=null;
        this.map.drawShape(this);
    }
};
/**
 * Return the Positions that scribe the outline of the polygon. To change the
 * shape of the polygon use {@link DDSPolygon#setPositions}.
 * @returns {Array} An array of Positions that form the corners of the Polygon.
 * The Polygon is assumed to close between the last point and the first point of
 * the array.
 * @see DDSPolygon#setPositions
 */
DDSPolygon.prototype.getPositions = function(){
    
    return this.positions;
};

DDSPolygon.prototype.getPosition = function(){
    
    return this.getBoundingBox().getCenterPosition();
};
/**
 * Set a new VR7 to describe the outline of the polygon. Note: VR7 is a deCarta
 * coined term. It means, "A vector made up of latitude and longitude pairs.
 * Each point along the vector has 7 decimal units of precision." The format
 * for writing a VR7 is in a comma delimited string. The first item in the list
 * is the number of latitude and longitude pairs that are found in the VR7. The
 * second item in the list is the starting latitude written in integer degrees.
 * The third item in the list is the starting longitude written in integer
 * degrees. Each following pair represents the offset from the previous pair of
 * latitude and longitude. No decimal points are used to conserve space; all
 * degrees are assumed to extend to the 7th unit beyond the decimal point.
 * Note: Unless familiar with the VR7 format, use Positions to describe the
 * polygon with {@link DDSPolygon#setPositions}.
 * @param {String} VR7 required The string describing the VR7.
 * @see DDSPolygon#setPositions
 */
DDSPolygon.prototype.setVR7 = function(VR7){
    
    this.VR7=VR7;
    if(this.map!=null){
        //this.map.redraw();
        this.bbox=null;
        this.map.drawShape(this);
    }
};
/**
 * Return VR7 string that describes the polygon. Note: Unless familiar with the
 * VR7 format, use Positions to describe the polygon with
 * {@link DDSPolygon#setPositions}.
 * @returns {String} A string, in VR7 format, describing this polygon.
 * @see DDSPolygon#setPositions
 */
DDSPolygon.prototype.getVR7 = function(){
    
    return this.VR7;
};
/**
 * Set whether or not the polygon points will be generalized according the the
 * zoom level, the default is false.
 * @param {Boolean} generalize required Determine whether or not this polygon
 * should be generalized to the correct zoom resolution.
 */
DDSPolygon.prototype.setGeneralize = function(generalize){
    
    this.generalize=generalize;
};
/**
 * Get whether or not the polygon points will be generalized according the the
 * zoom level.
 * @return {Boolean} Whether or not this polygon will be generazlied.
 */
DDSPolygon.prototype.getGeneralize = function(){
    
    return this.generalize;
};

/**
 * Test whether a position is inside this polyon
 * @param {Position} testPos required Test point.
 * @returns {Boolean} true if the test point is inside the polygon, false if
 * the polygon is outside the polygon.
 */
DDSPolygon.prototype.inside = function(testPos) {
    
    return deCarta.Math.pointInPolygon( this.positions, testPos );
};

// Not needed for server side drawing
/**
 * Returns the outlining positions of the polygon for a particular zoom level,
 * correctly generalized if requested, in mercator pixels. Mercator pixels are
 * stored once created for a particular zoom level.
 * @private
 * @function
 * @param {number} zoomLevel required The zoomLevel at which to return mercator
 * pixels.
 * @param {number} tileSize required Number of pixels tall/wide of the underlying
 * map. Required to correctly generalize the polygon.
 * @returns {Array} Mercator Pixel (in PixelPoint objects) representation of
 * the polygonal positions. Treat returned array as read only.
 */
// Borrow the static, abstract class function.
DDSPolygon.prototype.getMercPixels = DDSShape.getMercPixels;


DDSPolygon.prototype.getBoundingBox = function() {
    

    if ( this.bbox ) {
        // return immediately
        return (this.bbox);
    }
    if(this.positions.length>1) this.bbox=Utilities.positionsToBoundingBox(this.positions);
    else this.bbox=new BoundingBox(this.positions[0],this.positions[0]);
    return this.bbox;
};
/**
 * @fileoverview Convenience class used to calculate and then pass on page
 * Document dimensions from one object to another.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class This class allows an object to calculate it's on dimensions and then
 * pass these dimensions to another object that must perform on page positioning.
 * Passing object dimensions as a message structure cuts down on the knowledge
 * that each object must have about other objects when performing on screen
 * position adjustments. The class calculates the current dimensions for the
 * passed in DOM element, whether from CSS or from programmatic style settings.
 * @description Construct a new dimension object.
 * @param {DOM Element} el required Pass in the page element you wish to
 * calculate the dimensions of.
 * @throws {Exception} If the element does not have a style element.
 * @private
 */
deCarta.DOMDimensions = function( el ) { this.init(el); };

/**
 * The integer number of pixels of the left side of the element box on the
 * page.
 * @type number
 * @default null
 */
deCarta.DOMDimensions.prototype.left = null;
/**
 * The integer number of pixels of the top side of the element box on the
 * page.
 * @type number
 * @default null
 */
deCarta.DOMDimensions.prototype.top = null;
/**
 * The integer number of pixels of the right side of the element box on the
 * page.
 * @type number
 * @default null
 */
deCarta.DOMDimensions.prototype.right = null;
/**
 * The integer number of pixels of the bottom side of the element box on the
 * page.
 * @type number
 * @default null
 */
deCarta.DOMDimensions.prototype.bottom = null;
/**
 * The integer number of pixels of width, equivalent to clientWidth, of the
 * element.
 * @type number
 * @default null
 */
deCarta.DOMDimensions.prototype.width = null;
/**
 * The integer number of pixels of height, equivalent to clientHeight, of the
 * element.
 * @type number
 * @default null
 */
deCarta.DOMDimensions.prototype.height = null;

/**
 * Called from the constructor of DOMDimensions. See the constructor for a list
 * of the arguments accepted by init. Should only be called by the constructor.
 * Makes use of the Utilities methods getAbsoluteLeft and getAbsoluteTop.
 * @private
 */
deCarta.DOMDimensions.prototype.init = function( el ) {
    
    try {
        if ( !el || (el && !el.style) ) {
            throw new Exception( "passed in element not valid" );
        }
        this.width = parseInt( el.clientWidth, 10 );
        this.height = parseInt( el.clientHeight, 10 );
        this.left = parseInt( Utilities.getAbsoluteLeft(el), 10 );
        this.top = parseInt(  Utilities.getAbsoluteTop(el), 10 );
        // Extrapolate
        this.right = this.left + this.width;
        this.bottom = this.top + this.height;
        if( isNaN(this.width) || isNaN(this.height) || isNaN(this.left) || isNaN(this.top) || isNaN(this.right) || isNaN(this.bottom) ) {
            throw new Exception( "element does not have calculable dimensions" );
        }
    } catch(e) {
        throw new Exception( "DOMDimensions: Argument not applicable: " + e.message );
    }
};


/**
  * @fileoverview DefaultInfoWindow class
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * @class A {@link Pin} that gets attached to a {@link Map} object has a
 * default, simple div for displaying any information associated with the Pin.
 * To customize the window in which the information associated with a pin is
 * displayed in, use the DefaultInfoWindow class.
 * @description Construct a new DefaultInfoWindow object.
 * @param {Object} properties An object contains all properties, such as height, width, color,
 * autoHeight, xOffset, yOffset. If we specify autoHeight:true, then the defaultWindow will adjust height
 * automatically according to content. Otherwise, it will use fixed height and scroll bar if overflowed.
 * @constructor
 * @see Pin
 * @see Icon
 */
function DefaultInfoWindow( properties ) {
    //---------------------------------------------------------- Properties

    this.width = 255;
    this.height= 213;
    
    /**
     *if set to true, the height of the info window will be adjusted automatically.
     *else scroll bar will be used when overflow.
     */
    this.autoHeight=false;

    var _cornerHeight=24;
    var _pointerHeight=66;
    var _pointerWidth=89;



    /**
 * Horizontal (CSS left) shift used when anchoring this DefaultInfoWindow to a pin.
 * Applied to the onscreen display as (psuedo-code):
 * infowindow.style.left = -(xOffset);
 * @private
 * @type number
 * @default 0
 */
    this.xOffset = 0;
    /**
 * Vertical (CSS top) shift used when anchoring this DefaultInfoWindow to a pin.
 * Applied to the onscreen display as (psuedo-code):
 * if yOffset is set, infowindow.style.top =pin.top -(yOffset);
 * else if yOffset==undefined, the infoWindow will just be above the pin.
 * @private
 * @type number
 * @default undefined
 */
    this.yOffset = undefined;
    /**
 * Reference to the DefaultInfoWindow container DOM page element.
 * @private
 * @type DOM element (DIV)
 * @default null
 */
    this.bubble = null;
    /**
 * CSS class used by the DefaultInfoWindow container.
 * Since there is currently only one DefaultInfoWindow allowed on a map at a time,
 * this also functions as the id of the DefaultInfoWindow container.
 * @private
 * @type string
 * @default "decarta-bubble"
 */
    this.bubbleClassName = "decarta-bubble";
    /**
 * Should user generated events on the InfowWindow bubble be ignored by
 * the underlying map event handler?
 * false all events will be passed to the underlying map.
 * true events will be ignored and will not trigger underlying map events.
 * Treat this property as read only.
 * @see DefaultInfoWindow#setIgnoreMapEvents
 * @type boolean
 * @default true
 */
    this.bubbleIgnoreMapEvents = true;
    /**
 * Reference to the DefaultInfoWindow content DOM page element.
 * @private
 * @type DOM element (DIV)
 * @default null
 */
    this.bubbleContent = null;
    /**
 * CSS class used to style the content of the DefaultInfoWindow.
 * Since there is currently only one DefaultInfoWindow allowed on a map at a time,
 * this also functions as the id of the DefaultInfoWindow content.
 * @private
 * @type string
 * @default "decarta-bubbleContent"
 */
    this.bubbleContentClassName = "decarta-bubbleContent";
    /**
 * Should user generated events on the InfowWindow content be ignored by
 * the underlying map event handler?
 * false all events will be passed to the underlying map.
 * true events will be ignored and will not trigger underlying map events.
 * Treat this property as read only.
 * @see DefaultInfoWindow#setIgnoreMapEvents
 * @type boolean
 * @default true
 */
    this.bubbleContentIgnoreMapEvents = true;
    /**
 * Should the bubble content be highlightable by the mouse?
 * true means all content that makes up the bubbleContent can be highlighted
 * by the mouse.
 * false means that bubbleContent will not be selectable.
 * Treat this property as read only.
 * @type boolean
 * @default false
 */
    this.bubbleContentSelectable = false;
    /**
 * Reference to the DefaultInfoWindow container DOM page element.
 * @private
 * @type DOM element (IMG)
 * @default null
 */
    this.bubbleClose = null;
    /**
 * CSS class used to style the close button of the DefaultInfoWindow.
 * Since there is currently only one DefaultInfoWindow allowed on a map at a time,
 * this also functions as the id of the DefaultInfoWindow close button.
 * @private
 * @type string
 * @default "decarta-close"
 */
    this.bubbleCloseClassName = "decarta-close";
    /**
 * Should user generated events on the InfowWindow close button be ignored by
 * the underlying map event handler?
 * false all events will be passed to the underlying map.
 * true events will be ignored and will not trigger underlying map events.
 * Treat this property as read only.
 * @see DefaultInfoWindow#setIgnoreMapEvents
 * @type boolean
 * @default true
 */
    this.bubbleCloseIgnoreMapEvents = true;
    /**
 * The pin this DefaultInfoWindow is currently associated with when being shown.
 * @private
 * @type Pin
 * @default null
 */
    this.associatedPin = null;
    /**
 * Pointer to a handler function to be called when the DefaultInfoWindow is closed
 * via a user's click on the close button.
 * This is not the same as a callback associated with hiding the DefaultInfoWindow.
 * If a hide callback and a click callback are registered, the click callback
 * will be fired first and can be used to unhook an obsoleted hide callback.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the DefaultInfoWindow.
 * @private
 * @type function
 * @default null
 * @see DefaultInfoWindow.eventClose
 * @see 
 */
    this.onCloseCallback = null;
    /**
 * Pointer to a handler function to be called during a call to {@link DefaultInfoWindow#hide}.
 * This is not the same as a callback to the close event.
 * If a hide callback and a click callback are registered, the click callback
 * will be fired first and can be used to unhook an obsoleted hide callback.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the DefaultInfoWindow.
 * @private
 * @type function
 * @default null
 * @see DefaultInfoWindow#hide
 */
    this.onHideCallback = null;
    /**
 * Pointer to a function handler to be called during a call to {@link DefaultInfoWindow#show}.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the DefaultInfoWindow.
 * @private
 * @type function
 * @default null
 * @see DefaultInfoWindow#show
 */
    this.onShowCallback = null;
    /**
 * When we call show to display the DefaultInfoWindow, should we attempt to recenter
 * the display of the window in the center of the screen?
 * @private
 * @type boolean
 * @default false
 * @see DefaultInfoWindow#setAutoCenter
 * @see DefaultInfoWindow#autoCenter
 */
    this.shouldAutoCenter = false;

    this.bubbleCloseSrc=Credentials.infoWindowCloseButton;
    

    //---------------------------------------------------------- Methods

    /**
 * Set whether or not, when the DefaultInfoWindow gets shown, we want the map to
 * auto-center itself to place the DefaultInfoWindow in view.
 * This is turned off by default.
 * If auto centering is turned on, when {@link DefaultInfoWindow#show} is called with
 * a pin argument, the map will pan to place the pin to, as best
 * as possible, place the info bubble so that the entire bubble is viewable
 * and in a way that is as close to the center of the view as possible.
 * @param {boolean} [setting=false] true to turn the recentering over to the
 * auto-center function, false to turn it off.
 * @see DefaultInfoWindow#autoCenter
 */
    this.setAutoCenter = function(setting){
        
        setting = setting || false;
        this.shouldAutoCenter = setting;
    };

    /**
 * Register callback function for when the DefaultInfoWindow is closed via a mouse
 * click on the close button.
 * If a hide callback and a click callback are registered, the click callback
 * will be fired first and can be used to unhook an obsoleted hide callback.
 * @param {Function|null} callback Function called when the window is closed via
 * a click on the close button. Pass a null argument to unset the event handler.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the DefaultInfoWindow.
 * @see DefaultInfoWindow#setOnHide
 */
    this.setOnClose = function(callback){
        
        this.onCloseCallback = callback;
    };

    /**
 * Register callback function for when the DefaultInfoWindow is hidden via the hide
 * method.
 * If a hide callback and a click callback are registered, the click callback
 * will be fired first and can be used to unhook an obsoleted hide callback.
 * @param {Function|null} callback Function called when the window is hidden.
 * Pass a null argument to unset the event handler.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the DefaultInfoWindow.
 * @see DefaultInfoWindow#setOnClose
 * @see DefaultInfoWindow#hide
 */
    this.setOnHide = function(callback){
        
        this.onHideCallback = callback;
    };

    /**
 * Register callback function for when the DefaultInfoWindow is shown via the show
 * method.
 * @param {Function|null} callback Function called when the window is hidden.
 * Pass a null argument to unset the event handler.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the DefaultInfoWindow.
 * @see DefaultInfoWindow#show
 */
    this.setOnShow = function(callback){
        
        this.onShowCallback = callback;
    };

    /**
 * Set whether or not the different pieces of the DefaultInfoWindow will pass events
 * through to the underlying Map object.
 * @param {object} ignoreList JavaScript object containing an updated set of
 * ignore items.
 * @param {boolean} ignoreList.bubbleIgnoreMapEvents Whether user interactions
 * with the underlying DefaultInfoWindow (usually a graphic) trigger a corresponding map
 * event in that location (false) or whether the map will ignore the
 * interactions (true).
 * @param {boolean} ignoreList.bubbleContentIgnoreMapEvents Whether user interactions
 * with the content area trigger a corresponding map event in that
 * location (false) or whether the map will ignore the interactions (true).
 * @param {boolean} ignoreList.bubbleCloseIgnoreMapEvents Whether user interactions
 * with the close button trigger a corresponding map event in that
 * location (false) or whether the map will ignore the interactions (true).
 */
    this.setIgnoreMapEvents = function(ignoreList) {
        
        for ( var i in ignoreList ) {
            if ( ignoreList.hasOwnProperty(i) ) {
                // Drop property updates directly onto the object... hope dev spells well
                this[i] = ignoreList[i];
            }
        }
        // In case this is used to live update the interactivity of the window
        this.resetMapEventIgnorance();
    };

    /**
 * Set whether or not the content of the DefaultInfoWindow will be selectable.
 * Setting this will cause a live reset of selectability on the content window.
 * This is merely aesthetic in the browser, and should be used for security.
 * @param {object} isSelectable true to let the user highlight the bubble content,
 * false to restrict the highlighting.
 */
    this.setContentSelectable = function(isSelectable) {
        
        this.bubbleContentSelectable = isSelectable;
        // In case this is used to live update the interactivity of the window
        this.resetSelectability();
    };

    /**
 * Initialize the DefaultInfoWindow, supplying defaults when appropriate. Run from
 * the constructor, see it for documentation.
 * @private
 */
    this.init = function( properties ) {
        
        for(var z in properties){
            if(properties.hasOwnProperty(z)){
                this[z]=properties[z];
            }
        }
        
        //--------------------------------------------------------------
        // The container for the entire DefaultInfoWindow (bubble)
        this.bubble = document.createElement("div");
        this.bubble.id = this.bubbleClassName;
        //this.bubble.className = this.bubbleClassName;
        this.bubble.style.cssText="display:none;filter:alpha(opacity=100); opacity:1; position:absolute; z-index:10000;background-color:transparent;font-size:11px;";
        this.bubble.style.width=this.width+'px';
        //--------------------------------------------------------------
        
        //--------------------------------------------------------------


        /*var decartaBubbleTl=document.createElement('div');
        decartaBubbleTl.style.cssText="top:0px;left:0px;background-image:url(Credentials.imgPath+'info-tl.png'); margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubbleTl.style.height=_cornerHeight+'px';
        decartaBubbleTl.style.width=_cornerHeight+'px';
        this.bubble.appendChild(decartaBubbleTl);*/

        var decartaBubbleTl=document.createElement('img');
        decartaBubbleTl.src = Credentials.imgPath+'info-tl.png';
        decartaBubbleTl.style.cssText="top:0px;left:0px;margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubbleTl.style.height=_cornerHeight+'px';
        decartaBubbleTl.style.width=_cornerHeight+'px';
        this.bubble.appendChild(decartaBubbleTl);

        var decartaBubbleT=document.createElement('div');
        decartaBubbleT.style.cssText="top:0px;margin:0px;padding:0px;border-top:1px solid #ABABAB;position:absolute;background-color:white;";
        decartaBubbleT.style.left=_cornerHeight+'px';
        decartaBubbleT.style.right=_cornerHeight+'px';
        decartaBubbleT.style.height=_cornerHeight-1+'px';
        this.bubble.appendChild(decartaBubbleT);
        this.tElement = decartaBubbleT;

      /*  var decartaBubbleTr=document.createElement('div');
        decartaBubbleTr.style.cssText="top:0px;right:0px;background-image:url(Credentials.imgPath+'info-tr.png'); margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubbleTr.style.height=_cornerHeight+'px';
        decartaBubbleTr.style.width=_cornerHeight+'px';
        this.bubble.appendChild(decartaBubbleTr);*/

        var decartaBubbleTr=document.createElement('img');
        decartaBubbleTr.src = Credentials.imgPath+'info-tr.png';
        decartaBubbleTr.style.cssText="top:0px;right:0px; margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubbleTr.style.height=_cornerHeight+'px';
        decartaBubbleTr.style.width=_cornerHeight+'px';
        this.bubble.appendChild(decartaBubbleTr);

        var decartaBubbleL=document.createElement('div');
        decartaBubbleL.style.cssText="left:0px;margin:0px; padding:0px;border-left:1px solid #ABABAB;position:absolute;background-color:white;";
        decartaBubbleL.style.top=_cornerHeight+'px';
        decartaBubbleL.style.bottom=_cornerHeight+_pointerHeight+'px';
        decartaBubbleL.style.width=_cornerHeight-1+'px';
        this.bubble.appendChild(decartaBubbleL);
        this.lElement = decartaBubbleL;

        var decartaBubbleR=document.createElement('div');
        decartaBubbleR.style.cssText="right:0px;margin:0px; padding:0px;border-right:1px solid #ABABAB;position:absolute;background-color:white;";
        decartaBubbleR.style.top=_cornerHeight+'px';
        decartaBubbleR.style.bottom=_cornerHeight+_pointerHeight+'px';
        decartaBubbleR.style.width=_cornerHeight-1+'px';
        this.bubble.appendChild(decartaBubbleR);
        this.rElement = decartaBubbleR;

      /*  var decartaBubbleBl=document.createElement('div');
        decartaBubbleBl.style.cssText="left:0px;background-image:url(Credentials.imgPath+'info-bl.png'); margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubbleBl.style.bottom=_pointerHeight+'px';
        decartaBubbleBl.style.height=_cornerHeight+'px';
        decartaBubbleBl.style.width=_cornerHeight+'px';
        this.bubble.appendChild(decartaBubbleBl);*/
        var decartaBubbleBl=document.createElement('img');
        decartaBubbleBl.src = Credentials.imgPath+'info-bl.png';
        decartaBubbleBl.style.cssText="left:0px; margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubbleBl.style.bottom=_pointerHeight+'px';
        decartaBubbleBl.style.height=_cornerHeight+'px';
        decartaBubbleBl.style.width=_cornerHeight+'px';
        this.bubble.appendChild(decartaBubbleBl);

        var decartaBubbleB=document.createElement('div');
        decartaBubbleB.style.cssText="margin:0px; padding:0px;border-bottom:1px solid #ABABAB;position:absolute;background-color:white;";
        decartaBubbleB.style.bottom=_pointerHeight+'px';
        decartaBubbleB.style.left=_cornerHeight+'px';
        decartaBubbleB.style.right=_cornerHeight+'px';
        decartaBubbleB.style.height=_cornerHeight-1+'px';
        this.bubble.appendChild(decartaBubbleB);
        this.bElement = decartaBubbleB;

      /*  var decartaBubbleBr=document.createElement('div');
        decartaBubbleBr.style.cssText="right:0px;background-image:url(Credentials.imgPath+'info-br.png'); margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubbleBr.style.bottom=_pointerHeight+'px';
        decartaBubbleBr.style.height=_cornerHeight+'px';
        decartaBubbleBr.style.width=_cornerHeight+'px';
        this.bubble.appendChild(decartaBubbleBr);*/
        var decartaBubbleBr=document.createElement('img');
        decartaBubbleBr.src = Credentials.imgPath+'info-br.png';
        decartaBubbleBr.style.cssText="right:0px; margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubbleBr.style.bottom=_pointerHeight+'px';
        decartaBubbleBr.style.height=_cornerHeight+'px';
        decartaBubbleBr.style.width=_cornerHeight+'px';
        this.bubble.appendChild(decartaBubbleBr);

        /*var decartaBubblePointer=document.createElement('div');
        decartaBubblePointer.style.cssText="bottom:1px;left:0px;background-image:url(Credentials.imgPath+'info-pointer.png'); margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubblePointer.style.width=_pointerWidth+'px';
        decartaBubblePointer.style.height=_pointerHeight+'px';
        this.bubble.appendChild(decartaBubblePointer);*/
        var decartaBubblePointer=document.createElement('img');
        decartaBubblePointer.src = Credentials.imgPath+'info-pointer.png';
        decartaBubblePointer.style.cssText="bottom:1px;left:0px; margin:0px; padding:0px;position:absolute;background-color:transparent;";
        decartaBubblePointer.style.width=_pointerWidth+'px';
        decartaBubblePointer.style.height=_pointerHeight+'px';
        this.bubble.appendChild(decartaBubblePointer);

        // Content of the DefaultInfoWindow (bubble)
        this.bubbleContent = document.createElement("div");
        this.bubbleContent.id = this.bubbleContentClassName;
        this.bubbleContent.style.cssText="background-color:white;";
        this.bubbleContent.style.marginTop=_cornerHeight+'px';
        this.bubbleContent.style.marginRight=_cornerHeight+'px';
        this.bubbleContent.style.marginBottom=_cornerHeight+_pointerHeight+'px';
        this.bubbleContent.style.marginLeft=_cornerHeight+'px';
        this.bubbleContent.style.padding=0+'px';
        if(this.autoHeight){
            
        }else{
            var contentHeight=this.height-2*_cornerHeight-_pointerHeight;
            if(contentHeight>0){
                this.bubbleContent.style.height=contentHeight+'px';
                this.bubbleContent.style.overflowY="auto";
                
            }else{
                throw new Exception("height must be bigger than:"+(2*_cornerHeight+_pointerHeight));
            }
            
        }
        if(this.width<(_cornerHeight+_pointerWidth)){
            throw new Exception("width must be bigger than:"+(_cornerHeight+_pointerWidth));
        }
        // Add children elements to parent DefaultInfoWindow
        this.bubble.appendChild( this.bubbleContent );

        //--------------------------------------------------------------
        // Create default Close button for the DefaultInfoWindow if we can
        if(this.bubbleCloseSrc){
            this.bubbleClose = document.createElement("img");
            this.bubbleClose.src=this.bubbleCloseSrc;
            this.bubbleClose.id = this.bubbleCloseClassName;
            this.bubbleClose.owner = this;
            this.bubbleClose.style.cssText="position:absolute; width:13px; height:13px; top:8px; right:8px; cursor:pointer;";
            deCarta.Events.addEvent( this.bubbleClose, "click", DefaultInfoWindow.eventClose );
            this.bubble.appendChild( this.bubbleClose );
        }
        

        // FixPNG for ie6
    /*    if ( Utilities.ie6 ) {
            // Everything should be appended to the bubble
            var images = this.bubble.getElementsByTagName('img');
            for (var i = 0; i < images.length; i ++ ) {
                //if ( images[i].src.match(/\bpng\b/g) ) {
                if ( images[i].src.match(/.png/ig) ) {
                    Utilities.fixPng(images[i]);
                }
            }
        }
*/
        //this.ie6sizeTLRB();
    };

    /**
 * Initializes the basic DefaultInfoWindow DOM elements.
 * @private
 */
    this.build = function() {
        
        try {
            //--------------------------------------------------------------
            // The container for the entire DefaultInfoWindow (bubble)
            this.bubble = document.createElement("div");
            this.bubble.id = this.bubbleClassName;
            this.bubble.className = this.bubbleClassName;
            //--------------------------------------------------------------
            // Content of the DefaultInfoWindow (bubble)
            this.bubbleContent = document.createElement("div");
            this.bubbleContent.id = this.bubbleContentClassName;
            this.bubbleContent.className = this.bubbleContentClassName;
            //--------------------------------------------------------------
            // Create default Close button for the DefaultInfoWindow if we can
            if ( Credentials.infoWindowCloseButton ) {
                this.buildCloseIcon(Credentials.infoWindowCloseButton);
            }
            //--------------------------------------------------------------
            // Add children elements to parent DefaultInfoWindow
            this.bubble.appendChild( this.bubbleContent );
        } catch (e) {
            throw new Exception("build error:"+e.message);
        }
    };

    /**
 * Builds the default structure for the close icon.
 * Separation of this method allows the close icon to be ignore should
 * users not wish the icon to be built by default.
 * The bubble must be built before calling this function; this function will
 * automatically append the close icon to the DefaultInfoWindow 'bubble.'
 * @param {string} [src] Sets the icon source. If argument is not passed in, an
 * image object is created without a src.
 */
    this.buildCloseIcon = function(src) {
        this.bubbleClose = document.createElement("img");
        if ( src ) {
            this.bubbleClose.src = src;
        }
        this.bubbleClose.id = this.bubbleCloseClassName;
        this.bubbleClose.className = this.bubbleCloseClassName;
        this.bubbleClose.owner = this;
        deCarta.Events.addEvent( this.bubbleClose, "click", DefaultInfoWindow.eventClose );
        this.bubble.appendChild( this.bubbleClose );
    };

    /**
 * Position (top and left) the DefaultInfoWindow relative to screen coordinates,
 * anchoring according to the offsets.
 * @param {number} left optional Absolute left screen coordinate to position
 * this DefaultInfoWindow. Defaults to 0. yOffset will be applied to positioning.
 * @param {number} top optional Absolute top screen coordinate to position
 * this DefaultInfoWindow. Defaults to 0. xOffset will be applied to positioning.
 */
    this.setPosition = function( left, top ) {
        
        top = top || 0;
        left = left || 0;
        if(this.yOffset!=undefined){
            this.bubble.style.top = top - this.yOffset + "px";
        }else{
            if(this.autoHeight){
                this.bubble.style.top = top+"px";
            }else{
                this.bubble.style.top = top - this.height+1 + "px";
            }
        }
        this.bubble.style.left = left - this.xOffset + "px";
    };

    /**
 * Updates the content to be displayed within this DefaultInfoWindow.
 * @param {HTML} content optional Sets new content for this DefaultInfoWindow. Falsey
 * values will empty the contents of the DefaultInfoWindow.
 */
    this.setContent = function( content ) {
        
        this.bubbleContent.innerHTML = "";
        content=content || "&nbsp;";
        
        if ( content.style ) {
            this.bubbleContent.appendChild(content)
        } else {
            this.bubbleContent.innerHTML = content;
        }
        // Always reset the stack
        this.resetSelectability();
        this.resetMapEventIgnorance();
    };

    /**
 * Walk through all bubbleContent of the DefaultInfoWindow and appropriately set the
 * selectability.
 * @private
 */
    this.resetSelectability = function() {
        // Because this must be called live, we need to be able to turn on or off
        // the selectability of the content elements
        var func = (this.bubbleContentSelectable) ? Utilities.setSelectable : Utilities.setUnselectable;
        var bubContent = this.bubbleContent;
        // outer...
        func(bubContent);
        // ...inner
        if ( bubContent.hasChildNodes() ) {
            var elems = bubContent.getElementsByTagName('*');
            for ( var j = 0; j < elems.length; j++ ) {
                func(elems[j]);
            }
        }
    };

    /**
 * Walk through the HTML DOM pieces of the DefaultInfoWindow and, if necessary, mark
 * events that originated by these elements to be ignored by the map object.
 * @private
 */
    this.resetMapEventIgnorance = function() {
        var i, j, n, nodes, elems; // counters and collections
        if ( this.bubbleIgnoreMapEvents ) {
            // The bubble, but not anything else
            deCarta.IdManager.setTag(this.bubble, "ignoreForMapEvents" );
            if ( this.bubble.hasChildNodes() ) {
                // We only want the non-content, non-closebutton nodes
                nodes = this.bubble.childNodes;
                for ( i = 0; i < nodes.length; i++ ) {
                    n = nodes[i];
                    // Rely on the the classname and id to be the same for our DefaultInfoWindow
                    if ( n.id != this.bubbleContentClassName && n.id != this.bubbleCloseClassName ) {
                        elems = n.getElementsByTagName('*');
                        for ( j = 0; j < elems.length; j++ ) {
                            deCarta.IdManager.setTag(elems[j], "ignoreForMapEvents" );
                        }
                    }
                // continue
                }
            }
        }
        if ( this.bubbleContentIgnoreMapEvents ) {
            // The content to display
            deCarta.IdManager.setTag(this.bubbleContent, "ignoreForMapEvents" );
            elems = this.bubbleContent.getElementsByTagName('*');
            for ( i = 0; i < elems.length; i++ ) {
                deCarta.IdManager.setTag(elems[i], "ignoreForMapEvents" );
            }
        }
        if ( this.bubbleCloseIgnoreMapEvents && this.bubbleClose ) {
            // close button
            deCarta.IdManager.setTag(this.bubbleClose, "ignoreForMapEvents" );
        }
    };

    /**
 * Displays the DefaultInfoWindow. InfoWindows can be tied to pins.
 * @param {string} pin optional Ties this DefaultInfoWindow to a particular pin.
 */
    this.show = function( pin ) {
        
        // Until we build out the infowindow, the problem with this is that
        // many pins on a map can end up overlapping the DefaultInfoWindow once popped
        // and if the pins are refreshed. This prevents the DefaultInfoWindow from being
        // layered over with pins.
        this.bubble.style.zIndex = Pin.zIndexCounter + 10000;
        this.bubbleContent.style.zIndex = Pin.zIndexCounter + 10000;
        if ( this.bubbleClose ) {
            this.bubbleClose.style.zIndex = Pin.zIndexCounter + 10000;
        }
        this.bubble.style.display = "block";
        //we should calculate the css style top here if it's autoHeight
        if(this.autoHeight && this.yOffset==undefined){
            var height=this.bubble.offsetHeight;
            var top=parseInt(this.bubble.style.top);
            this.bubble.style.top=top-height-1+'px';
        }


        if ( pin ) {
            this.associatedPin = pin;
        } else {
            // This should really be improved, but this at least backwards compatible
            this.associatedPin = null;
        }
        // Show callback happens after the visual display
        if (this.onShowCallback) {
            this.onShowCallback();
        }
        // autoCenter has an internal check for whether or not it should fire
        
        this.autoCenter();

        this.ie6sizeTLRB();
        this.ie6FixPng()
    };

    /**
 * Hide the DefaultInfoWindow from view.
 * If an onCloseCallback function is registered with this DefaultInfoWindow, that
 * function will also be called.
 */
    this.hide = function() {
        
        this.bubble.style.display = "none";
        // Hide callback happens after the visual hiding
        if (this.onHideCallback) {
            this.onHideCallback();
        }
    };

    /**
 * If the DefaultInfoWindow is associated with a pin, this function will attempt to
 * fit the DefaultInfoWindow within view, and appropriately centered.
 * An DefaultInfoWindow that is too large will, obviously, fail to be fit correctly.
 * This function will fail silently if it is not associated with a pin via
 * {@link DefaultInfoWindow#show}, and is automatically called at the end of that
 * function.
 * Should a more creative solution be needed, this function could be overridden
 * on a particular instance, or an onShow callback could be added to the
 * DefaultInfoWindow that handles the recentering.
 * @see DefaultInfoWindow#show
 * @see DefaultInfoWindow#setAutoCenter
 * @see DefaultInfoWindow#show
 */
    this.autoCenter = function() {
        var pin = this.associatedPin;
        if ( !(pin && pin.map) || !this.shouldAutoCenter ) {
            // exit quickly
            return;
        }
        var map = pin.map;
        // This will only work after the DefaultInfoWindow is visible on the page
        // Get the mercator bounding box of the pin
        var pinHeight = pin.pinImg.clientHeight;
        var pinWidth = pin.pinImg.clientWidth;
        var pinTop = parseInt(pin.pinImg.style.top);
        var pinLeft = parseInt(pin.pinImg.style.left);
        var scale =  Utilities.radsPerPixelAtZoomLevel(map.getTileSize(), map.getZoomController().selected);
        var pinBox = pin.getViewableBoundingBox(scale);
        var pinTopLeftPos = pinBox.getUpperLeftPosition();
        var pinTopLeftMPix = map.posToMercPix(pinTopLeftPos);
        var pinLowerRightMPix = new PixelPoint(pinTopLeftMPix.x+pinWidth, pinTopLeftMPix.y-pinHeight );
        // Get the mercator bounding box of the DefaultInfoWindow
        var iwHeight = this.bubble.clientHeight;
        var iwWidth = this.bubble.clientWidth;
        var iwTop = parseInt(this.bubble.style.top);
        var iwLeft = parseInt(this.bubble.style.left);
        var iwTopMPix = pinTopLeftMPix.y + (pinTop - iwTop);
        var iwLeftMPix = pinTopLeftMPix.x - (pinLeft - iwLeft);
        var iwTopLeftMPix = new PixelPoint(iwLeftMPix, iwTopMPix);
        var iwLowerRightMPix = new PixelPoint(iwLeftMPix+iwWidth, iwTopMPix-iwHeight);


        var iwLowerLeftMPix = new PixelPoint(iwLeftMPix, iwTopMPix-iwHeight);
        var iwTopRightMPix = new PixelPoint(iwLeftMPix+iwWidth, iwTopMPix);
        var minPos = map.mercPixToPos(iwLowerLeftMPix);
        var maxPos=map.mercPixToPos(iwTopRightMPix);


        //    // Find the encompassing max and min of a bounding box containing
        //    // Pin and DefaultInfoWindow, assuming our pin and DefaultInfoWindow might be in wonky
        //    // positions
        //    var maxMercLat = Math.max(pinTopLeftMPix.y, iwTopLeftMPix.y);
        //    var minMercLat = Math.min(pinLowerRightMPix.y, iwLowerRightMPix.y);
        //    // Maximum longitude is generated in reverse: from the lower right
        //    var maxMercLon = Math.max(pinLowerRightMPix.x, iwLowerRightMPix.x);
        //    var minMercLon = Math.min(pinTopLeftMPix.x, iwTopLeftMPix.x);
        //    // Build the bounding box
        //    var maxMPix = new PixelPoint (maxMercLon, minMercLat);
        //    var minMPix = new PixelPoint (minMercLon, maxMercLat);
        //    var maxPos = map.mercPixToPos(maxMPix);
        //    var minPos = map.mercPixToPos(minMPix);
        var pinPlusInfoWindowBBox = new BoundingBox(minPos, maxPos);
        var reCenter = pinPlusInfoWindowBBox.getCenterPosition();
        map.panToPosition(reCenter);
    };

    this.init( properties );


    /**
     * Sets the size of the Top, Left, Right and Bottom elements so they work in ie6
     */

    this.ie6sizeTLRB = function(){
        if (!Utilities.ie6) return;

        var w = document.getElementById(this.bubbleClassName).clientWidth - (_cornerHeight * 2);
        var h = document.getElementById(this.bubbleClassName).clientHeight - _cornerHeight - _pointerHeight;

        this.bElement.style.width = w + 'px';
        this.tElement.style.width = w + 'px';
        this.lElement.style.height = h + 'px';
        this.rElement.style.height = h + 'px';

        return;
    }


    this.ie6FixPng = function(){
        if ( Utilities.ie6 ) {
            // Everything should be appended to the bubble
            var images = this.bubble.getElementsByTagName('img');
            for (var i = 0; i < images.length; i ++ ) {
                //if ( images[i].src.match(/\bpng\b/g) ) {
                if ( images[i].src.match(/.png/ig) ) {
                    Utilities.fixPng(images[i]);
                }
            }
        }
    }


//----------------------------------------------------------- Event handlers

/**
 * Handles the close action on a click on the DefaultInfoWindow.
 * Expects the DefaultInfoWindow display to have a backpointer called owner to the
 * DefaultInfoWindow object.
 */
    

}

DefaultInfoWindow.eventClose = function() {
    // onCloseCallback happens before the window is visually hidden
    var owner = this.owner;
    if (owner.onCloseCallback) {
        owner.onCloseCallback();
    }
    owner.hide();
};



 /** 
  * @fileoverview EventRegistry handles the assignment of event listeners.
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * EventRegistry is constructed on load of the deCarta.js library.
 * @class The EventRegistry is a deCarta JavaScript API specific event queue. 
 * It is designed specifically to capture click, drag, and other events 
 * associated with {@link Map} and {@link Pin} objects. The EventRegistry 
 * itself is a static singleton constructed on load of the deCarta.js library.
 * @constructor
 */
function EventRegistry() {}

/** 
 * Associate an event with an deCarta Map or Pin object and a callBack function.
 * <p>Example:</p>
 * <code>EventRegistry.addListener(map,"moveend", yourMoveEndCallBackFunction);</code>
 * <p>The possible combinations are</p>
 * <p>Events available on Map instances:</p>
 * <ul>
 * <li>rightclick -- returns Position instance representing the latitude / 
 * longitude of position clicked to the callBack function</li>
 * <li>dblclick -- returns Position instance representing the latitude / 
 * longitude of position clicked to the callBack function</li>
 * <li>click -- returns Position instance representing the latitude / longitude 
 * of position clicked to the callBack function</li>
 * <li>mousedown -- returns Position of mouse to the callBack function</li>
 * <li>mouseout -- mouse leaves the main Map div</li>
 * <li>mouseup -- returns Position of mouse to the callBack function</li>
 * <li>move -- returns Position of mouse to the callBack function</li>
 * <li>movestart -- returns void to the callBack function</li>
 * <li>moveend -- returns void to the callBack function</li>
 * <li>zoomend -- returns void to the callBack function</li>
 * </ul>
 * <p>Events available on Pin instances:</p>
 * <ul>
 * <li>rightclick -- returns Pin instance to callBack function</li>
 * <li>dblclick -- returns Pin instance to callBack function</li>
 * <li>click -- returns Pin instance to callBack function</li>
 * <li>mousedown -- returns Pin instance to callBack function</li>
 * <li>mouseover -- returns Pin instance to callBack function</li>
 * <li>mouseout -- returns Pin instance to callBack function</li>
 * <li>mouseup -- returns Pin instance to callBack function</li>
 * </ul>
 * @param {Object} source required Pin or Map object.
 * @param {String} event required Valid Event type for the passed in source.
 * @param {Function} callBack required Function that will be executed each time 
 * this event gets triggered. Certain events will return objects that can be 
 * used by the passed in callback function.
 * @throws {@link Exception} If the source and event arguments are not 
 * compatible, will notify about the "unsupported event type."
 */
EventRegistry.addListener = function( source, event, callBack ) {
    // Problems converting functions to string
    
	if(source.type=="map" && (
                event == "rightclick" ||
                event == "dblclick"  || 
                event == "click"     ||
                event == "mousedown" ||
                event == "mouseout"  ||
                event == "mouseup"   ||
                event == "move"      ||
                event == "movestart" ||
                event == "moveend"   ||
                event == "zoomend")) {
		source.addEventListener(event, callBack);
	}
    else if(source.type=="pin" && (
                event=="rightclick" ||
                event == "dblclick"  ||
                event == "click"     ||
                event == "mousedown" ||
                event == "mouseover" || 
                event == "mouseout"  ||
                event == "mouseup")) {
		source.addEventListener(event, callBack);
	}
    else {
		throw new Exception(event + " is unsupported event type for " + source.type);
	}	
};



/**
 * Remove all event types for a particular object.
 * @param {Object} source The object to remove events from.
 * @param {String} event The event type to clear from the passed in source 
 * object.
 */
EventRegistry.clearListeners = function(source,  event){
    
	source.clearListeners(event);
};



/**
 * Remove all events for a particular object.
 * @param {Object} source The object to remove events from.
 */
EventRegistry.clearInstanceListeners = function(source){
    
	source.clearInstanceListeners();
};






/**
 * @fileoverview Additional event functions to ease implementation
 * of cross-browser DOM event handling.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @namespace DOM Events in JavaScript are hard, and this collection of functions
 * helps to simplify their effective use.
 * @description deCarta specific DOM event functions.
 * @private
 */
deCarta.Events = {};

/**
 * Add an event handler to a DOM element. This function uses the best method
 * available to attach a function to an element depending on browser. All
 * registered event functions will be passed the event object as the first, and
 * only, parameter. On most modern browsers, multiple and different functions can
 * be registered to the same event type.
 * This is an expansion of John Resig's addEvent function found
 * <a href="http://ejohn.org/projects/flexible-javascript-events/">here</a>.
 * @param {DOM Object} obj required The page element we wish to attach the
 * event to.
 * @param {string} type required The base name of the event. For example,
 * pass in "click" for single click events, "onclick" would be incorrect.
 * A list of event names can be found
 * <a href="http://www.quirksmode.org/dom/events/index.html">here</a>.
 * There is no validity checking on the name of the event.
 * @param {function} fn required The event handling function to attach to this
 * event. Irrespective of browser type, all functions will be passed the event
 * object as the parameter. Function is still responsible for dealing with
 * event object property browser inconsistencies.
 * @static
 */
deCarta.Events.addEvent = function( obj, type, fn ) {
    
    // For all events on all browsers, id our page elements so we can easily
    // determine using srcElement/target if our object should be handling
    // the event. This should allow us always pass events and avoid capturing
    // when we really don't need to.
    // We add this once and don't remove it, assuming if the element needs
    // to be purged (IE) that a purge function will be called.
    var eventKey = deCarta.Events.eventKey;
    if ( !deCarta.IdManager.checkTag(obj, eventKey) ) {
        deCarta.IdManager.setTag( obj, eventKey, deCarta.IdManager.getUniqueId() );
    }

    if ( obj.attachEvent ) {
        // IE event registration
        // Don't reregister the same event
        if ( obj['e'+type+fn] ) {
            return;
        }
        obj['e'+type+fn] = fn;
        obj[type+fn] = function(){
            obj['e'+type+fn]( window.event );
        };
        obj.attachEvent( 'on'+type, obj[type+fn] );
    }
    else if (obj.addEventListener) {
        // Basically all other modern browser event registry
        obj.addEventListener( type, fn, false );
    }
    else {
        // old style method of adding that overwrites any function already
        // added as a listener to this event.
        // Make sure your code doesn't require multiple functions to be registered
        // at the same time.
        obj['on'+type] = fn;
    }
};

/**
 * Remove an event handler from a DOM element. This function uses the best method
 * available to remove a function from an element depending on browser.
 * This is an expansion of John Resig's addEvent function found
 * <a href="http://ejohn.org/projects/flexible-javascript-events/">here</a>.
 * @param {DOM Object} obj required The page element we wish to remove the
 * event from.
 * @param {string} type required The base name of the event. For example,
 * pass in "click" for single click events, "onclick" would be incorrect.
 * A list of event names can be found
 * <a href="http://www.quirksmode.org/dom/events/index.html">here</a>.
 * There is no validity checking on the name of the event.
 * @param {function} fn required The event handling function to remove from this
 * event.
 * @static
 */
deCarta.Events.removeEvent = function( obj, type, fn ) {
    
    if ( obj.detachEvent ) {
        // IE event removal
        if ( obj[type+fn] ) {
            obj.detachEvent( 'on'+type, obj[type+fn] );
            obj['e'+type+fn] = null;
            obj[type+fn] = null;
        }
    }
    else if ( obj.removeEventListener ) {
        // Basically all other modern browser event removal
        obj.removeEventListener( type, fn, false );
    }
    else {
        // Old style method of removal.
        obj['on'+type] = undefined;
    }
};

/**
 * If an event was registered on an object through these event functions,
 * this function will signal whether an object is the originator of an
 * event or not.
 * @param {DOM Object} obj required The page element we wish to check for
 * event origination.
 * @param {Event object} e required The event object to check against.
 * @returns {boolean} true if the object originated the event, false if not.
 */
deCarta.Events.checkIfTarget = function( obj, e ) {
    
    var eventId = deCarta.Events.eventKey;
    if( obj && obj[eventId] ) {
        if ( e && (e.target || e.srcElement) ) {
            var targetEl = e.target || e.srcElement;
            if ( targetEl[eventId] == obj[eventId] ) {
                return true;
            }
        }
    }
    return false;
};

/**
 * String used to key our object unique event id. Hopefully this unique.
 * @type string
 * @default "deCartaEvent"
 * @static
 */
deCarta.Events.eventKey = "deCartaEventId";



/** 
 * @fileoverview deCarta Exception class.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
  
// Begin Exception definition block
//
(function() {



if( Error ) {
    // Redirect Exception to the basic Error object if it exists
    Exception = Error;
}
else {
    /**
     * @class The Exception class is used within the deCarta.js library to help
     * catch errors, instantiation problems, and incorrect use of functions.
     * In all modern browsers it is a pass through to the JavaScript Error class.
     * @description Construct a new Exception object.
     * @param {String} message The message to be thrown in event of an error.
     * @constructor
     */
    Exception = function(message){
        
        /**
         * The description of the exception.
         * @type String
         */
        this.message = message || "an exception has occurred";
        var self = this;
        /**
         * Convert the Exception object to a string.
         * @return {string} Exception message returned as a string.
         */
        this.toString = function(){
            return self.message;
        };
    }
}


})();
//
// End Exception Definition block

 /** 
  * @fileoverview Represent an address as a single line string.
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * @class The FreeFormAddress class mainly provides a simplified interface to 
 * the {@link Geocoder}. It allows an address to be taken from user input as 
 * is. The DDS Web Services will perform the parsing and, obviously, the 
 * geocoding, freeing the client side application from the task of parsing user 
 * input.
 * @description Construct a new FreeFormAddress object.
 * @param {String} address required The address, represented as a single, space 
 * and comma delimited string.
 * @param {Locale} locale optional What parsing rules should be used to improve 
 * the address match rate. Default is equivalent to a Locale of "en" (English) 
 * language and "US" (United States) country parsing.
 * @throws {@link Exception} If the address is undefined or null string, will 
 * notify with an "invalid parameters" Exception message.
 * @see Locale
 * @see Geocoder#geocode
 * @constructor
 */
function FreeFormAddress( address, locale ) {
    
    if( !address || address.toString() == "" ) {
         throw new Exception("Error instantiating FreeFormAddress, invalid parameters.");
         return false;
     }
    /**
     * Parsing rules to be used with this FreeFormAddress object.
     * @type Locale 
     */
    this.locale = locale || new Locale("en","US");
    /** 
     * The address as a freeform, single string.
     * @type String 
     */
    this.address = address;
    /**
     * Designation that this is a freeform address.
     * @type string
     * @default "FreeForm"
     * @private
     */
    this.type = "FreeForm";
}

/**
 * Return the Locale associated with this address.
 * @return {Locale} locale field of the FreeFormAddress object.
 * @deprecated access through object property
 * @private
 */
FreeFormAddress.prototype.getLocale = function() {
    
    return this.locale;    
};

/**
 * Return the address object as a string. Only the address field is 
 * returned. Use getLocale to access the Locale associated with this 
 * FreeFormAddress.
 * @return {string} the FreeFormAddress object as string.
 */
FreeFormAddress.prototype.toString = function() {
    return this.address;
};

 /** 
  * @fileoverview GeocodedAddress
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * @class The GeocodedAddress class encapsulates results, and is returned, 
 * from a successful geocode request. Any matched geocodes will have an 
 * associated {@link Position} and an equivalent {@link FreeFormAddress} to 
 * describe the location. Additional support is provided for estimating the 
 * area of a Geocoded request if the best match found is an area and not a 
 * specific coordinate.
 * @description Construct a new GeocodedAddress object.
 * @see BoundingBox
 * @see Geocoder#geocode
 * @constructor
 */
function GeocodedAddress() {
     
     /**
      * The estimated location for this address.
      * @type Position
      * @default null
      */
     this.position = null;
     /**
      * The geocoded addresses in a single line, or freeform, structure.
      * These addresses are generated from the information found in the map
      * data. Even on an exact match, the address returned from the data might
      * be slightly different than the address used in the geocode request.
      * @type FreeFormAddress
      * @default null
      */
     this.freeFormAddress = null;
     /**
      * The geocoded addresses in a structured format.
      * These addresses are generated from the information found in the map
      * data. Even on an exact match, the address returned from the data might
      * be slightly different than the address used in the geocode request.
      * @type Address
      * @default null
      */
     this.structuredAddress = null;
     /**
      * Either null if the Geocode is an exact position, or a BoundingBox 
      * instance if the geocode represents an area, for instance Oakland CA. 
      * This is useful for setting the appropriate zoom level.
      * @type BoundingBox
      * @default null
      */
     this.boundingBox = null;
     /** 
      * Description of the geocoding method used to create this match. This can 
      * be used to determine how reliable the results are.
      * @type String
      * @default ""
      */
     this.matchType = "";
 }
 /**
  * Concatenates the position, the freeFormaddress, boundingBox, and matchType 
  * fields, in that order and returns that string.
  * @return {String} the GeocodedAddress object as a single, comma and newline 
  * delimited string.
  */
 GeocodedAddress.prototype.toString = function() {
     return this.position+"\n"+this.freeFormAddress+"\n"+this.boundingBox+"\n"+this.matchType;
 };


/**
 * @fileoverview Geocoder
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class The Geocoder object has two specific functions. It is used to perform 
 * geocoding, the translation of an address into a latitude and longitude 
 * coordinate, and to perform reverse geocoding, the translation of a latitude 
 * and longitude coordinate into an approximate address. While the {@link Map} 
 * object can perform rudimentary geocoding in some of its methods, the Geocoder 
 * class can be used to more gracefully deal with the results of poor, or 
 * inexact, user input. Geocoder objects operate independently from Map 
 * objects, allowing web applications to utilize just geocoding or reverse 
 * geocoding functionality, should that be required.
 * @description Construct a new Geocoder object.
 * @see FreeFormAddress
 * @see Address
 * @see GeocodedAddress
 * @constructor
 */
function Geocoder() {
    
    
    /*
     * Used to generate the XML strings for making Geocoding requests to
     * the DDS Web Services.
     * @private
     * @type XMLStringBuilder
     */
    this.xmlRecFac = new deCarta.XMLStringBuilder();
    /**
     * Switch between returning address matches as free form or structured.
     * By default, this is set to true: address matches will be returned as
     * free form strings.
     * @see FreeFormAddress
     * @see Address
     * @type boolean
     * @default true
     */
    this.returnFreeForm = true;
    /**
     * Holding tank for geocoding response handling.
     * @private
     * @type Array
     * @default []
     */
    var _callBackArray = [];
    /**
     * Self reference to avoid potential JavaScript private function and event
     * handling mis-references of this.
     * @private
     */
    var self = this;
		
		/**
		 * reference to populate response since it is not coming back from server
     * @ignore
     */
     this.locale;
		
    /**
     * Authenticate the Geocoder. If you have already authenticated another 
     * object, or have manually set the authentication fields of the Credentials 
     * object, you do not have to use this function.
     * @param {String} clientName required Set with the clientName 
     * authentication token.
     * @param {String} clientPassword required Set with the clientPassword 
     * authentication token.
     * @throws {@link Exception} "Error authenticating Geocoder, invalid 
     * parameters."
     * @see Credentials
     */
    this.authenticate = function( clientName, clientPassword ) {
        
        if(!clientName || !clientPassword || clientName=="" || clientPassword==""){
            throw new Exception("Error authenticating Geocoder, invalid parameters.");
            return false;
        }
        Credentials.clientName = clientName;
        Credentials.clientPassword = clientPassword;
        this.xmlRecFac.clientName = clientName;
        this.xmlRecFac.clientPassword = clientPassword;
    };

    /**
     * Set the configuration to be used with this object.
     * @param {String} configuration required
     */
    this.setConfiguration = function(configuration) {
        
        if(!configuration){
                throw new Exception("error calling Geocoder.setConfiguration()");
        }
        Credentials.configuration = configuration;
        this.xmlRecFac.configuration = configuration;
    };
		
    /** 
     * Translate an address into a list of Positions (latitude and longitude 
     * coordinates). Since user input may often be incomplete, it is important 
     * to be able to accept the multiple matches that can be returned from a 
     * geocode request. Geocoding is an asynchronous request made to the DDS 
     * Web Services, and thus requires a callBack function to catch the returned
     * results. The application should provide a callBack function that has the
     * following prototype:<br>
     * <p><code>function geocodeCallBack(arrayPositions, arrayAddresses, geocodedAddressArray)</code></p>
     * <p>where</p>
     * <ul>
     * <li>geocodeCallBack = Arbitrary function name</li>
     * <li>arrayPositions = An array of Position objects, or null if there was a geocoding error.</li>
     * <li>arrayAddresses = An array of Address or FreeFormAddress objects</li>
     * <li>geocodedAddessArray = An array of GeocodedAddress object</li>
     * </ul>
     * <p>The array of Positions and the array of FreeFormAddress (or Address) objects are
     * paired one to one, and are ordered in priority. The array of
     * GeocodedAddress objects encapsulates the array of Positions and
     * FreeFormAddresses (or Address) objects, and includes additional information about the geocode.
     * </p>
     * <p>A failed geocode will return empty arrays.</p>
     * @param {FreeFormAddress} address The address to be translated 
     * into a coordinate.
     * @param {function} callBack Function to catch and handle the 
     * results of a geocode.
     * @param {function} [timeoutCallback] Function to be called in case this
     * particular query times out.
     * @throws {Exception} If a function is not passed in as a callBack.
     * @see GeocodedAddress
     * @see FreeFormAddress
     * @see Position
     */
    this.geocode = function(address, callBack, timeoutCallback, referencePoint) {
        
        var reqId = Utilities.getRequestId();
        this.locale=address.locale;
        if ( typeof callBack == 'function' ) {
            _callBackArray[reqId] = callBack;
        } else {
            throw new Exception("Geocode.geocode: callBack must be a function, arg was: " + callBack );
        }
        var xml = this.xmlRecFac.createGeocodeRequest(address, reqId, this.returnFreeForm, referencePoint);
        JSRequest.send(xml, self.geocodeCallback, null, timeoutCallback);
        
    };

    /**
     * Translate a Position (latitude, longitude coordinate) into an Address. 
     * Reverse geocodes are always approximated to the best possible address 
     * within the range of addresses available in the map data. Reverse 
     * geocoding is an asynchronous request made to the DDS Web Services, and 
     * thus requires a callBack function to catch the returned results. The 
     * application should provide a callBack function that has the following 
     * prototype:<br>
     * <p><code>function reverseGeocodeCallBack(address)</code></p>
     * <p>where</p>
     * <ul>
     * <li>reverseGeocodeCallBack = Arbitrary function name</li>
     * <li>address = An Address object</li>
     * </ul>
     * <p>If a valid reverse geocode can be made, it will be passed to the 
     * callBack in an Address object.</p>
     * <p>A failed reverse geocode will return an empty Address 
     * (address.toString() == "").
     * @param {Position} position The location to reverse geocode.
     * @param {function} callBack Function to catch and handle the 
     * results of a reverse geocode.
     * @param {function} [timeoutCallback] Function to be called in case this
     * particular query times out.
     * @throws {Exception} If a function is not passed in as a callBack.
     * @see Address
     * @see Position
     */
    this.reverseGeocode = function(position, callBack, timeoutCallback){
        
        var reqId = Utilities.getRequestId();
        if ( typeof callBack == 'function' ) {
            _callBackArray[reqId] = callBack;
        } else {
            throw new Exception("Geocode.reverseGeocode: callBack must be a function, arg was: " + callBack );
        }
        //(pos, tileSize, requestId, referenceZoomLevel, newZoomLevel, trafficTime, sessionId)
        var xml = this.xmlRecFac.createReverseGeocodeRequest( position, reqId );
        
        JSRequest.send(xml, self.reverseGeocodeCallback, null, timeoutCallback);
    };
	

    /**
     * Handle reverse geocode response from Web Services.
     * @param {string} data required The XML response from web services in
     * serialized form.
     * @private
     */
    this.reverseGeocodeCallback = function(data) {
        
        var reqId = data.XLS.Response.requestID;
        var results;
        
        if ( deCarta.JSONParser.parseErrors(data) ) {
            // Return expected empty error
            results = new Address();
        } else {
            results = deCarta.JSONParser.parseAddress(data.XLS.Response.ReverseGeocodeResponse.ReverseGeocodedLocation.Address);
        }
        var  pos = new Position(data.XLS.Response.ReverseGeocodeResponse.ReverseGeocodedLocation.Point.pos);
        if ( (reqId >= 0) && _callBackArray[reqId] ) {
            _callBackArray[reqId](results, pos);
            _callBackArray[reqId] = undefined;
        }
    };
    /**
     * Handle geocode response from Web Services.
     * @param {string} data required The XML response from web services in
     * serialized form.
     * @private
     */
    this.geocodeCallback = function( data ) {
        
        // Holds Positions of possible geocode matches
        var posList=[];
        // Holds either Address or FreeFormAddress objects holding address matches
        var addrList=[];
        // The newer GeocodedAddress structure
        var geocodedAddressList=[];
        // reqId matches us with our correct callback
        var reqId=data.XLS.Response.requestID;
        if ( deCarta.JSONParser.parseErrors(data) ) {
            // Return expected empty error
            // We will end up passing the empty arrays above
        }
        else if(data.XLS.Response.GeocodeResponse.GeocodeResponseList){
            var resp;
            //deal with JSON one to many bug
            if(data.XLS.Response.GeocodeResponse.GeocodeResponseList.GeocodedAddress.length==undefined){
                resp=[];
                resp.push(data.XLS.Response.GeocodeResponse.GeocodeResponseList.GeocodedAddress);
            }else{
                resp=data.XLS.Response.GeocodeResponse.GeocodeResponseList.GeocodedAddress;
            }
            for(var i=0;i<resp.length;i++){
                var geoAddr = new GeocodedAddress();
                // Location of geocoded address
                // old-style
                posList.push(new Position(resp[i].Point.pos));
                // new-style
                geoAddr.position = new Position(resp[i].Point.pos.toString());
                
                if(resp[i].Address.freeFormAddress){
                    geoAddr.freeFormAddress = new FreeFormAddress(resp[i].Address.freeFormAddress, self.locale);
                    addrList.push(new FreeFormAddress(resp[i].Address.freeFormAddress, self.locale));
                }else if(resp[i].Address.Place){
                    geoAddr.structuredAddress = deCarta.JSONParser.parseAddress(resp[i].Address);
                    geoAddr.structuredAddress.locale= self.locale;
                    addrList.push( geoAddr.structuredAddress );
                }
                if(resp[i].BoundingBox){
                    geoAddr.boundingBox=new BoundingBox(new Position(resp[i].BoundingBox.pos[0].content),new Position(resp[i].BoundingBox.pos[1].content));
                }
                geoAddr.matchType=resp[i].GeocodeMatchCode.matchType;
                geoAddr.accuracy=resp[i].GeocodeMatchCode.accuracy;
                geocodedAddressList.push(geoAddr);
            }
        }
        if ( (reqId >= 0) && _callBackArray[reqId] ) {
            _callBackArray[reqId](posList,addrList,geocodedAddressList);
            _callBackArray[reqId] = undefined;
        }
    };
}


 /** 
  * @fileoverview Icon
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * @class The Icon class is used to create custom icon objects that can be
 * overlayed on a {@link Map} in conjunction with a {@link Pin}.
 * @description Construct a new Icon object.
 * @param {String} src required URL to the image to be used with the icon.
 * @param {int} iconAnchorX required The x pixel offset, from the left edge of
 * the src image, where the icon should be centered on when displayed on a map.
 * @param {int} iconAnchorY required The y pixel offset, from the top edge of
 * the src image, where the icon should be centered on when displayed on a map.
 * @param {int} width required The width, in pixels, of the src image.
 * @param {int} height required The height, in pixels, of the src image.
 * @param {TextOverlay} overlay optional Text to overlay on the icon, useful for
 * creating numbered icons from a single standard stock image.
 * @throws {@link Exception} When parameters are missing or incorrect, an
 * "Error instantiating..." exception will be thrown.
 * @see Pin
 * @see Position
 * @see TextOverlay
 * @constructor
 */
function Icon( src, iconAnchorX, iconAnchorY, width, height, overlay ) {
    
    if(!src || (iconAnchorX!=0 && !iconAnchorX) || (iconAnchorY!=0 && !iconAnchorY) || (width!=0 && !width) || (height!=0 && !height) ){
         throw new Exception("Error instantiating Icon, missing parameters. Icon(src,iconAnchorX,iconAnchorY,width,height) all required. The last parameter overlay is optional.");
    }
    /** @private */
    this._previousX = null;
    /** @private */
    this._previousY = null;
    /** @private */
    this.src = src;
    /** @private */
    this.anchorX = iconAnchorX;
    /** @private */
    this.anchorY = iconAnchorY;
    /** @private */
    this.width = width;
    /** @private */
    this.height = height;
    /** @private */
    this.overlay = overlay || new TextOverlay("",1,1);
}
/**
 * Retrieve the x pixel offset for the anchor of the icon image.
 * @return {int} The x pixel offset for the anchor of the icon image.
 */
Icon.prototype.getAnchorX = function(){
    
    return this.anchorX;
};
/**
 * Retrieve the y pixel offset for anchor of the icon image.
 * @return {int} The y pixel offset anchor of the icon image.
 */
Icon.prototype.getAnchorY = function(){
    
    return this.anchorY;
};
/**
 * Retrieve the pixel height of the icon image.
 * @return {int} The height of the icon image.
 */
Icon.prototype.getHeight = function(){
    
    return this.height;
};
/**
 * Retrieve the text overlay object for this icon.
 * @return {TextOverlay} The text overlay for this icon.
 */
Icon.prototype.getOverlay = function(){
    
    return this.overlay;
};
/**
 * Retrieve the src URL for the image of to be displayed by this icon.
 * @return {String} The URL to the image for this icon.
 */
Icon.prototype.getSrc = function(){
    
    return this.src;
};
/**
 * Retrieve the pixel width of the icon image.
 * @return {int} The width of the icon image.
 */
Icon.prototype.getWidth = function(){
    
    return this.width;
};
/**
 * Set the x pixel offset, from the left edge of the src image, where the icon
 * should be centered on when displayed on a map.
 * @param {int} anchorX required The x pixel offset from, the left edge of the
 * src image, where the icon should be centered on when displayed on a map.
 */
Icon.prototype.setAnchorX = function(anchorX){
    
    this._previousX=this.anchorX;
    this.anchorX = anchorX;
};
/**
 * Set the y pixel offset, from the top edge of the src image, where the icon
 * should be centered on when displayed on a map.
 * @param {int} anchorY required The y pixel offset, from the top edge of the
 * src image, where the icon should be centered on when displayed on a map.
 */
Icon.prototype.setAnchorY = function(anchorY){
    
    this._previousY=this.anchorY;
    this.anchorY=anchorY;
};
/**
 * Set the height, in pixels, of the src image.
 * @param {int} height required The height, in pixels, of the src image.
 */
Icon.prototype.setHeight = function(height){
    
    // TODO: This should not allow negative values
    this.height=height;
};
/**
 * Set the Text to overlay on the icon, useful for creating numbered icons from
 * a single standard stock image.
 * @param {TextOverlay} overlay required Text to overlay on the icon, useful for
 * creating numbered icons from a single standard stock image.
 */
Icon.prototype.setOverlay = function(overlay){
    
    this.overlay=overlay;
};
/**
 * Set the URL for the source image for the icon.
 * @param {String} src required URL to the image to be used with the icon.
 */
Icon.prototype.setSrc = function(src){
    
    this.src=src;
};
/**
 * Set the width, in pixels, of the src image.
 * @param {int} width required The width, in pixels, of the src image.
 */
Icon.prototype.setWidth = function(width){
    
    this.width=width;
};


/**
 * @fileoverview Static functions that aid in producing and managing unique Ids
 * within the deCarta JSAPI.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @namespace Functions and objects used to neatly package, and identify,
 * deCarta objects.
 * @description deCarta specific identification and tagging functions.
 * @private
 */
deCarta.IdManager = {};

/**
 * Produce a unique ID string for this particular session of deCarta.js use.
 * @param {string} prefix optional An optional string to prefix the returned
 * id with.
 * @returns {number or string} a unique id for the life of this window using
 * this instance of the deCarta JSAPI. If an argument is passed to this function
 * then the returned value will be a string, otherwise it will be a number.
 * @static
 */
deCarta.IdManager.getUniqueId = function( prefix ) {
    
    var nextId = deCarta.IdManager.getUniqueId.seedNumber++;
    
    var retval = null;
    if ( prefix ) {
        retval = "" + prefix + nextId;
    }
    else {
        retval = nextId;
    }
    return retval;
};
/**
 * Seed number for use with the IdManager. Don't start with zero.
 * @type number
 * @default 10000
 */
deCarta.IdManager.getUniqueId.seedNumber = 10000;

/**
 * Set a deCarta specific tag on an object. All deCarta tags will exist within
 * a particular object that acts as a key/value dictionary.
 * @param {Object} obj required The object to tag. This can be any JavaScript
 * non-primitive.
 * @param {string} key required The key to tag this particular object with. If
 * key already exists, key will be reset to value (see below).
 * @param {string} val optional Specific value to give to the key of this
 * object. If no value is provided, we set the value to true.
 * @static
 */
deCarta.IdManager.setTag = function( obj, key, val ) {
    
    var dictKey = deCarta.IdManager.tagDitionary;
    // default to true
    if(val===false) val=false;
    else{
        val = val || true;
    }
    if( !obj[dictKey]) {
        obj[dictKey] = {};
    }
    obj[dictKey][key] = val;
};
/**
 * Checks the value of a particular deCarta dictionary key and returns it.
 * @param {Object} obj required The object to check for tags on. Any JavaScript
 * object will work.
 * @param {string} key required The key to return the value of.
 * @returns {object} the value of the key, undefined if the key doesn't exist,
 * or undefined if this was an invalid search.
 */
deCarta.IdManager.checkTag = function( obj, key ) {
    
    var dictKey = deCarta.IdManager.tagDitionary;
    if( obj && key ) {
        if ( obj[dictKey] ) {
            // return value or undefined
            return obj[dictKey][key];
        }
    }
    // If we get here, return non-existence
    return undefined;
};
/**
 * Definition of the tag dictionary property key.
 * @type string
 * @default "deCartaTagDictionary"
 */
deCarta.IdManager.tagDitionary = "deCartaTagDictionary";

/**
  * @fileoverview InfoWindow class
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * @class A {@link Pin} that gets attached to a {@link Map} object has a
 * default, simple div for displaying any information associated with the Pin.
 * To customize the window in which the information associated with a pin is
 * displayed in, use the InfoWindow class.
 * @description Construct a new InfoWindow object.
 * @param {DIV} html An HTML Div element that defines the structure and
 * style of the InfoWindow.
 * @param {int} xOffset Relative to the upper left corner of the
 * InfoWindow, the x coordinate, in pixels, where the InfoWindow will be
 * anchored from the center of the Pin it is associated with. It is applied to
 * the onscreen display as (psuedo-code): infowindow.style.left = -(xOffset);
 * @param {int} yOffset Relative to the upper left corner of the
 * InfoWindow, the y coordinate, in pixels, where the InfoWindow will be
 * anchored from the center of the Pin it is associated with. It is applied to
 * the onscreen display as (psuedo-code): infowindow.style.type = -(yOffset);
 * @param {Icon} [closeIcon] An icon that represents the 'close' button if the
 * window is registered with onclick events. The anchor x/y of the icon are
 * relative to the upper-left corner of the InfoWindow. A default icon is used
 * if non is supplied.
 * @param {Icon} [backgroundIcon] An icon that represents the background of the
 * InfoWindow. Any TextOverlay or anchor x/y of the icon are ignored. The
 * background is always positioned from the upper left of the InfoWindow.
 * If a background icon is added to an InfoWindow the container
 * div background will be set to none and the size will be constrained
 * to the dimensions of the backgroundIcon. It is recommended that a backgroundIcon
 * not be used along with a custom html object. If both are used, the custom
 * html will be applied first, and then the settings derived from the backgroundIcon
 * will be applied to the custom html passed in as the first parameter.
 * @param {boolean} autoAdjustPos if true, autotomatically adjust infowindow position
 *  when map moveing, otherwise don't adjust infowindow. 
 * @constructor
 * @see Pin
 * @see Icon
 */
function InfoWindow( html, xOffset, yOffset, closeIcon, backgroundIcon , autoAdjustPos) {
    // Pass through
    this.init( html, xOffset, yOffset, closeIcon, backgroundIcon, autoAdjustPos );
}



//---------------------------------------------------------- Properties



/**
 * Horizontal (CSS left) shift used when anchoring this InfoWindow to a pin.
 * Applied to the onscreen display as (psuedo-code):
 * infowindow.style.left = -(xOffset);
 * @private
 * @type number
 * @default -20
 */
InfoWindow.prototype.xOffset = 0;
/**
 * Vertical (CSS top) shift used when anchoring this InfoWindow to a pin.
 * Applied to the onscreen display as (psuedo-code):
 * infowindow.style.top = -(yOffset);
 * @private
 * @type number
 * @default 0
 */
InfoWindow.prototype.yOffset = 0;
/**
 * Reference to the InfoWindow container DOM page element.
 * @private
 * @type DOM element (DIV)
 * @default null
 */
InfoWindow.prototype.bubble = null;
/**
 * CSS class used by the InfoWindow container.
 * Since there is currently only one InfoWindow allowed on a map at a time,
 * this also functions as the id of the InfoWindow container.
 * @private
 * @type string
 * @default "decarta-bubble"
 */
InfoWindow.prototype.bubbleClassName = "decarta-bubble";
/**
 * Should user generated events on the InfowWindow bubble be ignored by
 * the underlying map event handler?
 * false all events will be passed to the underlying map.
 * true events will be ignored and will not trigger underlying map events.
 * Treat this property as read only.
 * @see InfoWindow#setIgnoreMapEvents
 * @type boolean
 * @default false
 */
InfoWindow.prototype.bubbleIgnoreMapEvents = false;
/**
 * Reference to the InfoWindow content DOM page element.
 * @private
 * @type DOM element (DIV)
 * @default null
 */
InfoWindow.prototype.bubbleContent = null;
/**
 * CSS class used to style the content of the InfoWindow.
 * Since there is currently only one InfoWindow allowed on a map at a time,
 * this also functions as the id of the InfoWindow content.
 * @private
 * @type string
 * @default "decarta-bubbleContent"
 */
InfoWindow.prototype.bubbleContentClassName = "decarta-bubbleContent";
/**
 * Should user generated events on the InfowWindow content be ignored by
 * the underlying map event handler?
 * false all events will be passed to the underlying map.
 * true events will be ignored and will not trigger underlying map events.
 * Treat this property as read only.
 * @see InfoWindow#setIgnoreMapEvents
 * @type boolean
 * @default false
 */
InfoWindow.prototype.bubbleContentIgnoreMapEvents = false;
/**
 * Should the bubble content be highlightable by the mouse?
 * true means all content that makes up the bubbleContent can be highlighted
 * by the mouse.
 * false means that bubbleContent will not be selectable.
 * Treat this property as read only.
 * @type boolean
 * @default false
 */
InfoWindow.prototype.bubbleContentSelectable = false;
/**
 * Reference to the InfoWindow container DOM page element.
 * @private
 * @type DOM element (IMG)
 * @default null
 */
InfoWindow.prototype.bubbleClose = null;
/**
 * CSS class used to style the close button of the InfoWindow.
 * Since there is currently only one InfoWindow allowed on a map at a time,
 * this also functions as the id of the InfoWindow close button.
 * @private
 * @type string
 * @default "decarta-close"
 */
InfoWindow.prototype.bubbleCloseClassName = "decarta-close";
/**
 * Should user generated events on the InfowWindow close button be ignored by
 * the underlying map event handler?
 * false all events will be passed to the underlying map.
 * true events will be ignored and will not trigger underlying map events.
 * Treat this property as read only.
 * @see InfoWindow#setIgnoreMapEvents
 * @type boolean
 * @default true
 */
InfoWindow.prototype.bubbleCloseIgnoreMapEvents = true;
/**
 * The pin this InfoWindow is currently associated with when being shown.
 * @private
 * @type Pin
 * @default null
 */
InfoWindow.prototype.associatedPin = null;
/**
 * Pointer to a handler function to be called when the InfoWindow is closed
 * via a user's click on the close button.
 * This is not the same as a callback associated with hiding the InfoWindow.
 * If a hide callback and a click callback are registered, the click callback
 * will be fired first and can be used to unhook an obsoleted hide callback.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the InfoWindow.
 * @private
 * @type function
 * @default null
 * @see InfoWindow.eventClose
 * @see 
 */
InfoWindow.prototype.onCloseCallback = null;
/**
 * Pointer to a handler function to be called during a call to {@link InfoWindow#hide}.
 * This is not the same as a callback to the close event.
 * If a hide callback and a click callback are registered, the click callback
 * will be fired first and can be used to unhook an obsoleted hide callback.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the InfoWindow.
 * @private
 * @type function
 * @default null
 * @see InfoWindow#hide
 */
InfoWindow.prototype.onHideCallback = null;
/**
 * Pointer to a function handler to be called during a call to {@link InfoWindow#show}.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the InfoWindow.
 * @private
 * @type function
 * @default null
 * @see InfoWindow#show
 */
InfoWindow.prototype.onShowCallback = null;
/**
 * When we call show to display the InfoWindow, should we attempt to recenter
 * the display of the window in the center of the screen?
 * @private
 * @type boolean
 * @default false
 * @see InfoWindow#setAutoCenter
 * @see InfoWindow#autoCenter
 */
InfoWindow.prototype.shouldAutoCenter = false;

//---------------------------------------------------------- Methods

/**
 * Set whether or not, when the InfoWindow gets shown, we want the map to
 * auto-center itself to place the InfoWindow in view.
 * This is turned off by default.
 * If auto centering is turned on, when {@link InfoWindow#show} is called with
 * a pin argument, the map will pan to place the pin to, as best
 * as possible, place the info bubble so that the entire bubble is viewable
 * and in a way that is as close to the center of the view as possible.
 * @param {boolean} [setting=false] true to turn the recentering over to the
 * auto-center function, false to turn it off.
 * @see InfoWindow#autoCenter
 */
InfoWindow.prototype.setAutoCenter = function(setting){
    
    setting = setting || false;
    this.shouldAutoCenter = setting;
};

/**
 * Register callback function for when the InfoWindow is closed via a mouse
 * click on the close button.
 * If a hide callback and a click callback are registered, the click callback
 * will be fired first and can be used to unhook an obsoleted hide callback.
 * @param {Function|null} callback Function called when the window is closed via
 * a click on the close button. Pass a null argument to unset the event handler.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the InfoWindow.
 * @see InfoWindow#setOnHide
 */
InfoWindow.prototype.setOnClose = function(callback){
    
    this.onCloseCallback = callback;
};

/**
 * Register callback function for when the InfoWindow is hidden via the hide
 * method.
 * If a hide callback and a click callback are registered, the click callback
 * will be fired first and can be used to unhook an obsoleted hide callback.
 * @param {Function|null} callback Function called when the window is hidden.
 * Pass a null argument to unset the event handler.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the InfoWindow.
 * @see InfoWindow#setOnClose
 * @see InfoWindow#hide
 */
InfoWindow.prototype.setOnHide = function(callback){
    
    this.onHideCallback = callback;
};

/**
 * Register callback function for when the InfoWindow is shown via the show
 * method.
 * @param {Function|null} callback Function called when the window is hidden.
 * Pass a null argument to unset the event handler.
 * The callback function will be passed void arguments and this will refer
 * to the instance of the InfoWindow.
 * @see InfoWindow#show
 */
InfoWindow.prototype.setOnShow = function(callback){
    
    this.onShowCallback = callback;
};

/**
 * Set whether or not the different pieces of the InfoWindow will pass events
 * through to the underlying Map object.
 * @param {object} ignoreList JavaScript object containing an updated set of
 * ignore items.
 * @param {boolean} ignoreList.bubbleIgnoreMapEvents Whether user interactions
 * with the underlying InfoWindow (usually a graphic) trigger a corresponding map
 * event in that location (false) or whether the map will ignore the
 * interactions (true).
 * @param {boolean} ignoreList.bubbleContentIgnoreMapEvents Whether user interactions
 * with the content area trigger a corresponding map event in that
 * location (false) or whether the map will ignore the interactions (true).
 * @param {boolean} ignoreList.bubbleCloseIgnoreMapEvents Whether user interactions
 * with the close button trigger a corresponding map event in that
 * location (false) or whether the map will ignore the interactions (true).
 */
InfoWindow.prototype.setIgnoreMapEvents = function(ignoreList) {
    
    for ( var i in ignoreList ) {
        if ( ignoreList.hasOwnProperty(i) ) {
            // Drop property updates directly onto the object... hope dev spells well
            this[i] = ignoreList[i];
        }
    }
    // In case this is used to live update the interactivity of the window
    this.resetMapEventIgnorance();
};

/**
 * Set whether or not the content of the InfoWindow will be selectable.
 * Setting this will cause a live reset of selectability on the content window.
 * This is merely aesthetic in the browser, and should be used for security.
 * @param {object} isSelectable true to let the user highlight the bubble content,
 * false to restrict the highlighting.
 */
InfoWindow.prototype.setContentSelectable = function(isSelectable) {
    
    this.bubbleContentSelectable = isSelectable;
    // In case this is used to live update the interactivity of the window
    this.resetSelectability();
};

/**
 * Initialize the InfoWindow, supplying defaults when appropriate. Run from
 * the constructor, see it for documentation.
 * @private
 */
InfoWindow.prototype.init = function( html, xOffset, yOffset, closeIcon, backgroundIcon ,autoAdjustPos) {
    
    var i; // counter
    
    // Build the default pieces of the InfoWindow
    this.build();

    // Customize the window...
    if ( html ) {
        // ...Overwrite the old DOM container with the new. To be backwards
        // compatible, we assume that the custom html contains everything
        this.bubble = html;
        // We'll overwrite the id for our purposes, but will not overwrite
        // the class should the user app have supplied their own class
        this.bubble.id = "decarta-bubble";
        // Need to make sure the bubbleContent appears on top of custom content
        this.bubbleContent.style.position = "absolute";
        // Re-append the container and the close button
        this.bubble.appendChild( this.bubbleContent );
        if ( this.bubbleClose ) {
            this.bubble.appendChild( this.bubbleClose );
        }
    }
    // ... customize the background image ...
    if ( backgroundIcon ) {
        // Whatever the bubble is at this point gets modified.
        this.bubble.style.width = backgroundIcon.width + "px";
        this.bubble.style.height = backgroundIcon.height + "px";
        this.bubble.style.backgroundImage = "url("+backgroundIcon.src+")";
        this.bubble.style.backgroundRepeat = "no-repeat";
        this.bubble.style.backgroundColor = "transparent";
        // Assume we want to turn off the border
        this.bubble.style.borderStyle = "none";
    }
    // ... and the close button
    if ( closeIcon ) {
        if ( !this.bubbleClose ) {
            this.buildCloseIcon(closeIcon.src);
        }
        this.bubbleClose.src=closeIcon.src;
        this.bubbleClose.style.position = "absolute";
        this.bubbleClose.style.top = closeIcon.anchorY+"px";
        this.bubbleClose.style.left = closeIcon.anchorX+"px";
        if (closeIcon.height) {
            this.bubbleClose.style.height = closeIcon.height+"px";
        }
        if (closeIcon.width) {
            this.bubbleClose.style.width = closeIcon.width+"px";
        }
    }

    // Set the offsets if supplied
    if ( xOffset ) {
        this.xOffset = xOffset;
    }
    if ( yOffset ) {
        this.yOffset = yOffset;
    }
    
    if(autoAdjustPos===true){
        this.autoAdjustPos=true;
    }

    // FixPNG for ie6
    if ( Utilities.ie6 ) {
        // Everything should be appended to the bubble
        var images = this.bubble.getElementsByTagName('img');
        for ( i = 0; i < images.length; i ++ ) {
            if ( images[i].src.match(/\bpng\b/g) ) {
                Utilities.fixPng(images[i]);
            }
        }
    }
};

/**
 * Initializes the basic InfoWindow DOM elements.
 * @private
 */
InfoWindow.prototype.build = function() {
    
    try {
        //--------------------------------------------------------------
        // The container for the entire InfoWindow (bubble)
        this.bubble = document.createElement("div");
        this.bubble.id = this.bubbleClassName;
        this.bubble.className = this.bubbleClassName;
        //--------------------------------------------------------------
        // Content of the InfoWindow (bubble)
        this.bubbleContent = document.createElement("div");
        this.bubbleContent.id = this.bubbleContentClassName;
        this.bubbleContent.className = this.bubbleContentClassName;
        //--------------------------------------------------------------
        // Create default Close button for the InfoWindow if we can
        if ( Credentials.infoWindowCloseButton ) {
            this.buildCloseIcon(Credentials.infoWindowCloseButton);
        }
        //--------------------------------------------------------------
        // Add children elements to parent InfoWindow
        this.bubble.appendChild( this.bubbleContent );
    } catch (e) {
        throw new Exception("build error:"+e.message);
    }
};

/**
 * Builds the default structure for the close icon.
 * Separation of this method allows the close icon to be ignore should
 * users not wish the icon to be built by default.
 * The bubble must be built before calling this function; this function will
 * automatically append the close icon to the InfoWindow 'bubble.'
 * @param {string} [src] Sets the icon source. If argument is not passed in, an
 * image object is created without a src.
 */
InfoWindow.prototype.buildCloseIcon = function(src) {
    this.bubbleClose = document.createElement("img");
    if ( src ) {
        this.bubbleClose.src = src;
    }
    this.bubbleClose.id = this.bubbleCloseClassName;
    this.bubbleClose.className = this.bubbleCloseClassName;
    this.bubbleClose.owner = this;
    deCarta.Events.addEvent( this.bubbleClose, "click", InfoWindow.eventClose );
    this.bubble.appendChild( this.bubbleClose );
};

InfoWindow.prototype.position = function(refresh){
    if(!this.map) return;
    if(!this.autoAdjustPos) return;
    
    var offset=Utilities.getOffsetFromAncestor(this.bubble,this.map.mapDiv);
    var mapWidth=this.map.mapDiv.offsetWidth;
    var mapHeight=this.map.mapDiv.offsetHeight;
    
    if(refresh || !this.curDockY || this.bubble.offsetTop+offset.top<0
        || this.bubble.offsetTop+this.bubble.offsetHeight+offset.top>mapHeight){
        this.curDockY=this.curDockY || "top";
        
        var dockTopTop=this.topAnchorY-this.bubble.offsetHeight+offset.top;
        var dockBottomBottom=this.bottomAnchorY+this.bubble.offsetHeight+offset.top;
        if(dockTopTop < 0 && mapHeight-dockBottomBottom >= 0){
            this.curDockY="bottom";
        }else if(dockTopTop >= 0 && mapHeight-dockBottomBottom < 0){
            this.curDockY="top";
        }
        if(this.curDockY=='top'){
            this.bubble.style.top=this.topAnchorY-this.yOffset+"px";
        }else{
            this.bubble.style.top=this.bottomAnchorY+"px";
        }
    }
    
    
    if(refresh || !this.curDockX || this.bubble.offsetLeft+offset.left<0 
        || this.bubble.offsetLeft+this.bubble.offsetWidth+offset.left>mapWidth){
        this.curDockX=this.curDockX || "center";
    
        var anchorX=(this.curDockY=='top')?this.topAnchorX:this.bottomAnchorX;
        var dockLeftLeft=anchorX-this.bubble.offsetWidth+offset.left;
        var dockRightRight=anchorX+this.bubble.offsetWidth+offset.left;
        var dockCenterLeft=anchorX-this.bubble.offsetWidth/2+offset.left;
        var dockCenterRight=anchorX+this.bubble.offsetWidth/2+offset.left;
    
        if(dockLeftLeft<0 && mapWidth-dockCenterRight>=0){
            this.curDockX="center";
        }
        if(dockCenterLeft<0 && mapWidth-dockRightRight>=0){
            this.curDockX="right";
        }
        if(dockCenterLeft>=0 && mapWidth-dockRightRight<0){
            this.curDockX="center";
        }
        if(dockLeftLeft>=0 && mapWidth-dockCenterRight<0){
            this.curDockX="left";
        }
    
        if(this.curDockX=="center"){
            this.bubble.style.left=anchorX-this.xOffset+"px";
        }else if(this.curDockX=="left"){
            this.bubble.style.left=anchorX-this.bubble.offsetWidth+"px";
        }else{
            this.bubble.style.left=anchorX+"px";
        }  
    }
    
}
    
/**
 * Position (x and y) the InfoWindow relative to screen coordinates,
 * anchoring according to the offsets.
 * @param {number} topAnchorX optional Absolute top anchor point x screen coordinate to position
 * this InfoWindow. Defaults to 0. xOffset will be applied to positioning.
 * @param {number} topAnchorY optional Absolute top anchor point y screen coordinate to position
 * this InfoWindow. Defaults to 0. yOffset will be applied to positioning.
 * @param {number} bottomAnchorX optional Absolute bottom anchor point x screen coordinate to position
 * this InfoWindow. Defaults to 0. Only used when autoAdjustPosition==true;
 * @param {number} bottomAnchorY optional Absolute bottom anchor point y screen coordinate to position
 * this InfoWindow. Defaults to 0. Only used when autoAdjustPosition==true;
 */
InfoWindow.prototype.setPosition = function( topAnchorX, topAnchorY, bottomAnchorX, bottomAnchorY ) {
    
    topAnchorX = topAnchorX || 0;
    topAnchorY = topAnchorY || 0;
    
    //this.bubble.style.top = topAnchorY - this.yOffset + "px";
    //this.bubble.style.left = topAnchorX - this.xOffset + "px";
    
    this.topAnchorX=topAnchorX;
    this.topAnchorY=topAnchorY;
    this.bottomAnchorX=bottomAnchorX || topAnchorX;
    this.bottomAnchorY=bottomAnchorY || topAnchorY;
    
    if(!this.autoAdjustPos || !this.map){
        this.bubble.style.top = topAnchorY - this.yOffset + "px";
        this.bubble.style.left = topAnchorX - this.xOffset + "px";
    }else{
        this.position(true);
    }
    
};

/**
 * Updates the content to be displayed within this InfoWindow.
 * @param {HTML} content optional Sets new content for this InfoWindow. Falsey
 * values will empty the contents of the InfoWindow.
 */
InfoWindow.prototype.setContent = function( content ) {
    
    //    if ( content ) {
    //        this.bubbleContent.innerHTML = content
    //    } else {
    //        this.bubbleContent.innerHTML = "";
    //    }
    this.bubbleContent.innerHTML="";
    if ( content.style ) {
        this.bubbleContent.appendChild(content)
    } else {
        this.bubbleContent.innerHTML = content;
    }
    // Always reset the stack
    this.resetSelectability();
    this.resetMapEventIgnorance();
};

/**
 * Walk through all bubbleContent of the InfoWindow and appropriately set the
 * selectability.
 * @private
 */
InfoWindow.prototype.resetSelectability = function() {
    // Because this must be called live, we need to be able to turn on or off
    // the selectability of the content elements
    var func = (this.bubbleContentSelectable) ? Utilities.setSelectable : Utilities.setUnselectable;
    var bubContent = this.bubbleContent;
    // outer...
    func(bubContent);
    // ...inner
    if ( bubContent.hasChildNodes() ) {
        var elems = bubContent.getElementsByTagName('*');
        for ( var j = 0; j < elems.length; j++ ) {
            func(elems[j]);
        }
    }
};

/**
 * Walk through the HTML DOM pieces of the InfoWindow and, if necessary, mark
 * events that originated by these elements to be ignored by the map object.
 * @private
 */
InfoWindow.prototype.resetMapEventIgnorance = function() {
    var i, j, n, nodes, elems; // counters and collections
    if ( this.bubbleIgnoreMapEvents ) {
        // The bubble, but not anything else
        deCarta.IdManager.setTag(this.bubble, "ignoreForMapEvents" );
        if ( this.bubble.hasChildNodes() ) {
            // We only want the non-content, non-closebutton nodes
            nodes = this.bubble.childNodes;
            for ( i = 0; i < nodes.length; i++ ) {
                n = nodes[i];
                // Rely on the the classname and id to be the same for our InfoWindow
                if ( n.id != this.bubbleContentClassName && n.id != this.bubbleCloseClassName ) {
                    elems = n.getElementsByTagName('*');
                    for ( j = 0; j < elems.length; j++ ) {
                        deCarta.IdManager.setTag(elems[j], "ignoreForMapEvents" );
                    }
                }
            // continue
            }
        }
    }
    if ( this.bubbleContentIgnoreMapEvents ) {
        // The content to display
        deCarta.IdManager.setTag(this.bubbleContent, "ignoreForMapEvents" );
        elems = this.bubbleContent.getElementsByTagName('*');
        for ( i = 0; i < elems.length; i++ ) {
            deCarta.IdManager.setTag(elems[i], "ignoreForMapEvents" );
        }
    }
    if ( this.bubbleCloseIgnoreMapEvents && this.bubbleClose ) {
        // close button
        deCarta.IdManager.setTag(this.bubbleClose, "ignoreForMapEvents" );
    }
};

/**
 * Displays the InfoWindow. InfoWindows can be tied to pins.
 * @param {string} pin optional Ties this InfoWindow to a particular pin.
 */
InfoWindow.prototype.show = function( pin ) {
    
    // Until we build out the infowindow, the problem with this is that
    // many pins on a map can end up overlapping the InfoWindow once popped
    // and if the pins are refreshed. This prevents the InfoWindow from being
    // layered over with pins.
    this.bubble.style.zIndex = Pin.zIndexCounter + 10000;
    this.bubbleContent.style.zIndex = Pin.zIndexCounter + 10000;
    if ( this.bubbleClose ) {
        this.bubbleClose.style.zIndex = Pin.zIndexCounter + 10000;
    }
    this.bubble.style.display = "block";
    if ( pin ) {
        this.associatedPin = pin;
    } else {
        // This should really be improved, but this at least backwards compatible
        this.associatedPin = null;
    }
    // Show callback happens after the visual display
    if (this.onShowCallback) {
        this.onShowCallback();
    }
    // autoCenter has an internal check for whether or not it should fire
    this.autoCenter();
};

/**
 * Hide the InfoWindow from view.
 * If an onCloseCallback function is registered with this InfoWindow, that
 * function will also be called.
 */
InfoWindow.prototype.hide = function() {
    
    this.bubble.style.display = "none";
    // Hide callback happens after the visual hiding
    if (this.onHideCallback) {
        this.onHideCallback();
    }
};

/**
 * If the InfoWindow is associated with a pin, this function will attempt to
 * fit the InfoWindow within view, and appropriately centered.
 * An InfoWindow that is too large will, obviously, fail to be fit correctly.
 * This function will fail silently if it is not associated with a pin via
 * {@link InfoWindow#show}, and is automatically called at the end of that
 * function.
 * Should a more creative solution be needed, this function could be overridden
 * on a particular instance, or an onShow callback could be added to the
 * InfoWindow that handles the recentering.
 * @see InfoWindow#show
 * @see InfoWindow#setAutoCenter
 * @see InfoWindow#show
 */
InfoWindow.prototype.autoCenter = function() {
    var pin = this.associatedPin;
    if ( !(pin && pin.map) || !this.shouldAutoCenter ) {
        // exit quickly
        return;
    }
    var map = pin.map;
    // This will only work after the InfoWindow is visible on the page
    // Get the mercator bounding box of the pin
    var pinHeight = pin.pinImg.clientHeight;
    var pinWidth = pin.pinImg.clientWidth;
    var pinTop = parseInt(pin.pinImg.style.top);
    var pinLeft = parseInt(pin.pinImg.style.left);
    var scale =  Utilities.radsPerPixelAtZoomLevel(map.getTileSize(), map.getZoomController().selected);
    var pinBox = pin.getViewableBoundingBox(scale);
    var pinTopLeftPos = pinBox.getUpperLeftPosition();
    var pinTopLeftMPix = map.posToMercPix(pinTopLeftPos);
    var pinLowerRightMPix = new PixelPoint(pinTopLeftMPix.x+pinWidth, pinTopLeftMPix.y-pinHeight );
    // Get the mercator bounding box of the InfoWindow
    var iwHeight = this.bubble.clientHeight;
    var iwWidth = this.bubble.clientWidth;
    var iwTop = parseInt(this.bubble.style.top);
    var iwLeft = parseInt(this.bubble.style.left);
    var iwTopMPix = pinTopLeftMPix.y + (pinTop - iwTop);
    var iwLeftMPix = pinTopLeftMPix.x - (pinLeft - iwLeft);
    var iwTopLeftMPix = new PixelPoint(iwLeftMPix, iwTopMPix);
    var iwLowerRightMPix = new PixelPoint(iwLeftMPix+iwWidth, iwTopMPix-iwHeight);


    var iwLowerLeftMPix = new PixelPoint(iwLeftMPix, iwTopMPix-iwHeight);
    var iwTopRightMPix = new PixelPoint(iwLeftMPix+iwWidth, iwTopMPix);
    var minPos = map.mercPixToPos(iwLowerLeftMPix);
    var maxPos=map.mercPixToPos(iwTopRightMPix);


    //    // Find the encompassing max and min of a bounding box containing
    //    // Pin and InfoWindow, assuming our pin and InfoWindow might be in wonky
    //    // positions
    //    var maxMercLat = Math.max(pinTopLeftMPix.y, iwTopLeftMPix.y);
    //    var minMercLat = Math.min(pinLowerRightMPix.y, iwLowerRightMPix.y);
    //    // Maximum longitude is generated in reverse: from the lower right
    //    var maxMercLon = Math.max(pinLowerRightMPix.x, iwLowerRightMPix.x);
    //    var minMercLon = Math.min(pinTopLeftMPix.x, iwTopLeftMPix.x);
    //    // Build the bounding box
    //    var maxMPix = new PixelPoint (maxMercLon, minMercLat);
    //    var minMPix = new PixelPoint (minMercLon, maxMercLat);
    //    var maxPos = map.mercPixToPos(maxMPix);
    //    var minPos = map.mercPixToPos(minMPix);
    var pinPlusInfoWindowBBox = new BoundingBox(minPos, maxPos);
    var reCenter = pinPlusInfoWindowBBox.getCenterPosition();
    map.panToPosition(reCenter);
};

//----------------------------------------------------------- Event handlers

/**
 * Handles the close action on a click on the InfoWindow.
 * Expects the InfoWindow display to have a backpointer called owner to the
 * InfoWindow object.
 */
InfoWindow.eventClose = function() {
    // onCloseCallback happens before the window is visually hidden
    var owner = this.owner;
    if (owner.onCloseCallback) {
        owner.onCloseCallback();
    }
    owner.hide();
};


/**
 * @fileoverview Static utility functions to translate jsonified XLS messages
 * into equivalent deCarta JSAPI objects.
 */

/**
 * @namespace Container for JSON parsing utilities.
 * @description deCarta specific XLS message in JSON format parsing functions.
 * @private
 */
deCarta.JSONParser = {};

/**
 * Accept an XLS-in-JSON Address message and convert to a deCarta JSAPI
 * {@link Address} object instance.
 * @param {Object} json required The Address JSON element to convert.
 * @returns {Address} converted deCarta address object.
 * @static
 */
deCarta.JSONParser.parseAddress = function(json){
    
    var address = new Address();

    // just in case
    address.freeFormAddress=json.freeFormAddress;
    var place=json.Place;
    if (json.Place && json.Place.length) {
        // Multiple place objects come back
        for(var i=0;i<place.length;i++){
            parsePlace(address, place[i]);
        }
    }
    else if ( json.Place && json.Place.type ) {
        parsePlace(address, place);
    }
    //address.postalCode = (Utilities.isObjectEmpty(json.PostalCode)) ? "" : json.PostalCode;
    address.postalCode = (json.PostalCode)?json.PostalCode:"";
    address.countryCode = json.countryCode;
    if ( json.StreetAddress && json.StreetAddress.Street ) {
        // As of 442, Street might also have speedLimit attached to it, which will cause street to be an object
        // 2009 August 20: In very rare instances we might get an empty StreetAddress object back
        address.street = json.StreetAddress.Street.content || ((typeof json.StreetAddress.Street=="string") ? json.StreetAddress.Street : "");
        address.speedLimit = json.StreetAddress.Street.speedLimit || "";
        if( json.StreetAddress.Building ) {
            address.buildingNumber = json.StreetAddress.Building.number;
        }
    }
    return address;
    //------------------------------------------------- Inner function
    /**
     * Parse a place object into an address object.
     * @param {Address} address Recipient of the place content.
     * @param {object} place Place JSON object to parse.
     */
    function parsePlace(address, place) {
        switch (place.type){
            case "CountrySubdivision" :
                address.countrySubdivision = place.content;
                break;
            case "CountrySecondarySubdivision" :
                address.countrySecondarySubdivision = place.content;
                break;
            case "CountryTertiarySubdivision" :
                address.countryTertiarySubdivision = place.content;
                break;
            case "MunicipalitySubdivision" :
                address.municipalitySubdivision = place.content;
                break;
            case "Municipality" :
                address.municipality = place.content;
                break;
            case "Landmark" :
                address.landmark = place.content;
                break;
        }
    }
};

/**
 * Translate a Web Services xls:POI object into a deCarta JSAPI {@link POI}
 * object.
 * @param {Object} json required A deCarta Web Services jsonified
 * XLS POI.
 * @returns {POI} A POI object for use within the deCarta.js.
 * @static
 */
deCarta.JSONParser.parsePOI = function(json) {
    
    
    /*
        object POI
            string POIName = "Volkswagen Commercial Vehicles"
            object POIAttributeList
                object POIInfoList
                    array POIInfo (2)
                    [1]object
                        string name = "ADDRESS INFO"
                        string value = "105 Sumner Street,Southwark,SE19JZ"
                    [2]object
                        string name = "ID"
                        number value = 360052423
    */
    //alert(JSON.stringify(json))
    var poiInfo=[];
    if(json.POI.POIAttributeList && json.POI.POIAttributeList.POIInfoList && json.POI.POIAttributeList.POIInfoList.POIInfo)
        poiInfo = json.POI.POIAttributeList.POIInfoList.POIInfo;
    var properties = {};
    for (var p = 0; p < poiInfo.length; p++) {
        var obj = poiInfo[p];
        var nameAttr;
        for (var n in obj) {
            if (n == "name") {
                nameAttr = obj[n];
            } else if (n == "value") {
                properties[nameAttr] = obj[n];
            }
        }
    }

    // this is the ID returned from Lucene search that numerically identifies the POI
    if(json.POI.ID) {
        properties["ID"]=json.POI.ID;
    }
    
    var name = json.POI.POIName;
    var phoneNumber = json.POI.phoneNumber;
    var position = json.POI.Point.pos;
    
    var address = deCarta.JSONParser.parseAddress(json.POI.Address);    
    var poi = new POI(name, new Position(position), address, phoneNumber, properties);

    // if array then it is a corridor search POI since there is a
    // onRoute=true and onRoute=false distance.
    if(json.Distance.length){

        for(var i=0;i<json.Distance.length;i++){
            var distValue = json.Distance[i].value;
            var uom = json.Distance[i].uom;
            if(json.Distance[i].onRoute){
                poi.distance = {
                    value: parseInt(distValue),
                    uom: new UOM(uom)
                    };
            } else {
                poi.distanceOffRoute = {
                    value: parseInt(distValue),
                    uom: new UOM(uom)
                    };
            }
        }

    } else {
        var distValue = json.Distance.value;
        var uom = json.Distance.uom;
        poi.distance = {
            value: parseInt(distValue),
            uom: new UOM(uom)
            };
    }



    return poi;
};

/**
 * Translate a Web Services route response into a deCarta JSAPI {@link Route}
 * Object.
 * @param {Object} json required A deCarta Web Services jsonified
 * XLS DetermineRouteResponse.
 * @returns {Route} Route, and any alternates, converted to a JSAPI Route object.
 * @static
 */
deCarta.JSONParser.parseRoutes = function(json) {
    

    // counter
    var i;

    // Work with the main route
    var routeMessageObject = json.XLS.Response.DetermineRouteResponse;
    // Get main route, which we should always have
    var route = parseRoute(routeMessageObject);

    // Check for alternate routes
    if ( routeMessageObject.AlternateRoute ) {
        var alternateRoutes = routeMessageObject.AlternateRoute;
        var numAlternates = alternateRoutes.length;
        if ( numAlternates == undefined ) {
            // one and only one alternate route
            route.alternates[0] = parseRoute(alternateRoutes);
        }
        else {
            // multiple alternates
            for ( i = 0; i < numAlternates; i++ ) {
                route.alternates[i] = parseRoute(alternateRoutes[i]);
            }
        }
    }

    return route;
    //---------------------------------------------- End public function
    
    /**
     * Parse an individual route or alternate route. Whether main or alternate,
     * route messages are structured the same way beneath their corresponding
     * DetermineRouteResponse or AlternateRoute element.
     * @inner
     * @param {Object} routeMessageObject required The containing route message. Should be
     * either the DetermineRouteResponse or the AlternateRoute.
     * @returns {Route} deCarta JSAPI Route object.
     */
    function parseRoute(routeMessageObject) {
        
        var route = new Route();
        //---------------------------------------------------------- Summary fields
        // RouteSummary Items
        var rs = routeMessageObject.RouteSummary;
        route.TotalTime = Utilities.podParse(rs.TotalTime);
        route.TotalTimeObject = Utilities.podParseJSON(rs.TotalTime);
        route.TotalDistance = rs.TotalDistance.value;
        route.uom = new UOM(rs.TotalDistance.uom);
        var rsBBox = rs.BoundingBox;
        if ( rsBBox ) {
            // Assume pos are returned as lower-left followed by upper right
            var minPos = new Position(rsBBox.pos[0].content);
            var maxPos = new Position(rsBBox.pos[1].content);
            route.boundingBox = new BoundingBox ( minPos, maxPos );
            // If we have the bounding box, we can derive the ~center position of the route
            route.centerPosition = route.boundingBox.getCenterPosition();
        }
        // RouteID
        var rh = routeMessageObject.RouteHandle;
        if ( rh && rh.routeID ) {
            route.routeID = rh.routeID;
        }
        // for optimized routes
        var viaPointSeq = routeMessageObject.viaPointSequence;
        if ( viaPointSeq ) {
            route.viaPointSequence = viaPointSeq;
        }

        //--------------------------------------------------------- Geometry
        var rGeo = routeMessageObject.RouteGeometry;
        if ( rGeo ) {
            var routeGeometryMessage = rGeo.LineString.pos;
            var numPoints = routeGeometryMessage.length;
            if ( numPoints == undefined || !(deCarta.Array.isArray(routeGeometryMessage))) {
                // Odd case of a single point route
                route.RouteGeometry[0] = new Position( routeGeometryMessage );
            }
            else {
                // standard multipoint route
                for ( i = 0; i < numPoints; i++ ) {
                    route.RouteGeometry[i] = new Position( routeGeometryMessage[i] );
                }
            }
        }

        //--------------------------------------------------------- Instructions
        var rInstList = routeMessageObject.RouteInstructionsList;
        var rMap = routeMessageObject.RouteMap;
        if ( rInstList ) {
            var routeInstructionMessages = rInstList.RouteInstruction;
            var numInstructions = routeInstructionMessages.length;
            if ( numInstructions == undefined ) {
                // Odd case of a single point route
                route.RouteInstructions[0] = parseInstruction(routeInstructionMessages);
            } else {
                // standard multipoint route
                for ( i = 0; i < numInstructions; i++ ) {
                    route.RouteInstructions[i] = parseInstruction(routeInstructionMessages[i]);
                    // if there are maneuver maps then construct ManeuverMap into Instruction
                    if(rMap){
                        var mm = new ManeuverMap();
                        mm.desc=rMap[i].Content.description;
                        mm.URL=rMap[i].Content.URL;
                        mm.format=rMap[i].Content.format;
                        mm.height=rMap[i].Content.height;
                        mm.width=rMap[i].Content.width;
                        mm.boundingBox=new BoundingBox(
                            new Position(rMap[i].BBoxContext.pos[0].content),
                            new Position(rMap[i].BBoxContext.pos[1].content));
                        route.RouteInstructions[i].maneuverMap=mm;
                    }
                }
            }
        }
        return route;
    } // end parseRoute inner function

    /**
     * Parse an individual route instruction. Helps cut down on code.
     * @inner
     * @param {Object} routeInstructionMessage required A jsonified XLS RouteInstruction
     * message.
     * @returns {RouteInstruction} deCarta JSAPI Route Instruction.
     */
    function parseInstruction(routeInstructionMessage) {
        
        var routeInstruction = new RouteInstruction();
        routeInstruction.Instruction = routeInstructionMessage.Instruction;
        routeInstruction.distance = routeInstructionMessage.distance.value;
        routeInstruction.duration = Utilities.podParseJSON(routeInstructionMessage.duration);
        routeInstruction.position = new Position(routeInstructionMessage.Point);
        routeInstruction.tour = routeInstructionMessage.tour;
        return routeInstruction;
    } // end parseInstruction inner function
};

/**
 * Accept any XLS-in-JSON message and return true if any errors are found,
 * or false if no errors are found. Assume that any user made error handling
 * will occur in the response interceptor. Request callback functions that
 * use this will modify the response appropriately to send to the user's
 * callback function.
 * @param {Object} json required The JSON XLS message, as passed in through
 * JSRequest.
 * @returns {boolean} true if there are errors, false if there are no errors.
 * @static
 */
deCarta.JSONParser.parseErrors = function(json) {
    // If we're here we at least if a ResponseHeader
    var errorStatus = (json.XLS.ResponseHeader.ErrorList) ? true : false;
    if(json.XLS.Response.ErrorList) errorStatus=true;
    return errorStatus;
};




/**
 * @fileoverview Visualize JSON objects on the page
 * deCarta confidential and proprietary
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class A logger built to display, in a visually pleasing way, JavaScript objects.
 * Traverses the JavaScript object and nests the various sub-objects and arrays.
 * @description Construct a new viewer.
 * @constructor
 * @private
 */
deCarta.JSONViewer = function(){
    
    // It's possible to show this without a map, so init stylesheet here
    deCarta.StyleManager.init();
    /**
     * Current nesting depth of our JSON tree.
     * 0 means we're outside of the tree.
     * Minimum actual depth is 1
     * @type number
     * @default 0
     */
    var deep = 0;
    /**
     * HTML representation of JSON objects currently appended to the log.
     * @inner
     * @type string
     * @default ""
     */
    var representation = "";
    /**
     * Is array numbering in effect? Main affect is to trigger index numbers
     * on the elements.
     * @type boolean
     * @default false
     */
    var arrayFlag=false;
    /**
     * Stores array index count. Works because we call this function recursively.
     * @inner
     * @type number
     * @default 0
     */
    var index = 0;
    //-------------------------------- CSS class and ids used by the JSONViewer
    /**
     * id property used for the on page JSON console.
     * @type string
     */
    var _cssViewerId = "decarta-json-reflector";
    /**
     * className property used to define data value type.
     * @type string
     */
    var _cssTypeClassName = "decarta-json-type";
    /**
     * className for the relationship (aka. equals) sign.
     * @type string
     */
    var _cssEqualsClassName = "decarta-json-relation";
    /**
     * className for the string primitive values.
     * @type string
     */
    var _cssStrPrimClassName = "decarta-json-string";
    /**
     * className for the number primitive values.
     * @type string
     */
    var _cssNumPrimClassName = "decarta-json-number";
    
    /**
     * Traverse the JSON object and display with typed and nesting on the page.
     * Reflection will silently return if arg is falsey or NaN.
     * @param {Object} obj required A JavaScript object. 
     */
    this.reflect = function(obj){
        

        var previousIndex; // Stores previous index value before next array descent
        if ( !arrayFlag ) {
            deep++;            // Mark the depth of our recursion
        }

        // assume array if raw element types are immediately accessible
        // also allows us to deal with any primitives accidentally dropped in
        if ( typeof(obj) === "string" ) {
            reflectString(null, obj);
            return;
        }
        else if ( typeof(obj) === "number" ) {
            reflectNumber(null, obj);
            return;
        }
        else if ( typeof(obj) === "boolean" ) {
            reflectBoolean(null, obj);
            return;
        }
        else if ( typeof(obj) === "null" ) {
            reflectNull(null, obj);
            return;
        }
        else if ( typeof(obj) === "undefined" ) {
            // undefined isn't supposed to be a basic json type, but just in case
            reflectUndefined(null, obj);
            return;
        }
        else {
            // from here we assume some typeof(obj) === "object"
            // which requires
            // first check for objects immediately contained in an array
            if ( arrayFlag ) {
                // If we're here, this MUST be either an array or an object
                // arrays typeof as objects, do a special check for them first
                if ( Object.prototype.toString.call(obj) === '[object Array]' ) {
                    // Array contains an array mark appropriately and descend into
                    // arrayflag must be on here
                    reflectArray(null, obj);
                    previousIndex = index;
                    index = 0;
                    for( var i = 0; i < obj.length; i++ ) {
                        // Pass in each array element
                        index++;
                        this.reflect(obj[i]);
                    }
                    index = previousIndex;
                    return;
                }
                else {
                    // then we had best have an object. Objects in arrays are keyless
                    // mark appropriately and descend into
                    reflectObject(null);
                    // array numbering is on, turn it off for the descent into the object...
                    arrayFlag = false;
                    this.reflect(obj);
                    // and back on now that we're out
                    arrayFlag = true;
                    return;
                }
            }
            else {
                // We are not in an array, it must be some sort of object
                // Check for key : primitive pairings
                for (var member in obj) {
                    if ( typeof(obj[member]) === "string" ) {
                        reflectString(member, obj[member]);
                    }
                    else if ( typeof(obj[member]) === "number" ) {
                        reflectNumber(member, obj[member]);
                    }
                    else if ( typeof(obj[member]) === "boolean" ) {
                        reflectBoolean(member, obj[member]);
                    }
                    else if ( typeof(obj[member]) === "null" ) {
                        reflectNull(member, obj[member]);
                    }
                    else if ( typeof(obj[member]) === "undefined" ) {
                        // undefined isn't supposed to be a basic json type, but just in case
                        reflectUndefined(member, obj[member]);
                    }
                    // Not primitive, must be a key object pairing, only two choices
                    else if ( Object.prototype.toString.call(obj[member]) === '[object Array]' ) {
                        // mark key array pairing, flip on arrayflag, descend into array
                        reflectArray(member, obj[member]);
                        arrayFlag = true;
                        previousIndex = index;
                        index = 0;
                        for( var j = 0; j < obj[member].length; j++ ) {
                            // Pass in each array element
                            index++;
                            this.reflect(obj[member][j]);
                        }
                        // turn off array indexing
                        index = previousIndex;
                        arrayFlag = false;
                    }
                    else {
                        // mark key object pairing, descend into array
                        reflectObject(member);
                        this.reflect(obj[member]);
                    }
                }
            }
        }
        deep--; // Back out one level of recursion

        //--------------------------------------------------------- Inner functions
        // Reflect the various JSON types
        /**
         * Record a string.
         * @param {string} key optional Key to catalog, or null if 
         * primitive is passed in.
         * @param {string} val required Value to catalog.
         */
        function reflectString(key, val) {
            var toAppend;
            if ( key ) {
                toAppend = t("string ")+key+e()+s(val);
            }
            else {
                toAppend = t("string ")+s(val);
            }
            appendItem(toAppend);
        }
        /**
         * Record a number.
         * @param {string} key optional Key to catalog, or null if 
         * primitive is passed in.
         * @param {string} val required Value to catalog.
         */
        function reflectNumber(key, val) {
            var toAppend;
            if ( key ) {
                toAppend = t("number ")+key+e()+n(val);
            }
            else {
                toAppend = t("number ")+n(val);
            }
            appendItem(toAppend);
        }
        /**
         * Record a boolean.
         * @param {string} key optional Key to catalog, or null if 
         * primitive is passed in.
         * @param {string} val required Value to catalog.
         */
        function reflectBoolean(key, val) {
            // For now, reflect boolean as a number
            var toAppend;
            if ( key ) {
                toAppend = t("boolean ")+key+e()+n(val);
            }
            else {
                toAppend = t("boolean ")+n(val);
            }
            appendItem(toAppend);
        }
        /**
         * Correctly record a null.
         * @param {string} key optional Key to catalog, or null if 
         * primitive is passed in.
         * @param {string} val required Value to catalog.
         */
        function reflectNull(key, val) {
            // For now, reflect null as a number
            var toAppend;
            if ( key ) {
                toAppend = t("null ")+key+e()+n(val);
            }
            else {
                toAppend = t("null ")+n(val);
            }
            appendItem(toAppend);
        }
        /**
         * Record an undefined.
         * @param {string} key optional Key to catalog, or null if
         * is passed in.
         * @param {string} val required Value to catalog.
         */
        function reflectUndefined(key, val) {
            // For now, reflect undefined as a number
            var toAppend;
            if ( key ) {
                toAppend = t("undefined ")+key+e()+n(val);
            }
            else {
                toAppend = t("undefined ")+n(val);
            }
            appendItem(toAppend);
        }
        /**
         * Record an Array. The value of a keyed array is the array itself.
         * @param {string} key optional Key to catalog, or null if
         * an array object as an array element is passed in.
         * @param {string} val required The array object to catalog, we only
         * use the length.
         */
        function reflectArray( key, val ) {
            var toAppend;
            if ( key ) {
                toAppend = t("array ")+key+" ("+val.length+")";
            }
            else {
                toAppend = t("array ")+" ("+val.length+")";
            }
            appendItem(toAppend);
        }
        /**
         * Record an Object. The value of a keyed array would be an object,
         * therefore no need to pass it in as a value.
         * @param {string} key optional Key to catalog, or null if
         * an object as an array element is passed in.
         */
        function reflectObject( key ) {
            var toAppend;
            if ( key ) {
                toAppend = t("object ")+key;
            }
            else {
                toAppend = t("object ");
            }
            appendItem(toAppend);
        }
        /**
         * Form an element+content representing the type of the data stored in a
         * key.
         * @inner
         * @returns {string} HTML dom element as string.
         */
        function t(t){
            // Logging of logging too noisy. Uncomment manually if needed.
            //
            return "<span class='"+_cssTypeClassName+"'>"+t+"</span>";
        }
        /**
         * Form an element+content representing relatedness between key and value.
         * (Fancy way of saing: print an equals sign.)
         * @inner
         * @returns {string} HTML dom element as string.
         */
        function e(){
            // Logging of logging too noisy. Uncomment manually if needed.
            //
            return "<span class='"+_cssEqualsClassName+"'> = </span>";
        }
        /**
         * Form an element+content representing a string primitive as the value of
         * an object key.
         * @inner
         * @param {string} s required Value of the string primitive.
         * @returns {string} HTML dom element as string.
         */
        function s(s){
            // Logging of logging too noisy. Uncomment manually if needed.
            //
            return "<span class='"+_cssStrPrimClassName+"'>\""+s+"\"</span>";
        }
        /**
         * Form an element+content representing a number primitive as the
         * value of an object key.
         * @inner
         * @param {string} n required Value of the number primitive.
         * @returns {string} HTML dom element as string.
         */
        function n(n){
            // Logging of logging too noisy. Uncomment manually if needed.
            //
            return "<span class='"+_cssNumPrimClassName+"'>"+n+"</span>";
        }
        /**
         * Index item as an array primitive/object or a non array object and
         * append to the display.
         * @param {string} x required the key/value respresented as an HTML marked
         * up string.
         */
        function appendItem(x){
            // Logging of logging too noisy. Uncomment manually if needed.
            //
            if (arrayFlag) {
                representation += getTabs()+"["+index+"]"+x+"\n";
            }
            else {
                representation += getTabs()+x+"\n";
            }
        }
        /**
         * Determine number of tabs at the current level of nesting.
         * @returns {string} 1 tab character per level of nesting.
         */
        function getTabs(){
            // Logging of logging too noisy. Uncomment manually if needed.
            //
            var tabs="";
            for(var i=0;i<deep;i++){
                tabs+="\t";
            }
            return tabs;
        }
    }; // end deCarta.JSONViewer.reflect

    
    /**
     * Display the current store of objects on the page. Lazy-builds the
     * element in which to display the object visuals.
     */
    this.show = function(){
        // Logging of logging too noisy. Uncomment manually if needed.
        //
        var console;
            console = document.getElementById(_cssViewerId);
            if (!console) {
                // Initialize page element
                console = document.createElement("pre");
                console.id = _cssViewerId;
                document.body.appendChild(console);
            }
            console.innerHTML += representation;
    };
    /**
     * Clear any saved internal visualization of objects, and clear the
     * view of the objects.
     */
    this.clear = function(){
        // Logging of logging too noisy. Uncomment manually if needed.
        //
        representation = "";
        document.getElementById(_cssViewerId).innerHTML = "";
    };
}


/** 
 * @fileoverview JSRequest
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class The deCarta JavaScript API communicates with the DDS Web Services via
 * XML-over-HTTP requests. Browser "domain of origin" security prevents any
 * JavaScript library (including the deCarta.js library) from being downloaded
 * from one domain and used to send queries to a different domain. Since most
 * AJAX applications require accessing services from more than one domain, there
 * are two main methods used to work around the domain of origin security. One
 * method requires implementation of a proxy on the server to redirect queries
 * from the client to the DDS Web Services. The second, method involves wrapping
 * the XML sent to the DDS Web Services in a set of dynamic script tags, and
 * sending the XML over as a JSON request. The second method is simpler to use
 * out of the box because it is directly supported via the JSRequest object.
 * Besides allowing a simple method to work around the domain of origin browser
 * security, JSRequest provides a few methods for interacting with the XML
 * requests and responses sent between the deCarta JavaScript API and the DDS Web
 * Services.
 * <strong>NOTE:</strong>The most used method of this class,
 * JSRequest.setDynamicScriptTagMode(), must be called immediately
 * <strong>after</strong> any calls to map.setURL().
 * @description JSRequest is constructed on load of the deCarta.js library.
 */
function JSRequest() {}

/**
 * DDS Web Services host that we will pin our current set of dynamic script
 * tag chunks to.
 * @private
 * @type string
 * @default null
 */
JSRequest.host = null;
/** 
 * Timeout interval in milliseconds (used in Dynamic Script Tag Mode). The
 * default is 45,000 milliseconds, or 45 seconds. Changing this value will change
 * the amount of time the deCarta JavaScript API will wait for a the return
 * response from a JSON request.
 * @type int
 * @see JSRequest.timeoutHandler
 */
JSRequest.TIMEOUT = 60000;
/**
 * The default timeout handler for the dynamic script tag chunks.
 * Consider this property read only if accessed outside of the JSRequest object.
 * @private
 * @type function
 * @see JSRequest.timeoutHandler
 */
JSRequest.tHandler = function(id) {
    throw new Exception("JSRequest timeout on requestID: "+id);
};
/**
 * Per query set of timehandlers.
 * Consider this property read only if accessed outside of the JSRequest object.
 * @private
 * @type function[]
 * @see JSRequest.registerQueryTimeoutHandler
 */
JSRequest.qtHandler = [];
/**
 * Use dynamic script tags or XMLHTTPRequest?
 * @private
 * @type boolean
 * @default ture
 */
JSRequest.xmlhttp = true;


/**
 * Indicates whether or not a host is being retrieved to "stick" dynamic script
 * tag chunks to. True if retrieval is in process, false if not.
 * @private
 * @type boolean
 * @default false
 */
JSRequest.hostInProgress = false;
/**
 * Hold script tag requests until an available host to stick the requests to
 * is returned from the load balancer.
 * @private
 * @type array
 */
JSRequest.holder=[];
/**
 * Array of internal, deCarta JSAPI callback functions to be called. Functions
 * are registered by the requestID of the call.
 * @private
 * @type Array
 * @see JSRequest.send
 * @see JSRequest.callbackRegistry
 */
JSRequest.callbackFunctions = [];

/**
 * Pointer to currently registered XMLHTTPRequest object interceptor function,
 * or null if no function is registered.
 * @private
 * @type function
 * @default null
 */
JSRequest.interceptorXMLHTTPRequest = null;
/**
 * Function reference that, if defined, will be passed the XLS message string
 * prior to being sent.
 * @private
 * @type function
 * @default null
 * @see JSRequest.registerXMLRequestInterceptor
 */
JSRequest.interceptorXMLRequest = null;
/**
 * Function reference that, if defined, will be passed an XML object returned
 * from the server prior to the object being consumed by the deCarta JSAPI.
 * @private
 * @type function
 * @default null
 * @see JSRequest.registerXMLResponseInterceptor
 * @deprecated use the newer JSRequest.interceptorJSONResponse
 */
JSRequest.interceptorXMLResponse = null;
/**
 * Function reference that, if defined, will be passed the JSON object returned
 * from the server prior to the object being consumed by the deCarta jsapi
 * internal callbacks.
 * @private
 * @type function
 * @default null
 * @see JSRequest.registerJSONResponseInterceptor
 */
JSRequest.interceptorJSONResponse = null;


/**
 * Register a function that will intercept every XMLHTTPRequest object
 * after the object has been created and before the object is sent.
 * @param {Function} funct required Either a function, or a falsey value. The
 * registered intercepter function will be passed one parameter that is the
 * generated and initialized XMLHTTPRequest object. Falsey values will remove
 * any previously registered interceptor value.
 */
JSRequest.registerXMLHTTPRequestInterceptor = function(funct) {
    
    JSRequest.interceptorXMLHTTPRequest = funct;
};


/**
 * Register a function to receive the request XML before it is sent to server.
 * The function will be passed a single XML String.
 * @param {Function} funct required The function to receive the request XML
 * before it is sent to the server. It should be set-up to take one parameter,
 * that being an XML Document.
 */
JSRequest.registerXMLRequestInterceptor = function(funct){
    
    JSRequest.interceptorXMLRequest = funct;
};

/**
 * Register a per query timeout handler.
 * If a timeout happens, the general timeout handler function will fire first
 * (if registered), followed by an per query functions.
 * A registered query timeout callback function will be passed the queryID as
 * the only argument.
 * @param {Number} requestId The requestId to link this function with.
 * @param {Function} funct The function to handle a per query timeout.
 */
JSRequest.registerQueryTimeoutHandler = function(requestId, funct) {
    
    JSRequest.qtHandler[requestId] = funct;
};

/**
 * Register a function to receive the response JSON before it is sent to the
 * application. The function will be passed a single JSON Object
 * parameter.
 * The response interceptor is your chance to catch and handle errors within
 * your application.
 * @example
 * // Your application will be passed the XML document of the XLS response
 * // You can get access to the ErrorList in your Interceptor function.
 * // Assume that the parameter for your function is named data,
 * // perform the following check to alert the error message from the server.
 * // Assume we work with the Sarissa library that is part of the JSAPI.
 * // Prepare the document
 * var oDomDoc = (new DOMParser()).parseFromString(Utilities.normalizePrefixes(data), "text/xml");
 * oDomDoc.setProperty("SelectionLanguage", "XPath");
 * oDomDoc.setProperty("SelectionNamespaces", "xmlns:xls='http://www.opengis.net/xls' xmlns:gml='http://www.opengis.net/gml'");
 * // Sarissa offers cross-browser XLS
 * var errors = oDomDoc.selectNodes("//xls:Error");
 * if ( errors.length > 0) {
 *     for( var i = 0; i &lt; errors.length; i++ ) {
 *     alert("error #"+i+": severity:"+errors[i].getAttribute("severity")+", errorCode:"+errors[i].getAttribute("errorCode")+", message:"+errors[i].getAttribute("message"), "error");
 * }
 * @param {Function} funct required The function to receive a single XML
 * argument. This function can return any value, it will be ignored by
 * the application.
 * @deprecated use the newer JSON response interceptor to work with JSON
 * response payloads.
 * @see JSRequest.registerJSONResponseInterceptor
 */
JSRequest.registerXMLResponseInterceptor = function(funct){
    
    JSRequest.interceptorXMLResponse = funct;
};

/**
 * Register a function to receive the response JSON before it is sent to the
 * application. The function will be passed a single JSON Object
 * parameter.
 * The response interceptor is your chance to catch and handle errors within
 * your application.
 * You must return the JSON object from your callback function back to the
 * JSAPI.
 * @example
 * // Your application will be passed the JSON version of the XLS response
 * // You can get access to the ErrorList in your Interceptor function.
 * // Assume that the parameter for your function is named data,
 * // perform the following check to alert the error message from the server.
 * // The Error property might be a single object, or an array:
 * if (data.XLS.ResponseHeader.ErrorList) {
 *     var errorList = data.XLS.ResponseHeader.ErrorList.Error;
 *     var errorListLength = errorList.length;
 *     if (errorListLength) {
 *         for( var i = 0; i &lt; errorListLength; i++ ) {
 *             alert("error #"+i+": severity:"+errorList[i].severity+", errorCode:"+errorList[i].errorCode+", message:"+errorList[i].message);
 *         }
 *     }
 *     else {
 *         alert("error 0: severity:"+errorList.severity+", errorCode:"+errorList.errorCode+", message:"+errorList.message);
 *     }
 * }
 * @param {Function} funct required The function to receive a single JSON
 * argument before it is sent to the application. The response interceptor
 * MUST return the JSON argument.
 */
JSRequest.registerJSONResponseInterceptor = function(funct){
    
    JSRequest.interceptorJSONResponse = funct;
};

/**
 * As data is returned from the server, determine if we have gotten the final
 * response from the server for a request (as requests may be sent in chunks,
 * but the response is sent all at once).
 * @private
 * @param {object} data required Transports parameters returned from the server.
 * Currently expected properties:
 * requestID (number) array index location of the callbackFunction;
 * chunkNo (number) which chunk is this a response to;
 * response (string) either the XLS json package to handle from the server, or
 * null indicating that the request has not been fully sent yet.
 */
JSRequest.callbackRegistry = function(data){
    
    
    //mobile-dev - coding with a hammer and shovel
    if(GLOBALS.DEBUG_JSON && data){
        if(!window.jsonViewer) {
            window.jsonViewer = new deCarta.JSONViewer();
        }
        window.jsonViewer.reflect(data);
        window.jsonViewer.show();
    }
    try{
        if( data && (data.response != null) ) {
            // Log errors in debug mode
            // Errors might come back as a single object or an array
          
            // Here we assume that if we have a response,
            // then we will have at least XLS.ResponseHeader
            // JSON response interceptor - no longer XML
            try{
                // Error testing should be done within the interceptorResponseFunction
                if(typeof JSRequest.interceptorXMLResponse === 'function' && data.xmlResponse){
                    var xml = (new DOMParser()).parseFromString(Utilities.normalizePrefixes(data.xmlResponse), "text/xml");
                    // Don't handle the responses to RUOK queries that are used
                    // to pin our requests to a specific server.
                    if(data.xmlResponse.indexOf("RUOK") == -1){
                        // Ignore anything passed back
                        JSRequest.interceptorXMLResponse(xml);
                    }
                }
                if(typeof JSRequest.interceptorJSONResponse === 'function'){
                    data.response = JSRequest.interceptorJSONResponse(data.response);
                }
            }catch(e){
                throw new Exception("Application Error: API user application response interceptor function threw error: "+e.message);
            }

            // invoke callback function if it exists
            // if it doesn't exist, then make something up.
            if( JSRequest.callbackFunctions[data.requestID] ) {
                // As of 442 we can fix requestID==-1 in the response because our
                // requestID parameter in the URL == requestID in the XLS message
                // Things we need to check for:
                // - If Response is an array, correct just Response[0].requestID.
                //   We assume Response arrays are dealt with in bulk by the
                //   callback.
                // - If Response is not an array, correct the regular
                //   Response.requestID.
                if(data.responseFormat=="XML"){
                    
                }else{
                    if ( deCarta.Array.isArray(data.response.XLS.Response) ) {
                        if ( data.response.XLS.Response[0].requestID == -1 ) {
                            // Correct the first Response in the array
                            data.response.XLS.Response[0].requestID = data.requestID;
                        }
                    }
                    else if ( data.response.XLS.Response.requestID == -1 ) {
                        // Correct the requestID
                        data.response.XLS.Response.requestID = data.requestID;
                    }
                }
                JSRequest.callbackFunctions[data.requestID](data.response);
                JSRequest.callbackFunctions[data.requestID] = undefined;
                JSRequest.qtHandler[data.requestID] = undefined;
            }
        }
        // remove script tag for this chunk
        if(document.getElementById(data.requestID+":"+data.chunkNo)){
           document.getElementsByTagName("head").item(0).removeChild(document.getElementById(data.requestID+":"+data.chunkNo));           
        }
    } catch(e) {
        throw new Exception(e.message)
    }
};

/**
 * One checkTimeout gets queued for each script tag request chunk created.
 * Essentially if one chunk times out, the entire request will time out and
 * the response, even if returned from the server, will be prevented from
 * executing.
 * Once created, the timeouts are not handled or canceled by JSRequest, so this
 * function will need return silently if there is nothing to do.
 * @private
 */
JSRequest.checkTimeout = function(id) {
    
    var requestID = (id.split(":"))[0];
    if( JSRequest.callbackFunctions[requestID] || JSRequest.qtHandler[requestID] ) {
        JSRequest.host = null;
        JSRequest.tHandler(requestID);
        if ( typeof JSRequest.qtHandler[requestID] == 'function' ) {
            
            JSRequest.qtHandler[requestID](requestID);
            JSRequest.qtHandler[requestID] = undefined;
        }
        JSRequest.callbackFunctions[requestID] = undefined;
        var oldScript = document.getElementById(id);
        if (oldScript) {
            document.getElementsByTagName("head").item(0).removeChild(oldScript);
        }
    }
};



/**
 * Register a function to handle dynamic script tag requests that timeout.
 * @param timeoutHandler {function} function to execute when the request times 
 * out. Function will be passed the XLS requestID of the timed out request.
 * @param timeoutInterval {number} optional timeout interval in milliseconds, 
 * defaults to 60000 (60 seconds).
 */
JSRequest.timeoutHandler = function(timeoutHandler, timeoutInterval){
    
    JSRequest.tHandler = timeoutHandler;
    JSRequest.TIMEOUT = timeoutInterval || 60000;
};



/**
 * Send an XLS request to the DDS Web Services, using either the XMLHTTPRequest
 * method or dynamic script tags.
 * @private
 * @param {string} xml The XLS request to send to the server.
 * @param {function} callback The internal deCarta JSAPI callback
 * function that will handle the DDS WS response.
 * @param {string} [rf] If present, this will override any generated
 * response format.
 * @param {function} [qTimeout] If present, a per query timeout will be
 * registered. NOTE: This is currently not supported for XLS sent via an
 * XMLHTTPRequest.
 * @param {string} [urlOverride] If present, this URL will be used to query
 * the server. No RUOK request will precede the main request.
 */
JSRequest.send = function( xml, callback, rf, qTimeout, urlOverride ) {
    
    if (!xml){
        // No request, exit early.
        return;
    }
    // Determine which response format to use:
    // 4.4.2 it's either the rf override, JSON or ALL
    var responseFormat = rf ? "responseFormat="+rf : (typeof JSRequest.interceptorXMLRequest === "function" || typeof JSRequest.interceptorXMLResponse === "function") ? "responseFormat=ALL" : "responseFormat=JSON";
    var url = (urlOverride) ? urlOverride : Credentials.url;
    if ( (/\/openls$|\/openls\/$/.test(url)) && !urlOverride ) {
        // Fix up the URL to redirect all requests to the JSON servlet and not
        // openls servlet, as we need access to a JSON response internal to the
        // JSAPI.
        // Serialized XML will be buried in the response if needed.
        url = url.substring(0,Credentials.url.lastIndexOf("openls")) + Credentials.jsonServletName;
    }

    // if configured for using the XMLHTTPRequest object
    if ( JSRequest.xmlhttp ) {
        // Call using XMLHTTPRequest
        JSRequest.sendXHR(xml, callback, responseFormat, url);
        return;
    }

    // if configured for using the dynamic script tag approach, see below
    // because the requests are sent in chunks we need to
    // first get a host from the load balancer so the requests 
    // will all stick to the same server.
    if ( JSRequest.host==null && !urlOverride ) {
        JSRequest.holder.push(xml);
        JSRequest.holder.push(callback);
        // infinity-1 out of infinity this will be the default, but to support WSXMLTunnel....
        JSRequest.holder.push(rf);
        // infinity-1 out of infinity this will be undefined, but to support the more conscious coders....
        JSRequest.holder.push(qTimeout);
        //qTimeout = null;

        if(JSRequest.hostInProgress){
            return;
        }
        JSRequest.hostInProgress=true;
        qTimeout = JSRequest.getHostTimeout;
        //mobile-dev
        var xmlStr = new deCarta.XMLStringBuilder();    
        var initial = xmlStr.createRUOKRequest(Utilities.getRequestId());
        xml = initial;
        callback = JSRequest.getHost;
        // 442 Good lord.... okay, well, if we're pinning ourselves to a server
        // than we need to make sure that we are going to use the correct
        // responseFormat which should equal JSON
        // and, just in case the WSXMLTunnel is being used, we need to now
        // store the overriding rf values, if there are any (see above).
        responseFormat = "responseFormat=JSON";
    }

    // using the XML request interceptor
    try{
        if (typeof JSRequest.interceptorXMLRequest === 'function' && JSRequest.host!=null) {
            // 442 for backwards compatibility: pass in an XML document,
            // serialize return value
            xml = (new DOMParser()).parseFromString(Utilities.normalizePrefixes(xml), "text/xml");
            xml = Sarissa.serialize(JSRequest.interceptorXMLRequest(xml));
        }
    }catch(e){
        throw new Exception("Application Error: API user application request interceptor function threw error: "+e.message);
    }


    // Shouldn't need this anymore, we create this at the get-go
    //url = Credentials.url;
    var max = 1800;
    var urlLength = url.length;
    var otherParamsLength = 80; // i.e. the additional query params
	
    var escXmlLength = (encodeURIComponent(xml)).length;
	
    
	
    var chunks;
    var i=1;
    while(true){
        if( urlLength + otherParamsLength + ( escXmlLength / i ) < max){
            chunks=i;
            break;
        }
        i++;
    }
    var multipart="";

    // round added
    var multipartLength = Math.ceil(xml.length/chunks);

    // Match script tag reqID URL parameter with requestID from the XLS request
    // @TODO Note from Geoff: the reqID JSON URL parameter is supposed to be
    // globally unique across _all_ clients connecting to a server.
    // Note from Jeremy: Currently no way to confirm that all reqIds will
    // be unique unless we get a unique sessionID from the server.
    var reqId = Utilities.parseRequestIDFromXLS(xml);

    var endBack=0;
    for (i=1; i<=chunks; i++){
        JSRequest.callbackFunctions[reqId]=callback;
        JSRequest.qtHandler[reqId] = qTimeout;
		
        var start;
        if(endBack==0)
            start=Math.round(multipartLength*i-multipartLength);
        else
            start=endBack;
	
        var end=Math.round(multipartLength*i);
        endBack=end;

        
		
        var xmlSubStr=xml.substring(start,end);
        multipart = encodeURIComponent(xmlSubStr);

        // Create the script tag
        var scriptObj = document.createElement("script");
        // set type, source and id for script tag
        scriptObj.setAttribute("type", "text/javascript");
        var completeURL = url+"?reqID="+reqId+"&chunkNo="+i+"&numChunks="+chunks+"&callback=JSRequest.callbackRegistry&data="+multipart+"&"+responseFormat;
        
        // need to escape + symbols that occur in routeids
        completeURL=completeURL.replace(new RegExp("\\+", "g"),"%2b");
                

        scriptObj.setAttribute("src", completeURL);
        scriptObj.setAttribute("id",reqId+":"+i);
        
        // append to head
        document.getElementsByTagName("head").item(0).appendChild(scriptObj);

        if(JSRequest.TIMEOUT!=-1){
            setTimeout("JSRequest.checkTimeout('"+reqId+":"+i+"')",JSRequest.TIMEOUT);
        }        
    }
};

/**
 * Send an XLS request to the DDS Web Services, using either the XMLHTTPRequest
 * method or dynamic script tags.
 * @private
 * @param {string} xml The XLS request to send to the server.
 * @param {function} callback The internal deCarta JSAPI callback
 * function that will handle the DDS WS response.
 * @param {string} responseFormat Format of data payload returned from the
 * server.
 * @param {string} url The url to send this request to.
 */
JSRequest.sendXHR = function( xml, callback, responseFormat, url ) {
    try{
        if (!Utilities.ie){
            // For local file XHR testing
            try {
                netscape.security.PrivilegeManager.enablePrivilege("UniversalPreferencesWrite UniversalBrowserWrite UniversalPreferencesRead UniversalBrowserRead");
            } catch (e) {}
        }
        var xmlhttp = new XMLHttpRequest();
        xmlhttp.open("POST",url+"?"+responseFormat,true);
    }catch(e){
        throw new Exception(e.message+"Depending on your browser settings you may have troubles running JavaScript code that uses the XMLHTTPRequest from your local file system.  XMLHTTPRequest verifies that the request to the server is from a script that is downloaded from that same server.  To remedy this problem, place your app inside tomcat and access from localhost.  Or see the feature of using dynamic script tags (JSON/GET) to bypass this security issue.");
    }
    xmlhttp.onreadystatechange = function(){
        if (xmlhttp.readyState == 4){
            if(xmlhttp.responseText==""){
                throw new Exception("Problem connecting to DDS Web Services: Please try again later or contact support");
            }
            if(xmlhttp.responseText && xmlhttp.responseText!=null && xmlhttp.responseText.indexOf("problem connecting to DDS")>0){
                throw new Exception("Problem connecting to DDS: Please try again later or contact support");
            }
            // 2009 June 23 - Updated to work correctly for at least 5
            // minutes until we change something else
            //var r = eval(("("+xmlhttp.responseText+")"));
            var r = eval(xmlhttp.responseText);
            // Pass the XML to the XMLResponseHandler if there is one
            if (typeof JSRequest.interceptorXMLResponse === 'function' && r.xmlResponse){
                var xml = (new DOMParser()).parseFromString(Utilities.normalizePrefixes(r.xmlResponse), "text/xml");
                // Ignore anything returned from the response handler
                // we've moved beyond XML in the JSAPI ;)
                JSRequest.interceptorXMLResponse(xml);
            }
            // Pass the JSON to the JSONResponseHandler if there is one
            if (typeof JSRequest.interceptorJSONResponse === 'function'){
                // catch what is returned
                r.response = JSRequest.interceptorJSONResponse(r.response);
            }
            // Pass the JSON to the callback function
            if ( r.response ) {
                callback(r.response);
            }
            else {
                // Workaround to help with WSXMLTunnel requests, where the
                // message body is just a string
                callback(r);
            }
        }
    }
    // Intercept the xmlhttp object
    if ( typeof JSRequest.interceptorXMLHTTPRequest === 'function' ) {
        JSRequest.interceptorXMLHTTPRequest(xmlhttp);
    }

    xmlhttp.send(xml);
    return;
};

/**
 * Given the results of an RUOKResponse, determine return the hostname to use
 * to src our dynamic script tag chunks to.
 * @private
 * @param {Object} data required The RUOKResponse as a JSON object.
 */
JSRequest.getHost = function(data){
    
    
    //mobile-dev        
    var host = data.XLS.Response.RUOKResponse.hostName;
    //alert(host)
    var u = Credentials.url;
    var prefix,suffix;
    if(u.indexOf("https://")>-1)
        prefix="https://";
    else	
        prefix="http://";
    var tmp = u.substring(prefix.length);
    if(tmp.indexOf(":")>-1)
        suffix=tmp.substring(tmp.indexOf(":"));
    else
        suffix=tmp.substring(tmp.indexOf("/"));
    JSRequest.host=prefix+host+suffix;
    Credentials.url=JSRequest.host;
	
    for(var i=0; i<JSRequest.holder.length; i++){
        // 2009 June 23 adding support for WSXMLTunnel
        // Order of items being held: XLS string, callback function, requestFormat param, per query timeout
        JSRequest.send(JSRequest.holder[i],JSRequest.holder[i+1],JSRequest.holder[i+2],JSRequest.holder[i+3]);
        i=i+3;
    }

    /* RUOK NOW HAS INFO ABOUT THE HOST ALIASING */
    JSRequest.maxHostAliases = parseInt(data.XLS.Response.RUOKResponse.maxHostAliases) || 0;

    JSRequest.holder=[];
    JSRequest.hostInProgress=false;
};

JSRequest.getHostTimeout = function(id){
    for(var i=0; i<JSRequest.holder.length; i++){
        // 2009 June 23 adding support for WSXMLTunnel
        // Order of items being held: XLS string, callback function, requestFormat param, per query timeout
        //JSRequest.send(JSRequest.holder[i],JSRequest.holder[i+1],JSRequest.holder[i+2],JSRequest.holder[i+3]);
        if(typeof JSRequest.holder[i+3]=='function'){
            JSRequest.holder[i+3](null);
        }
        i=i+3;
    }
    JSRequest.holder=[];
    JSRequest.hostInProgress=false;
}
/** 
 * Sets the communication mode to use the XMLHTTPRequest, enforcing the server
 * of origin policy. This function only needs be called once per session, and
 * only needs to be called to turn off the effects of a call to
 * JSRequest.setDynamicScriptTagMode().
 */
JSRequest.setXMLHTTPMode = function(){
    
    //change the request to the usage of XMLHTTPRequest
    JSRequest.xmlhttp=true;
};
/** 
 * Sets the communication mode to use the JSON/GET with dynamic script tags, 
 * bypassing the server of origin policy. This function only needs be called once
 * per session.
 * NOTE: This function must be called following any calls to map.setURL().
 */
JSRequest.setDynamicScriptTagMode = function(){
    
    //change the request to the usage of DST
    JSRequest.xmlhttp=false;
};

/**
*  Emulates a JSRequest for a zoom in, avoiding trip to the server.
*  Moved from Map since the overviewcontroller uses it too
*
*/
JSRequest.emulatedZoomRequest = function(centerPosition, newZoomLevel, seedUrl, gxSeedUrl, callback){

    /* look up table for llmax on zoom level */
    _ll_LUT= {
        'EPSG:3395': [
            "89.787438015348100000,360.00000000000000000",
            "85.084059050110410000,180.00000000000000000",
            "66.653475896509040000,90.000000000000000000",
            "41.170427238429790000,45.000000000000000000",
            "22.076741328793200000,22.500000000000000000",
            "11.251819676168665000,11.250000000000000000",
            "5.653589942659626000,5.625000000000000000",
            "2.830287664051185000,2.812500000000000000",
            "1.415581451872543800,1.406250000000000000",
            "0.707845460801532700,0.703125000000000000",
            "0.353929573271679340,0.351562500000000000",
            "0.176965641673330230,0.175781250000000000",
            "0.088482927761462040,0.087890625000000000",
            "0.044241477246363230,0.043945312500000000",
            "0.022120740293895182,0.021972656250000000",
            "0.011060370355776452,0.010986328125000000",
            "0.005530185203987857,0.005493164062500000",
            "0.002765092605263539,0.002746582031250000",
            "0.001382546303032519,0.001373291015625000",
            "0.000691272945568983,0.000686645507812500",
            "0.000345636472797214,0.000343322753906250"
        ],
        'EPSG:3857':[                
            "85.000000000000000000,180.000000000000000000",
            "85.051128779806600000,180.000000000000000000",
            "66.513260443111850000,90.000000000000000000",
            "40.979898069620130000,45.000000000000000000",
            "21.943045533438180000,22.500000000000000000",
            "11.178401873711785000,11.250000000000000000",
            "5.615985819155340000,5.625000000000000000",
            "2.811371193331140300,2.812500000000000000",
            "1.406108835435159400,1.406250000000000000",
            "0.703107352436490900,0.703125000000000000",
            "0.351560293992270900,0.351562500000000000",
            "0.175780974247085330,0.175781250000000000",
            "0.087890590530824220,0.087890625000000000",
            "0.043945308191358085,0.043945312500000000",
            "0.021972655711432625,0.021972656250000000",
            "0.010986328057681535,0.010986328125000000",
            "0.005493164054094371,0.005493164062500000",
            "0.002746582030202296,0.002746582031250000",
            "0.001373291015495537,0.001373291015625000",
            "0.000686645507798657,0.000686645507812500",
            "0.000343322753905690,0.000343322753906250"
        ]
    };

    var pixDim =  GLOBALS.DEFAULT_MAP_TILE_SIZE;
    var scale = Utilities.radsPerPixelAtZoomLevel(pixDim, newZoomLevel);
    var fixedSeedRowIdx = 0;
    var fixedSeedColumnIdx = 0;
    var pixX = 0;
    var pixY = 0;
    var offsetPixXToTileBorder = 0;
    var offsetPixYToTileBorder = 0;
    var tileGridCenterLat = centerPosition.lat;
    var tileGridCenterLon = centerPosition.lon;    

    pixX = Math.round(Utilities.lon2pix(tileGridCenterLon, scale));
    pixY = Math.round(Utilities.lat2pix(tileGridCenterLat, scale));

    var toLat = tileGridCenterLat;
    var toLon = tileGridCenterLon;

    offsetPixXToTileBorder = (pixDim + (pixX % pixDim)) % pixDim;
    offsetPixYToTileBorder = (pixDim + (pixY % pixDim)) % pixDim;

    var offsetPixX = offsetPixXToTileBorder-pixDim/2;
    var offsetPixY = offsetPixYToTileBorder-pixDim/2;

    tileGridCenterLat = Utilities.pix2lat(pixY - offsetPixYToTileBorder + pixDim / 2.0, scale);
    tileGridCenterLon = Utilities.pix2lon(pixX - offsetPixXToTileBorder + pixDim / 2.0, scale);

    fixedSeedColumnIdx = Math.floor(pixX / pixDim);
    fixedSeedRowIdx = Math.floor(pixY / pixDim);

    var radius = pixDim / 2 * scale * Utilities.EARTH_RADIUS_METERS;
    radius *= Math.cos(tileGridCenterLat * Math.PI / 180);

    /* Modify the seed url */
    /* Split it up
     *
     * I wonder if this is faster than regexs. I want to test it out.
     * */
	var gxResultUrl = '';
	var resultUrl = '';
	 
	if (seedUrl) {
		var seedUrlObj = Utilities.urlParse(seedUrl.baseUrl);

		//Modify street url
		seedUrlObj.queryParameters.LLMAX = _ll_LUT[Credentials.projection][21-newZoomLevel];
		seedUrlObj.queryParameters.N = fixedSeedRowIdx;
		seedUrlObj.queryParameters.E = fixedSeedColumnIdx;

		//recompose	
		resultUrl = Utilities.urlCompose(seedUrlObj);
	}
	
	
	if (gxSeedUrl){
        /* Modify gx url*/	
        var gxSeedUrlObj = Utilities.urlParse(gxSeedUrl.baseUrl);          
        if(Credentials.projection=='EPSG:3857'){
            var gxZoom=Utilities.deCartaToGXZoomLevel(newZoomLevel);
            gxSeedUrlObj.queryParameters.TileMatrix = "EPSG:3857:"+gxZoom;
            var mod=Math.pow(2,gxZoom);
            gxSeedUrlObj.queryParameters.TileRow = ((-(fixedSeedRowIdx+1)+mod/2)%mod+mod)%mod;
            gxSeedUrlObj.queryParameters.TileCol = ((fixedSeedColumnIdx+mod/2)%mod+mod)%mod;
        }
        else{
            gxSeedUrlObj.queryParameters.ZOOM = Utilities.deCartaToGXZoomLevel(newZoomLevel);               
            gxSeedUrlObj.queryParameters.LL = centerPosition.lat + ", " + centerPosition.lon;
            gxSeedUrlObj.queryParameters.N = 0;
            gxSeedUrlObj.queryParameters.E = 0;
            
        }


        gxResultUrl = Utilities.urlCompose(gxSeedUrlObj);
    }
	
    /* Response struct : (need to rewrite this so it's not this big)
     * Now it's shorter, but so so much harder to read ..
     * */
    var response = {};

	response.XLS = {};
    response.XLS.Response = {};    

    response.XLS.ResponseHeader = {};
    response.XLS.ResponseHeader.ErrorList = false;

    response.XLS.Response.PortrayMapResponse = {};
    response.XLS.Response.PortrayMapResponse.TileGrid = [];
    response.XLS.Response.PortrayMapResponse.TileGrid[0] = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[1] = {};

    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan = [];

    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan[0] = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan[0].direction = 'E';
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan[0].numTiles = (offsetPixX / GLOBALS.DEFAULT_MAP_TILE_SIZE);
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan[0].toLon = toLon;

    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan[1] = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan[1].direction = 'N';
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan[1].numTiles = offsetPixY / GLOBALS.DEFAULT_MAP_TILE_SIZE;
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Pan[1].toLat = toLat;

    response.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.CenterPoint = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.CenterPoint.pos = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.CenterPoint.pos.content = tileGridCenterLat + " " + tileGridCenterLon;
    response.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.CenterPoint.radius = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.CenterPoint.radius.content = radius;

    response.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.Radius = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.Radius.content = radius;

    response.XLS.Response.PortrayMapResponse.TileGrid[0].Tile = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Tile.Map = {}
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Tile.Map.Content = {}
    response.XLS.Response.PortrayMapResponse.TileGrid[0].Tile.Map.Content.URL = resultUrl;

    response.XLS.Response.PortrayMapResponse.TileGrid[1].Tile = {};
    response.XLS.Response.PortrayMapResponse.TileGrid[1].Tile.Map = {}
    response.XLS.Response.PortrayMapResponse.TileGrid[1].Tile.Map.Content = {}
    response.XLS.Response.PortrayMapResponse.TileGrid[1].Tile.Map.Content.URL = gxResultUrl;

    if (typeof callback === 'function'){
        callback(response);
    }

}

 
 /**
  * @fileoverview KML
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */

/**
 * @class KML is a data structure which is returned by Utilities.parseKML().
 * @description Construct an object.
 * @param {KMLGeometry} geometry
 * @param {String} name required The name of this KML item, also the most likely
 * way this item would be labeled on a Map.
 * @param {String} description required The description of this KML item.
 * @constructor
 * @see OpenSearchQuery
 * @see Utilities#parseKML
 */
function KML(geometry,name,description) {
    
    if( !geometry ) {
        throw new Exception("Error constructing a KML object, geometry is required");
    }
    /**
     * @type {KMLGeometry} geometry
     */
    this.geometry=geometry;
    /**
     * The name of this item, also the most likely way this KML item would be labeled on a Map.
     * @type String
     */
    this.name=name  || null;

    /**
     * The description.
     * @type String
     */
    this.description=description || null;
}	

/**
 * @class KMLGeometry is an object the represents the location data for 
 * a KML Placemark.  The type denotes the type of geometry, either 
 * Point, LineString, Polygon, or MultiGeometry.  The coordinates is a 
 * dynamic type that is an array of Positions in the cases of KML 
 * LineString and KML Polygon, or a single Position in the case of a KML
 * Point, or an array of yet more KMLGeometry instances in the case of 
 * MultiGeometry, MultiGeometry is the case where one KML placemark 
 * might have several geometries associated.
 * @param {Object} type
 * @param {Object} coordinates
 */
function KMLGeometry(type,coordinates){
    
    /**
     * type denotes the type of geometry, either Point, LineString, Polygon,
     * or MultiGeometry.
     */
    this.type=type;
    /**
     * coordinates is a dynamic type that is an array of Positions in the
     * cases of KML LineString and KML Polygon, or a single Position in the
     * case of a KML Point, or an array of yet more KMLGeometry instances
     * in the case of MultiGeometry, MultiGeometry is the case where one
     * KML placemark might have several geometries associated.
     */
    this.coordinates=coordinates;
}

 /**
  * @fileoverview JavaScript implementation of a LinkedList.
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * Construct a linked list.
 * @class Implementation of a linked list datatype. LinkedList is simplified
 * for use within the deCarta JSAPI: the list itself keeps track of a single
 * entry point and the count of items in the list. Data is added to the list
 * via a LinkedListItem, and the LinkedListItem handles actual linking between 
 * stored objects.
 * @constructor
 * @private
 * */
deCarta.LinkedList = function() {
    
    /**
     * The length of the linked list.
     * Let the LinkedList do the touching, not you. For simplicity, foregoing the 
     * get and set functions.
     * @type int
     * @default 0
     */    
    this.length = 0;
    /**
     * Single entry point for the linked list.
     * Points to the head of the LinkedList. 
     * @type Object
     * @default null
     */
    this.head = null;
    /**
     * Unique index of this linked list.
     * @type string
     */
    this.index = deCarta.LinkedList.Config.genIndex();
    
}

/**
 * Configuration settings for Linked Lists.
 * Configuration settings for use with the LinkedList class. Should not be
 * touched unless you wish to have a global impact on future LinkedList usage.
 * The reason for this clunky implementation comes from the need to provide
 * backwards support for the old map.removePin functionality that can be passed
 * an actual pin object. The pin object will not have access to the LinkedList
 * by default unless we give it access to the LinkedList. Instead of forcing
 * each object that might use a LinkedList to have a LinkedList back pointer,
 * we'll add the backpointer pointer silently within the LinkedList object.
 * If you do not wish this side effect, do not use this LinkedList
 * implmentation. End of disclaimer.
 * @private
 */
deCarta.LinkedList.Config = {};
/**
 * The back pointer dictionary name
 * @type string
 * @default "dCLLItemPointer"
 */
deCarta.LinkedList.Config.itemBackPointer = "dCLLItemPointer";
/**
 * Combine with the itemBackPointer to create a unique LinkedList Index.
 * @type number
 * @default 0
 */
deCarta.LinkedList.Config.itemBackPointerIndex = 0;
/**
 * Generates the unique LL id.
 * @static
 */
deCarta.LinkedList.Config.genIndex = function() {
    
    return (deCarta.LinkedList.Config.itemBackPointer + deCarta.LinkedList.Config.itemBackPointerIndex++);
}

/**
 * Append new data to the LinkedList.
 * Items are added to the front of the linked list.
 * @param {Object} newData required Object to add to the list.
 * @throws {@link Exception} If newData is null or undefined, or if data
 * has already been added to a linked list, exception is thrown.
 */
deCarta.LinkedList.prototype.add = function(newData) {
    
    var item = null;

    try {
        item = new deCarta.LinkedListItem(newData, this.index);
    } 
    catch(e) {
        throw new Exception("Error LinkedList.add(): " + e.message);
    }


    if ( !this.head ) {
        // If we have a new list...
        this.head = item;
        this.head.next = null;
        this.head.prev = null;
    }
    else {
        // ... else we have a used list
        this.head.prev = item;
        item.next = this.head;
        item.prev = null;
        this.head = item;
    }

    // If we're here, we've added something to the list
    this.length++;
};


/**
 * Remove an item from the LinkedList.
 * Removes a LinkedListItem from the LinkedList. Will either function as a
 * stack pop if passed null or undefined, if passed a LinkedListItem it will
 * remove the linked list item and return the contained data, and if passed
 * a data structure that has a correctly name back pointer, it will remove
 * that back pointer from the list.
 * @param {Object} toRemove Optional null, a LinkedListItem or data within
 * the linked list.
 * @throws {@link Exception} if attempting to remove something that's not
 * actually a part of the LinkedList.
 * @return {Object} null if LinkedList is empty or the data contained within
 * the LinkedListItem removed from the list.
 */
deCarta.LinkedList.prototype.remove = function(toRemove) {
    
    // Pointers into the linked list
    var dataContainer = null;
    var dataToReturn = null;
    
    // Nothing to remove.
    if ( this.length <= 0 ) {
        return null;
    }
    
    if ( !toRemove ) {
        // Remove the head of the list    
        dataContainer = this.head;
        this.head = dataContainer.next;
    }
    else if ( (toRemove.data) && toRemove.data.hasOwnProperty(this.index) ) {
        // We are deailing with a LinkedListItem
        dataContainer = toRemove;
    }
    else if ( toRemove.hasOwnProperty(this.index) ) {
        // We are dealing with the data within a linked list
        dataContainer = toRemove[this.index];
    }
    else {
        // If we're here, we're trying to remove an object that's not a 
        // part of the LinkedList
        throw new Exception("Attempting to remove an item that's not really a part of the LinkedList.");
    }

    // reset the pointers
    if ( dataContainer.prev ) {
        // Not at the head of the list
        dataContainer.prev.next = dataContainer.next;
    } else {
        // At the head of the list
        this.head = dataContainer.next;
    }
    if ( dataContainer.next ) {
        dataContainer.next.prev = dataContainer.prev;
    }

    // Clean up the LinkedListItem and grab the data from it.
    dataToReturn = dataContainer.destroy( this.index );

    // Decrease the size of the linked list.
    this.length--;
    
    return dataToReturn;
}

/**
 * Remove items according to some underlying data key.
 * Method allows for removal of items from a list by property name of keyName
 * and value of keyVal when keyName and keyVal are found on the data underlying
 * the LinkedListItem data.
 * @param {string} keyName Required The name of the property to check for on
 * the underlying data.
 * @param {string} keyVal Required If the keyName equals this, than remove the
 * item from the LinkedList.
 * @throws {@link Exception} Don't call with undefined properties.
 * @return {Array} Array containing the data removed from the LinkedList. Null
 * if there isn't anything to be returned.
 */
deCarta.LinkedList.prototype.removeByKey = function(keyName, keyVal) {
    
    // Counters
    var i;
    // Avoid side effect of removing items from the list
    var numItems = this.length;
    // Deal with the LinkedListItems 1 by 1
    var nextItem = this.head;
    var currentItem;
    // Used to hold our items
    var foundItems = new Array();
    
    // We must have at least the semblance of valid parameters...
    if( !keyName || !keyVal ) {
        throw new Exception("Attempt to removeByKey keyName: " +
            keyName + " and keyVal: " + keyVal);
    }
    if ( this.length <= 0 ) {
        // ... and let's not deal with empty linked lists.
        return null;
    }
    
    for ( i = 0; i < numItems; i++ ) {
        // Ready the next item, if we need to check it.
        currentItem = nextItem;
        nextItem = currentItem.next;
        
        if ( keyVal == currentItem.data[keyName.toString()] ) {
            foundItems.push( this.remove(currentItem) );
        }
    }
    
    if ( !foundItems.length ) {
        return null;
    }
    else {
        return foundItems;
    }
    
}



/**
 * Remove an item by data id.
 * Method allows for removal of a single item from a list by property name of 
 * idName with a matching idVal. This will remove the first data item 
 * that matches idName and idVal and then return. Much faster removal function
 * if underlying data is assumed to contain unique idVals.
 * @param {string} idName Required The name of the property to check for on
 * the underlying data.
 * @param {string} idVal Required If the idName equals this, than remove the
 * item from the LinkedList.
 * @throws {@link Exception} Don't call with undefined properties.
 * @return {Object} Returns the data object if found, null if nothing matches.
 */
deCarta.LinkedList.prototype.removeById = function(idName, idVal) {
    
    // Counters
    var i;
    // Avoid side effect of removing items from the list
    var numItems = this.length;
    // Deal with the LinkedListItems 1 by 1
    var nextItem = this.head;
    var currentItem;
    // Used to hold our item
    var foundItem = null;
    
    // We must have at least the semblance of valid parameters...
    if( !idName || !idVal ) {
        throw new Exception("Attempt to removeByKey keyName: " +
            idName + " and keyVal: " + idVal);
    }
    if ( this.length <= 0 ) {
        // ... and let's not deal with empty linked lists.
        return null;
    }
    
    for ( i = 0; i < numItems; i++ ) {
        // Ready the next item, if we need to check it.
        currentItem = nextItem;
        nextItem = currentItem.next;
        
        if ( idVal == currentItem.data[idName.toString()] ) {
            foundItem = this.remove(currentItem);
            return foundItem;
        }
    }
    
    // Nope, didn't find anything
    return null;
}



/**
 * Remove and return all items from a LinkedList.
 * Method removes and returns all data from a LinkedList as an array.
 * This empties, but does not destroy, the LinkedList.
 * @return {Array} returns an array object containing any data objects that were
 * stored within the LinkedList. The array object will be empty
 * if the linked list was empty.
 */
deCarta.LinkedList.prototype.removeAll = function() {
    
    // Array to return any data within
    var dataToReturn = [];
    var dataRemoved = null;
    
    while(this.length > 0) {
        dataRemoved = this.remove();
        dataToReturn.push( dataRemoved );
    }
    
    return dataToReturn;
}



/**
 * Return access to the underlying data as an array.
 * I don't like this function, but it's necessary to support the Map.getPins()
 * method that currently exists. This function finds all data within the
 * LinkedList, returns that data within an array, but does not remove the
 * data from the LinkedList. Yikes, but backwards compatible.
 * @return {Array} returns an array object. The array object will be empty
 * if the linked list was empty.
 */
deCarta.LinkedList.prototype.returnAsArray = function() {
    
    // Array to return any data within.
    // me an overcommenter? nahhhhhh....
    var dataToReturn = [];
    // Counter
    var i;
    // current item to deal with
    var llitem = this.head;
    // next item to deal with
    var next = null;
    
    for ( i = 0; i < this.length; i++ ) {
        dataToReturn.push( llitem.data );
        next = llitem.next;
        llitem = next;
    }
    
    return dataToReturn;
}



/**
 * Perform operations on the underlying data without altering the LinkedList.
 * Takes the passed in function pointer and runs each LinkedListItem data 
 * object through the function. It is assumed the caller will use this function
 * responsibly as it meant to allow for simple operations on the underlying
 * data.
 * @param {function} fp Required Each LinkedListItem data object will be passed
 * into this function.
 * @throws {@link Exception} If fp is not of function type, toss an error.
 */
deCarta.LinkedList.prototype.operateOnData = function(fp) {
    
    // counter
    var i;
    // current item to deal with
    var llitem = this.head;
    // next item to deal with
    var next = null;
    
    // For speed, check for errors first    
    if ( typeof fp != 'function' ) {
        throw new Exception("Attempt operateOnData without a function.");        
    }
    
    // iterate away
    for( i = 0; i < this.length; i++ ) {
        fp( llitem.data );
        next = llitem.next;
        llitem = next;
    }
};

/*----------------------------------------------------------------------------*/

/**
 * Construct an object container for use within a LinkedList.
 * @class Container for abstract data for use within a LinkedList. There is
 * currently no reason to use this class outside of LinkedList code.
 * LinkedListItem implements the double link: next and prev.
 * @constructor
 * @param {Object} newData required Data to add to add to envelope in the
 * LinkedListITem.
 * @param {string} index required Index of the LinkedList of the item to
 * add to.
 * @throws {@link Exception} if newData is not an object, if index is falsey, 
 * throw error
 * @private
 */
deCarta.LinkedListItem = function( newData, index ) {
    
    // Should not be attempting to add in data that is already part of a
    // list, or empty data, at least in this implementation.
    if ( !newData || (typeof newData != 'object') || !index ) {
       throw new Exception("LinkedList Error: Attempt to add null or primitive.");
    }
    if ( newData.hasOwnProperty(index) ) {
       throw new Exception("LinkedList Error: newData already contains" + 
         "property backpointer: " + index);
    }

    /**
     * Pointer to data to be included in the LinkedList.
     * @type Object
     */
    this.data = newData;
    // And here we get a bit tricky... we need some way to access the list
    // through the object. Add a parameter to the object.
    // MUST null out this parameter when we nuke the data from the list.
    newData[index] = this;
    
    /**
     * Pointer to the next item in the LinkedList.
     * @type Object
     */
    this.next = null;
    /**
     * Pointer to the previous item in the LinkedList.
     * @type Object
     */
    this.prev = null;
}

/**
 *  Cleans up the LinkedListItem container and returns the data.
 * @param {string} index required Index of the LinkedList of the item to
 * remove.
 *  @return {Object} Returns any data from the LinkedListItem.
 */
deCarta.LinkedListItem.prototype.destroy = function( index ) {
    
    var dataToReturn = this.data;

    // Nullify this
    this.data = null;
    this.next = null;
    this.prev = null;
    
    // Remove the backpointer from the data
    delete dataToReturn[index];
    
    // Make sure we don't lose the data
    return dataToReturn;
}

/** 
 * @fileoverview Locale representing structured address
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class A Locale object represents a specific geographical, political, or
 * cultural region. An operation that requires a Locale to perform its task is
 * called locale-sensitive and uses the Locale to tailor information for the
 * user. Currently, Locales can be attached to a {@link FreeFormAddress} object
 * to aid in producing better results with a {@link Geocoder#geocode}.
 * The current valid pairs of language and country codes are as follows:
 * <ul>
 * <li>Language Code: "DE"; Country Code: "AT"</li>
 *   <ul><li>for German in Austria</li></ul>
 * <li>Language Code: "EN"; Country Code: "CA"</li>
 *   <ul><li>for English in Canada</li></ul>
 * <li>Language Code: "FR"; Country Code: "CA"</li>
 *   <ul><li>for French in Canada</li></ul>
 * <li>Language Code: "DE"; Country Code: "DE"</li>
 *   <ul><li>for German in Germany</li></ul>
 * <li>Language Code: "ES"; Country Code: "ES"</li>
 *   <ul><li>for Spanish in Spain</li></ul>
 * <li>Language Code: "FR"; Country Code: "FR"</li>
 *   <ul><li>for French in France</li></ul>
 * <li>Language Code: "EN"; Country Code: "GB"</li>
 *   <ul><li>for English in Great Britain</li></ul>
 * <li>Language Code: "EN"; Country Code: "IE"</li>
 *   <ul><li>for English in Ireland</li></ul>
 * <li>Language Code: "IT"; Country Code: "IT"</li>
 *   <ul><li>for Italian in Italy</li></ul>
 * <li>Language Code: "EN"; Country Code: "US"</li>
 *   <ul><li>for English in the United States</li></ul>
 * </ul>
 * <p>These pairs of language can be used to create a valid locale for use with
 * the Geocoder.</p>
 * @description Construct a new Locale object.
 * @param {String} language required A valid ISO Language Code. It is always an
 * upper case, two letter string. See the class description for valid language
 * and country code pairs.
 * @param {String} country required A valid ISO Country Code. It is always an
 * upper case, two letter string. See the class description for valid language
 * and country code pairs.
 * @see FreeFormAddress
 * @see Geocoder
 * @constructor
 */  
function Locale( language, country ) {
    
    /**
     * A valid ISO Language Code. It is always an upper case, two letter string.
     * See the class description for valid language and country code pairs.
     * @private
     * @type String
     */
    this.language = language.toUpperCase();
    /**
     * A valid ISO Country Code. It is always an upper case, two letter string.
     * See the class description for valid language and country code pairs.
     * @private
     * @type String
     */
    this.country = country.toUpperCase();
} // End Locale constructor


/**
 * Retrieve the language code for this locale
 * @return {String} language field of the Locale object
 */
Locale.prototype.getLanguage = function() {
    
    return this.language;
};

/**
 * Set the language code for this locale.
 * @param {String} language required A valid ISO Language Code. It is always an
 * upper case, two letter string. See the class description for valid language 
 * and country code pairs.
 */
Locale.prototype.setLanguage = function(language) {
    
    this.language = language.toUpperCase();
};

/**
 * Retrieve the country code for this locale
 * @return {String} country field of the Locale object
 */
Locale.prototype.getCountry = function() {
    
    return this.country;
};

/**
 * Set the country code for this locale.
 * @param {String} country required country required A valid ISO Country Code. 
 * It is always an upper case, two letter string. See the class description for 
 * valid language and country code pairs.
 */
Locale.prototype.setCountry = function(country) {
    
    this.country = country.toUpperCase();
};

/**
 * Concatenates the country and language fields, in that order and returns 
 * that string.
 * @return {String} The Locale object as a single, underbar delimited string.
 */
Locale.prototype.toString = function() {
    return this.language + "_" + this.country;
};

/* @fileoverview Basic Map interface for a quick and modular use of draggable maps.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 * @author Brent Hamby
 */
/**
 * @class The Map Class provides the necessary objects for an online mapping
 * application: it provides the map display and interaction. In its simplest
 * form, Map objects provide a draggable map to the end user. Almost all other
 * functionality hooks into the Map, from  controllers and
 * the display of traffic to routes, geocodes, and dynamically placed pins and
 * shapes.
 * @description Construct a new Map object. Make sure to include the map
 * dimensions as CSS, either inline or via a CSS style rule on the map container.
 * The map container dimensions (height and width) must be even numbers.
 * Default map dimensions are 500px by 800px.
 * @example
 * &lt;!-- Map with width and height configured, id is arbitrary --&gt;
 * &lt;div id="map" style="width:800px; height:500px;"&gt;&lt;/div&gt;
 * @param {DIV} mapContainer required An HTML Div Element within a page that will
 * display the Map object.
 * @throw {Exception} If mapContainer doesn't appear to be a valid DIV.
 * @constructor
 */
function Map( mapContainer ) {
    

    // Initialize our deCarta styles
    deCarta.StyleManager.init();

    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BEGIN CONSTRUCTOR
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

    if ( !(mapContainer && mapContainer.style) ) {
        throw new Exception("Must supply a div element to construct the map.");
    }
    /**
     * Pointer to the page div acting as the viewport for this map.
     * @private
     */
    this.mapDiv = mapContainer;
    
    // Make sure dimensions are set
    // 442 Change in how the inital dimensions are set to work around possible
    // rare cases on mobile.
    // Step 1: Check any possible CSS settings for height and width.
    // Step 2: If no dimension available, check offsetHeight and offsetWidth.
    // Step 3: If no dimension yet available, use default.
    var initialHeight = parseInt(deCarta.StyleManager.getCurrentStyle(mapContainer, "height"));
    initialHeight = (!isNaN(initialHeight)) ? initialHeight : this.mapDiv.offsetHeight;
    initialHeight = (initialHeight) ? initialHeight+"px" : GLOBALS.DEFAULT_MAP_HEIGHT;
    this.mapDiv.style.height = initialHeight;
    var initialWidth = parseInt(deCarta.StyleManager.getCurrentStyle(mapContainer, "width"));
    initialWidth = (!isNaN(initialWidth)) ? initialWidth : this.mapDiv.offsetWidth;
    initialWidth = (initialWidth) ? initialWidth+"px" : GLOBALS.DEFAULT_MAP_WIDTH;
    this.mapDiv.style.width = initialWidth;
    /**
     * Used in various spots, in particular with event registration.
     * @private
     */
    this.type = "map";

    // private variables
    //**************************************** Objects associated with the map
    // Enforce closure across private public boundaries
    var self            = this;
    // Hash of controls associated with this map
    var _mapControlList = {};
    // The scalebar object associated with the map
    var _scaleBar       = undefined;
    // Copyright message associated with the map
    var _copyright      = null;
    // Zoom controller attached to the map
    var _zoom           = null;
    // Pan controller attached to the map
    var _panController  = null;

    var _mapOverviewController = null;
    var _shapeDrawingTool = null;

    // the MapTypeController
    var _chooser        = null;
    // Currently active InfoWindow
    var _bubble         = null;
    // 4.4.2 Generates XLS requests, as strings, to send to the DDS WS
    var _xmlRecFac      = new deCarta.XMLStringBuilder();
    // Currently displayed view (MapTypeController) to the user
    // Set on the XMLRequestFactory
    _xmlRecFac.mapType   = GLOBALS.STREET; // GLOBALS.STREET || GLOBALS.HYBRID || GLOBALS.SATELLITE
    // "client" || "server" rendering of DDShapes
    var _rendering       = "server";
    // 4.4.2 Clipping is a near-term pity-fix for FireFox and IE who just have
    // some finicky implementations.
    var _clipShapes      = false;

    // Holds callback functions
    // For regular callbacks, a number will always be used as the index.
    // For animations, like panToPosition, this structure will also be used.
    // Animations will NEVER use numbers, but strings and treat the array as an
    // object. Current special strings used:
    // "panToPosition" - fires after the panToPosition function animation ends.
    // "zoomMap" - fires after the zoomMap function completes.
    var _callBackArray      = [];
    // Holds labels and dictionary of events (the Array object is overloaded)
    var _events             = new Array();
    // What pins have been added to the map
    var _pinList            = new deCarta.LinkedList();
    // Associative array reference to each map layer
    var _mapLayers = {};    
    // Contains the ZoomLayer used for digital zooming.
    var _zoomLayer          = null;
    // The on-the-html-page map container
    var _mapArrayDiv        = null;
    //**************************************** Constants
    // In Internet explorer or not
    var _isIE           = Utilities.ie;
    // Reusable CSS styling suffix for positions, maybe a time saver?
    var _px             = "px";

    //**************************************** Event state variables
    // Boolean for whether or not to draw a border around the tiles
    var _tileBorder      = 0;

    // Is dragging currently enabled
    var _draggingEnabled = true;
    // is the map currently dragging?
    var _drag            = false;
    // X pixel of start drag
    var _dragStartX      = 0;
    // Y pixel of start drag
    var _dragStartY      = 0;


    // Is the map zooming?
    var _zoomLock         = false;

    // Sliding "event"
    // Is the map sliding in a panToPosition event
    var _sliding	 = false;
    // Remainder number of x pixels to pan during a slide
    // Positive is west, negative is east.
    var pixelsToSlideX = 0;
    // Remainder number of y pixels to pan during a slide.
    // Positive is north, negative is south.
    var pixelsToSlideY = 0;

    // Has the map been resized
    var _hasResized      = false;

    // 4.4.1 Is digital zoom enabled (by default yes)
    var _digitalZoom = true;

    // Does the double click recenter the map or do nothing at all?
    var _doubleClickRecenteringEnabled = true;
    // Browser independent assistance for determining mouse clicks
    var _mouseDownClock = new Date();
    var _mouseUpClock   = new Date();
    // Is a double click happening?
    var _dbclick         = false;
    // Is a double click and zoom happening?
    var _dbclickZoom     = false;
    // Is the map beginning to be dragged by the user, and is it done being dragged?
    // helps with movestart and moveend
    var _didMove        = false;

    // Number of milliseconds delay between each frame of a pan
    // Default of 37 ~= 27 frames a second.
    var _mapPanTimeoutDelay    = 37;

    //**************************************** Map display settings
    // Current center Position of the map
    var _centerPosition  = null;
    // 4.3.4 This is the center position of the tilegrid we are working with
    //var _fixedGridCenterPosition = null
    // Tile size (square). Default 256 = GX complient tile size
    var _tileSize        = GLOBALS.DEFAULT_MAP_TILE_SIZE;
    // Used to determine when to flip a tile
    var _threshold       = _tileSize;
    // Map dimensions units tiles
    var _horizontalTiles = 0;
    // Map dimensions units tiles
    var _verticalTiles   = 0;
    // Number of tiles functioning as a buffer outside of the viewable map
    var _tileBuffer      = 2;
    /**
     *  Determines whether all tiles, or only tiles within the viewport, should
     *  make a GET request to the server for their tiles.
     *  @type boolean
     *  @default false
     */
    var _onlyLoadTilesInViewport = false;

    //**************************************** On screen positioning
    // The initial fixed tile grid pixel offset.
    // These values are used to perform the initial pan, or offset, of
    // the fixed tile grid map so the requested center position can be displayed.
    var _fixedGridPixelOffset = new PixelPoint(0,0);

    // Before panning the true centerpoint of the fixed tile grid map into view
    // This is the offset in pixels between the upper left corner of
    // the tilegrid and the viewable map div
    var _offsetX            = 0;
    var _offsetY            = 0;

    // The current pixel location of the upper left corner of the tilegrid
    // relative to the viewable map--the actual map DIV tag.
    var _mapDivX            = 0;
    var _mapDivY            = 0;
    // The current origin location of the upper left corner of the tilegrid
    // parent DOM element relative to the viewable map.
    var _mapDivXorigin      = 0;
    var _mapDivYorigin      = 0;

    // Sub-tile delta pixel pan. When _deltaX or _deltaY passes the _threshold
    // pixel distance in the horizontal or vertical direction, a new tile is
    // requested.
    var _deltaX             = 0;
    var _deltaY             = 0;

    // for enabling ability to draw rectangles on the map for zooming
    var _rightClickBBoxZoomEnabled=false;

    // this is for the pan easing routines
    var _dragEasingEnabled=false;
    var _dragEasing=false;
    var _dragEasingSecondToLastMoveXY={
        x:0,
        y:0
    };
    var _dragEasingLastMoveXY={
        x:0,
        y:0
    };
    var _dragEasingIntervalID=null;

    var _raphael_paper = null;
    var _canvas = null;
    var _tilesContainer = null;

	var _mapTileFading = true;

    var _onRotateCallback=undefined;

    var _wheelZoom = false;

    //TODO fix all of the z-indices

    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ END CONSTRUCTOR
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BEGIN PRIVILAGED PUBLIC INTERFACE
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

    // NOTE: Due to the size of the map class, methods are grouped as best as
    // possible: all pin stuff is together, overlay stuff is together, etc.
    // NOTE 2: JsDoc and PERL once again are proving why I despise PERL like a bad
    // rash between my toes. Fully documenting the map class breaks Perl's stupid
    // fragile regular expression search length limit... although, maybe it does
    // have a point that the map class could use some refactoring. Solution I
    // found is to only turn on the documenting slash-star-star indicator for
    // functions that really should show up in the JsDocs

    ////----------------------------------------------------------------------------
    ////----------------------------------------------- Group: Authentication
    ////----------------------------------------------------------------------------

    /**
     * Authenticate the Map. If you have already authenticated another object,
     * or have manually set the authentication fields of the Credentials object,
     * you do not have to use this function.
     * @param {String} clientName required Set with the clientName
     * authentication token.
     * @param {String} clientPassword required Set with the clientPassword
     * authentication token.
     * @throws {Exception} exception "Error calling Map.authenticate(), bad
     * params"
     * @see Credentials
     */
    this.authenticate = function(clientName, clientPassword){
        
        if(!clientName || !clientPassword || clientName=="" || clientPassword==""){
            throw new Exception("Error calling Map.authenticate(), bad params");
        }
        Credentials.clientName = clientName;
        Credentials.clientPassword = clientPassword;
        // 4.4.1
        _xmlRecFac.clientName = clientName;
        _xmlRecFac.clientPassword = clientPassword;
    };

    /**
     * Changes the DDS Web Services that this Map instance is pointing towards.
     * @param {String} url required Full URL to the DDS Web Services.
     */
    this.setURL = function(url) {
        
        Credentials.url=url;
    };

    /**
     * Changes the configuration used to generate the map. Map configurations
     * are defined within the DDS Web Services. This does not automatically
     * refresh the map view.
     * @param {String} configuration required A valid configuration name.
     * @see Map#reDrawMap
     * @see Map#setMapStyle
     * @see Credentials#configuration
     */
    this.setConfiguration = function(configuration){
        
        if(!configuration){
            throw new Exception("error calling Map.setConfiguration() with argument: " + configuration);
        }
        Credentials.configuration = configuration;
        _xmlRecFac.configuration = configuration;
    };

    /**
     * Changes the configuration to be used for hybrid maps. Unless you have
     * been advised to use this function, it is recommended that you do not
     * use it.
     * @param {String} transparentConfiguration required The name of a valid
     * configuration.
     * @see Map#setConfiguration
     */
    this.setTransparentConfiguration = function(transparentConfiguration){
        
        if(!transparentConfiguration){
            throw new Exception("error calling Map.setTransparentConfiguration() with arg: " + transparentConfiguration);
        }
        Credentials.transparentConfiguration = transparentConfiguration;
        _xmlRecFac.transparentConfiguration = transparentConfiguration;
    };

    /**
     * Dynamically change map style to one of the predefined map styles
     * defined by the DDS Web Services configuration settings. Redraws the
     * map tiles when called.
     * @param {String} newStyle required A valid mapstyle, as defined by the DDS
     * Web Services.
     */
    this.setMapStyle = function(newStyle) {
        
        Credentials.configuration = newStyle;
        _xmlRecFac.configuration = newStyle;
        if ( _mapLayers[GLOBALS.STREET] && _mapLayers[GLOBALS.STREET].refUrl ) {
            _mapLayers[GLOBALS.STREET].refUrl.setParameter( "config", newStyle );
            _mapLayers[GLOBALS.STREET].refresh();
        }
    };

    /**
     * Change the format of the street map to any that are supported by the
     * DDS Web Services: SVG, BMP, JPG, GIF or PNG. This method will refresh
     * the displayed street map tiles.
     * @param {string} format required A valid image format. No error checking
     * is performed, please insure correctness before using.
     */
    this.setMapFormat = function(format) {
        
        _xmlRecFac.streetImgFormat = format;
        if ( _mapLayers[GLOBALS.STREET] && _mapLayers[GLOBALS.STREET].refUrl ) {
            _mapLayers[GLOBALS.STREET].refUrl.setParameter( "format", format );
            _mapLayers[GLOBALS.STREET].refresh();
        }
    };

    this.dg3SatelliteImgFormat = "image/jpeg";
        
    /**
     * Change the format of the DG3 Satellite tile url, can be "png", "jpeg".
     * @param {string} format required A valid image format. No error checking
     * is performed, please insure correctness before using.
     */
    this.setDG3SatelliteFormat = function(format) {
        
        format="image/"+format;
        this.dg3SatelliteImgFormat = format;
        if (Credentials.projection=="EPSG:3857" && _mapLayers[GLOBALS.SATELLITE] && _mapLayers[GLOBALS.SATELLITE].refUrl) {
            if(_mapLayers[GLOBALS.SATELLITE].refUrl.isDGSpherical){
                _mapLayers[GLOBALS.SATELLITE].refUrl.setParameter( "format", format );
                _mapLayers[GLOBALS.SATELLITE].refresh();
            }
        }
    };

    /**
     * Change map style to one of the predefined map styles. Internally calls
     * setMapStyle.
     * @param {String} newStyle required choices old-english-tile
     * blue-steel-tile parchment-tile back-white-tile
     * @deprecated use setMapStyle
     * @private
     */
    this.changeCurrentMapStyle = function(newStyle){
        
        setMapStyle(newStyle);
    }

    /**
     * Refreshes the view of the map. This function will probably only be
     * used in conjunction with other functions that require a map refresh
     * and reference this function.
     * @param {function} callBack optional A callBack function that will be called when
     * the map has been resized. The center position of the map will be passed
     * as an argument to the callBack function.
     * @returns {boolean} false if the redraw does not happen, true if the
     * redraw is actually performed.
     */
    this.reDrawMap = function( callBack ){
        
        if( !_mapLayers[GLOBALS.STREET] && !_mapLayers[GLOBALS.SATELLITE] && !_mapLayers[GLOBALS.HYBRID] ) {
            return false;
        }
        // 4.4.1: This is now just a front for center on position
        self.centerOnPosition( self.getCenterPosition(), callBack );
        // Redraw has happened
        return true;
    }

    ////----------------------------------------------------------------------------
    ////----------------------------------------------- Group: Copyright
    ////----------------------------------------------------------------------------

    /**
     * Place a copyright message within the Map display. NOTE: While you never
     * need to display a deCarta copyright, it is your responsibility to display
     * the correct copyright for the data provider you are using. By default,
     * the copyright message will be displayed in the lower left corner of
     * the map.
     * @param {String or Object} message required A Text or HTML message to be
     * displayed in the Map div. As of version 4.4.1, a deCarta.CopyrightMessage
     * can also be passed in as an argument.
     * @param {int} x optional DEPRECATED IN JSAPI 4.4.1, SEE NOTE BELOW.
     * If you wish to place the copyright message in a
     * custom location, this is the x offset (in pixels) of the upper-left
     * corner of  the copyright message from the upper-left corner of the viewable
     * Map.
     * @param {int} y optional DEPRECATED IN JSAPI 4.4.1, SEE NOTE BELOW.
     * If you wish to place the copyright message in a
     * custom location, this is the y offset (in pixels) of the upper-left
     * corner of  the copyright message from the upper-left corner of the viewable
     * Map.
     * @deprecated As of 4.4.1 the 'x' and 'y' anchor arguments are deprecated. They
     * have been left in under the assumption that the application will never
     * be resizing the map. The 'x' and 'y' anchoring methodology does not
     * work well for a resizeable map. Please see the deCarta.CopyrightMessage
     * class if you need more customizeable functionality.
     */
    this.addCopyrightMessage = function( message, x, y ) {
        

        if ( deCarta.String.isString(message) ) {
            // The old method, which we support, is to pass in the message
            // as a string.
            _copyright = new deCarta.CopyrightMessage( message );
        } else {
            // 4.4.1 allow an object to be passed in, assume the correct
            // object is passed in.
            _copyright = message;
        }

        // finally add completed copyright to the map
        self.addMapControl( _copyright );

        // 4.4.1 Keep this for backwards compatibility, and to discourage
        // use I keep it almost exactly as I found it.
        if(x && y){
            // 4.4.1 We override the position function here to prevent it
            // from operating when called
            _copyright.position = function(){};
            _copyright.frame.style.top = y + _px;
            _copyright.frame.style.left = x + _px;
        }
    };



    ////----------------------------------------------------------------------------
    // Group: Map Centering and Recentering (aka. first draw)
    ////----------------------------------------------------------------------------


    /**
     * Get a 16 chr hash containing the map center and zoom
     * This can later be used to restore a specific map position
     * for example through a url
     */
    this.getViewHash = function(){

       function zeropad(s, l){
           while (s.length < l) s = '0'+s;
           return s;
       }

        var z = _zoom.getZoomLevel();
        var pos = self.getCenterPosition();

        var clat = zeropad(this._n2s(Math.round((90 + pos.getLat()) * 10000)), 5);
        var clon = zeropad(this._n2s(Math.round((180 + pos.getLon()) * 10000)), 5);
        var czoom = zeropad(this._n2s(z), 1);

        return czoom+clat+clon;

    }
    /**
     * Restore a view from a 16-chr hash
     *
     */
    this.restoreViewFromHash = function(hash){

        var data = self.parseViewHash(hash);
        if (!data) return;
        self.zoomMap(data.zoom);
        self.panToPosition(data.center, function(){}, true);
    }

    /**
     *
     * Parse a 16 chr hash and return info
     *
     */

    this.parseViewHash = function(hash){
       /* if (hash.length != 16) {
            return;
        }*/
        try {
            var zoom = this._s2n(hash.substr(0,1));
            var lat = (this._s2n(hash.substr(1,5))  / 10000) - 90;
            var lon = (this._s2n(hash.substr(6,5))  / 10000) - 180;

            if (isNaN(zoom) || isNaN(lat) || isNaN(lon)) {                
                return false;
            }

            var p = new Position(lat, lon);
        } catch (e) {
            return false;
        }

        return {zoom: zoom, center: p};
    }

    /**
     * @private binary base64 encode
     */
    this._n2s = function(num){
        var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-=";
        var res = '';

        while (num > 0){
            var n = num % 64;
            num = num >> 6;            
            res = chars.charAt(n) + res;
        }

        return res;
    }

    /**
     * @private binary base64 decode
     */
    this._s2n = function(str){

        var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-=";
        var res = 0;

        for (var i = 0; i < str.length; i++){
            var c = str.charAt(i);
            var n = chars.indexOf(c);
            res = (res << 6) + n;            
        }

        return res;
    }

    /**
     * Center the Map on a specific Position. This function initializes a map,
     * which is required for using certain other functions, like
     * {@link Map#addPin}. Once a map is drawn, it is more proper to use
     * {@link Map#panToPosition} to perform casual recentering of a Map. This
     * function will mainly be used after geocoding an address with a Geocoder
     * object.
     * <p>Calling centerOnPosition is an asynchronous request made to the DDS
     * Web Services. Immediate interactions with the map (like adding a Pin)
     * can be safely performed within a callBack function that can be passed
     * into centerOnPosition. The application should provide a callBack function
     * that has the following prototype:</p>
     * <p><code>function callBack(centerPosition)</code></p>
     * <p>where</p>
     * <ul>
     * <li>callback = Arbitrary function name</li>
     * <li>centerPosition = A Position object that marks the center point of the
     * map, or null if there was an error creating the map.</li>
     * </ul>
     * @param {Position} position required The Position to center the Map on.
     * @param {function} callBack optional A callback function to catch the
     * Position that the map is centered on.
     * @param {String} trafficTime optional Used with predictive traffic to
     * generate a view of traffic at a specific time. Note: You must be
     * accessing a DDS Web Services set-up with predictive traffic data.
     * @param {boolean} panMapOverview indicate whether should pan the map overview
     * instead of centerOnPosition directly.
     * @see Position
     * @see Geocoder
     */
    this.centerOnPosition = function(position, callBack, trafficTime, panMapOverview) {
        
        // Prevent possible problems from people passing in an obj.pos.
        //move the following 3 action to the callback, 09/12/03
        //_centerPosition = position.clone();
        //populateTiles();
        //self.hidePinsBeforeZoom();
        var requestId = Utilities.getRequestId();
        if( typeof callBack == 'function'){
            _callBackArray[requestId] = callBack;
        } else {
            // Callback is optional
            _callBackArray[requestId] = null;
        }

        // 4.3.4
        // Internally backwards incompatible change. Initial map grid size
        // is one tile. The response handler _must_ call the new updateUrlList
        // to out-fill the remaining tiles. createMapRequestDOM assumes
        // single tile generation.
        //mobile-dev
        //(pos, tileSize, requestId, referenceZoomLevel, newZoomLevel, trafficTime, sessionId)
        var mapReqId = Utilities.getRequestId();
        //var xml = _xmlRecFac.createMapRequest(position, _tileSize, requestId, _zoom.getZoomLevel(), null, trafficTime, mapReqId);
        var xml = _xmlRecFac.createMapRequest(position, _tileSize, requestId, _zoom?_zoom.getZoomLevel():5, null, trafficTime, mapReqId);
        //JSRequest.send(xml, centerOnPositionCallback);

        JSRequest.send(xml, function(data){
            _centerPosition = position.clone();
            populateTiles();
            self.hidePinsBeforeZoom();

            centerOnPositionCallback(data);
        },null,function(id){
            _callBackArray[id]=undefined;
        });

        if(_mapOverviewController && _mapOverviewController.frame && !panMapOverview)
            _mapOverviewController.centerOnPosition(position);
        else if(_mapOverviewController && _mapOverviewController.frame && panMapOverview)
            _mapOverviewController.panToPosition(position);
    }

    /**
     * Once the map has been initialized, use this function to recenter the
     * map. If the coordinate to pan to is close by, the map will pan
     * smoothly. Only when the coordinate passed in is too far away will the
     * map refresh. Smooth panning provides a better user experience.
     * @param {Position} pos required The new location that will be
     * panned to. This will become the new center point of the map.
     * @param {function} callBack optional A reference to a function to be
     * called after the panToPosition animation has completed. The argument
     * passed to the callBack will be the final position.
     * @param {boolean} instantaneous moves to the position immediately without animation
     * @see Map#centerOnPosition
     */
    this.panToPosition = function( pos, callBack, instantaneous) {
        

        var position = pos.clone();

        // get current center in GX pix
        var cPos = self.getCenterPosition();
        var c = this.posToMercPix( cPos );
        // get the new position in GX pix
        var c2 = this.posToMercPix( position );
        // this is the pixel difference
        var pix = new PixelPoint( Math.round(c.x-c2.x), Math.round(c.y-c2.y) );
        

        // Determine whether to slide or teleport
        if(_centerPosition && _zoom.getRadius()){
            var bbox = Utilities.centerContextToBoundingBox(cPos, _zoom.getRadius());
            if( bbox.extendedContains(position) ){
                // (4.4.1 Notes)
                // Allow registration of a pan to position callback
                // We cheat and use the _callBackArray as an object, no error checking
                // callBack will execute within the slide function
                if( typeof callBack == 'function'){
                    _callBackArray["panToPosition"] = callBack;
                }
                else {
                    // Callback is optional
                    _callBackArray["panToPosition"] = null;
                }

                if( pix.x == 0 && pix.y == 0 ) {
                    // no movement, quit out but call callback first
                    if ( _callBackArray["panToPosition"] ) {
                        _callBackArray["panToPosition"]( self.getCenterPosition() );
                        _callBackArray["panToPosition"] = undefined;
                    }
                    return;
                }
                else {
                    if (instantaneous){
                        _mapDivX += pix.x;
                        _mapDivY -= pix.y;;
                        _deltaX += pix.x;
                        _deltaY -= pix.y;                        
                        move(_mapDivX, _mapDivY);
                        rotateTiles();
                    }else {
                        slider( pix.x, -1*pix.y );
                    }
                    if(_mapOverviewController && _mapOverviewController.frame){
                        _mapOverviewController.panToPosition(position);
                    }
                }
            }
            else {
                // (4.4.1 notes continued)
                // Otherwise we just pass callBack to centerOnPosition
                // callBack should be falsey (probably undefined) or a function.
                // no error checking
                this.centerOnPosition(position, callBack, null, true);
            }
        }
        else{
            this.centerOnPosition(position, callBack, null, true);
        }

    }

    /**
     * Retrieves the current center position coordinates of the map.
     * @throws {Exception} If the map has not been initialized, a "Center
     * Position not set" exception is thrown.
     * @return {Position} Position The latitude and longitude coordinate
     * center of the map.
     */
    this.getCenterPosition = function() {
        
        if(!_centerPosition){
            throw new Exception("Center Position not set");
        }
        

        // 4.3.4 We now rely that _centerPosition to be the true center point of
        // the map, not the fixed grid center of the map.
        // The logic of the calculations for future reference and debugging:
        // if diff of _mapDivX and _mapDivY and _fixedGridPixelOffset are equal,
        // the map hasn't moved, return _centerPosition.
        // If there is a difference, the map has moved, return the recalculated
        // offset.
        //var pixelDiffX = _mapDivX - _mapDivXorigin + _fixedGridPixelOffset.x;
        //var pixelDiffY = _mapDivY - _mapDivYorigin + _fixedGridPixelOffset.y;
        var pixelDiffX = _mapDivX - _mapDivXorigin;
        var pixelDiffY = _mapDivY - _mapDivYorigin;
        if(pixelDiffX == 0 && pixelDiffY == 0) {
            // no movement, return the true _centerPosition
            return _centerPosition;
        }
        // Else we've moved, find the original center position
        var cpix = self.posToMercPix( _centerPosition );
        // add together and send to pix2pos
        cpix.x -= pixelDiffX;
        cpix.y += pixelDiffY;

        var currentCenter = self.mercPixToPos( cpix );
        return currentCenter;
    }

    ////----------------------------------------------------------------------------
    // Group: Info Window
    ////----------------------------------------------------------------------------

    /**
     * Display {@link Pin} message information within a custom made
     * {@link InfoWindow}.
     * When a Pin is added to a map, it will often have associated
     * information to display to a user. This information is displayed within
     * an InfoWindow object. If no InfoWindow is associated with a Map
     * object, a simple default will be used. To override the default, use this
     * method to tell the Map object to display information in the custom made
     * InfoWindow instead. NOTE: A map object can only have one custom
     * InfoWindow attached to it at a time. To switch InfoWindows, pass a
     * different InfoWindow object to this method.
     * @param {InfoWindow} infoWindow required A custom InfoWindow object.
     * @see InfoWindow
     * @see Pin
     */
    this.addCustomInfoWindow = function( infoWindow ) {
        
        if( _mapArrayDiv && _bubble ){
            _mapArrayDiv.removeChild(_bubble.bubble);
        }
        // Store the new InfoWindow
        _bubble = infoWindow;
        // Add to the map if the map has been initialized
        if( _mapArrayDiv ) {
            _mapArrayDiv.appendChild( _bubble.bubble );
        }
        
        infoWindow.map=self;
    };

    /**
     * Retrieve the InfoWindow current associated with this map.
     * Allows access to the default InfoWindow created by the Map object if
     * none has been added through {@link Map#addCustomInfoWindow}.
     * @return {InfoWindow} the current InfoWindow associated with this map, or
     * null if the InfoWindow has not yet been created.
     */
    this.getInfoWindow = function(){
        
        var infoWin = _bubble || null;
        return infoWin;
    };


    ////----------------------------------------------------------------------------
    // Group: Pin
    ////----------------------------------------------------------------------------

    /**
     * Takes a Pin object as an argument, adds the pin to the map and centers
     * on that pin.
     * @param {Pin} pin required A defined pin object.
     * @throws {Exception} If the Pin is empty, or the Position associated
     * with the Pin is invalid, an exception will be thrown.
     * @see Pin
     */
    this.addAndCenterOnPin = function(pin) {
        
        this.addPin(pin);
        this.panToPosition(pin.position);
    }


    /**
     * Overlays a Pin object onto a map. The Map must have been initialized
     * with a {@link Map#centerOnPosition} call.
     * @param {Pin} pin required
     * @throws {Exception} If the Map has not yet been initialized, an
     * "Error adding Pin..." message will be thrown.
     * @see Pin
     * @see Map#centerOnPosition
     */
    this.addPin = function( pin ) {
        

        if( _centerPosition == null ) {
            throw new Exception("Error adding Pin, you can not add a pin until the center Position is set. Please use the callback of map.centerPosition().");
        }

        // set a reference from map -> pin...
        try {
            // By the way, I don't agree with this, but technically having
            // addPin throw an error is backwards incompatibile, and so
            // I wrap a try catch block around this
            _pinList.add(pin);
        } catch(e) {
            // silently return
            
            return;
        }
        // ...set a reference from pin -> map...
        pin.map = self;
        // ...set the pixel position of the pin...
        pin.setPosition( pin.position );
        // ...add the pin to the map layer...
        _mapArrayDiv.appendChild( pin.pinImg );
        // ...and add overlay text, if any.
        if ( pin.pinTxt ) {
            _mapArrayDiv.appendChild( pin.pinTxt );
        }
    }

    /**
     * Retrieve all of the Pins that have been added to the Map.
     * @return {Array} An array containing all Pin objects that have
     * been added to the map.
     * @see Pin
     * @see Map#addPin
     */
    this.getPins = function(){
        
        return _pinList.returnAsArray();
    }
    /**
     * Retrieve a pin that is associated with the map by the pin id.
     * @param {String} id
     * @see Pin
     * @see Map#addPin
     */
    this.getPinById = function(id){
        
        var pin=null;
        _pinList.operateOnData( function(thisPin) {
            if ( !thisPin ) return null;
            if (thisPin.getId()==id)
                pin = thisPin;
        });
        return pin;
    }

    /**
     * Hides all Pins that are currently attached to the Map. This function
     * does not remove any instances of Pins, it merely hides them from view.
     * @see Pin
     * @see Map#addPin
     * @see Map#removeAllPins
     * @see Map#removePin
     */
    this.hidePins = function(){
        
        // operateOnData passes each pin in the list to this function
        _pinList.operateOnData( function(thisPin) {
            if ( !thisPin ) return;
            thisPin.pinImg.style.display = "none";
            thisPin.pinTxt.style.display = "none";
        });
    }

    /**
     * Shows all pins that have already been added to the Map. This will unhide
     * any pins that have been previously hidden.
     * @see Pin
     * @see Map#addPin
     * @see Map#hidePins
     */
    this.showPins = function(){
        
        // operateOnData takes an anonymous function that works directly on
        // the pin
        _pinList.operateOnData( function(thisPin) {
            thisPin.pinImg.style.display = "block";
            thisPin.pinTxt.style.display = "block";
        });
    }

    /**
     * Removes, and destroys, all Pins that have been added to the Map. If Pins
     * will be reused, it may be  more convenient to hide them.
     * @throw {Exception} If there is a problem removing the pins, throw an
     * "Error removing all pins" exception.
     * @see Pin
     * @see Map#addPin
     * @see Map#hidePins
     */
    this.removeAllPins = function() {
        
        var pinToDelete;  // Catches the pins we wish to nullify

        // Cycle through each pin in the list, nullify and remove pin from
        // existence
        while ( _pinList.length > 0 ) {
            pinToDelete = _pinList.remove();
             pinToDelete.destroy();
        }
    }

    /**
     * Removes, and destroys, a specific Pin object that has been added to
     * the map. If Pins will be reused, it may be more convenient to hide
     * them.
     * @param {Pin} pin required The Pin to remove from the map that was
     * previously added.
     * @see Pin
     * @see Map#addPin
     * @see Map#hidePins
     */
    this.removePin = function(pin) {
        
        var pinToDelete = null;
        try {
            pinToDelete = _pinList.remove(pin);
        }
        catch (e1) {
            // Return silently here since users can pass in bad pins.
            // JO: DEBUG: Should have some debug statement here.
            return;
        }

        if ( !pinToDelete ) {
            return;
        }
        pinToDelete.destroy();
    /*
        if ( pinToDelete.pinTxt ) {
            Utilities.purge(pinToDelete.pinTxt);
            _mapArrayDiv.removeChild(pinToDelete.pinTxt);
            pinToDelete.pinTxt=null;
        }
        Utilities.purge(pinToDelete.pinImg);
        _mapArrayDiv.removeChild(pinToDelete.pinImg);
         */
    }

    /**
     * Removes, and destroys, the first Pin with a specific id.  This
     * performs better than removePinsById since it short circuits once it
     * matches the ID.  Useful when you have unique ID's.
     * @param {String} id required Pins matching this id will be removed.
     * @see Pin
     * @see Map#hidePins
     */
    this.removePinById = function(id){
        
        // The id property must be called by string reference here
        try {
            var pinToDelete = _pinList.removeById( "id", id );
        }
        catch(e) {
            // To support backwards compatibility, it is possible to
            // pass in bad or null ids. In that case, we just return.
            // JO: DEBUG: Should have some debug statement here.
            return;
        }
        if ( !pinToDelete ) {
            // It is also possible to grab a null value. Return here, too.
            return;
        }
        if ( pinToDelete.pinTxt ) {
            Utilities.purge(pinToDelete.pinTxt);
            _mapArrayDiv.removeChild(pinToDelete.pinTxt);
            pinToDelete.pinTxt=null;
        }
        Utilities.purge(pinToDelete.pinImg);
        _mapArrayDiv.removeChild(pinToDelete.pinImg);

    }

    /**
     * Removes, and destroys, all Pins with a specific id value that have
     * been added to the map. If Pins will be reused, it may be more
     * convenient to hide them.
     * @param {String} id required Pins matching this id will be removed.
     * @see Pin
     * @see Map#hidePins
     */
    this.removePinsById = function(id){
        
        var pinsToDelete = null;
        var numToDelete = null;
        var i; // Counter

        try {
            // need to pass the hash "id" in as a string
            pinsToDelete = _pinList.removeByKey("id", id);
        }
        catch(e) {
            // To support backwards compatibility, it is possible to
            // pass in bad or null ids. In that case, we just return.
            // JO: DEBUG: Should have some debug statement here.
            return;
        }
        // We might still be null, exit out if so
        if ( !pinsToDelete ) {
            return;
        }
        for ( i = 0, numToDelete = pinsToDelete.length; i < numToDelete; i++ ) {
            if ( pinsToDelete[i].pinTxt ) {
                Utilities.purge(pinsToDelete[i].pinTxt);
                _mapArrayDiv.removeChild(pinsToDelete[i].pinTxt);
                pinsToDelete[i].pinTxt=null;
            }
            Utilities.purge(pinsToDelete[i].pinImg);
            _mapArrayDiv.removeChild(pinsToDelete[i].pinImg);
        }
    }

    ////----------------------------------------------------------------------------
    // Group: Event handling
    ////----------------------------------------------------------------------------
    /**
     * Used to turn on (or turn back off) the ability to 'flick' a map by
     * click-and-dragging. By default click-and-drag easing is off.
     * @param {boolean} enabled required (default) 'true' to enable,
     * 'false' to turn this feature off.
     * @throw {Exception} Throws an exception if a boolean value is not
     * passed in.
     */
    this.setDragEasingEnabled = function(enabled){
        
        _dragEasingEnabled=enabled;
    }

    /**
     * Used to turn off (or turn back on) the ability to pan a map by
     * click-and-dragging. By default click-and-drag panning is on.
     * @param {boolean} enabled required (default) 'true' to enable,
     * 'false' to turn this feature off.
     * @throw {Exception} Throws an exception if a boolean value is not
     * passed in.
     */
    this.setDragEnabled = function(enabled){
        
        if(! 'boolean' == (typeof enabled)) {
            throw new Exception("Map.setDragEnabled requires boolean");
        }
        _draggingEnabled=enabled;
    }


    /**
     * Used to turn on (or turn back off) the ability to right click and drag
     * to draw a new bounding region to zoom into.
     * @param {boolean} enabled required (default) 'true' to enable,
     * 'false' to turn this feature off.
     * @throw {Exception} Throws an exception if a boolean value is not
     * passed in.
     */
    this.setRightClickBBoxZoomEnabled = function(enabled){
        
        if(! 'boolean' == (typeof enabled)) {
            throw new Exception("Map.setRightClickBBoxZoomEnabled requires boolean");
        }
        _rightClickBBoxZoomEnabled=enabled;
    }


    /**
     * Used to turn off (or turn back on) universal shape clipping.
     * This feature should not be used unless absolutely necessary as it
     * can cause a slow down in performance.
     * @param {boolean} enabled required (default) 'true' to enable,
     * 'false' to turn this feature off.
     * @throw {Exception} Throws an exception if a boolean value is not
     * passed in.
     * @see DDSLine#setClip
     * @private
     */
    this.setShapeClippingEnabled = function(enabled){
        
        if( !'boolean' == (typeof enabled) ) {
            throw new Exception("Map.setShapeClippingEnabled requires boolean");
        }
        _clipShapes = enabled;
    };

    /**
     * Used to turn off (or turn back on) the ability to center a map
     * wherever the mouse is double-clicked. By default, double-clicking a
     * map will recenter the view on the double-click. Turning this off can
     * be useful if you wish to modify or enhance the behavior of the
     * double-click event on a map.
     * @param {boolean} enabled required (default) 'true' to enable,
     * 'false' to turn this feature off.
     * @throw {Exception} Throws an exception if a boolean value is not
     * passed in.
     * @see EventRegistry
     * @see Map#setDoubleClickRecenterAndZoom
     */
    this.setDoubleClickRecenteringEnabled = function(enabled){
        
        if(! 'boolean' == (typeof enabled)) {
            throw new Exception("Map.setDoubleClickRecenteringEnabled requires boolean");
        }
        _doubleClickRecenteringEnabled = enabled;
    };

    /**
     * Used to turn on (or turn back off) the ability to recenter a map,
     * followed by a zoom in of one level, wherever the mouse is double-
     * clicked. By default, this functionality is turned off.
     * @param {boolean} enabled required 'true' to enable, (default) 'false'
     * to turn this feature off.
     */
    this.setDoubleClickRecenterAndZoom = function(enabled){
        
        if( enabled ) {
            _dbclickZoom = true;
        } else {
            _dbclickZoom = false;
        }
    };

    /**
     * Used to turn on (or turn back off) the digital zoom ability.
     * By default, this functionality is turned on.
     * @param {boolean} enabled required 'true' to enable, (default) 'false'
     * to turn this feature off.
     */
    this.setDigitalZoomEnabled = function(enabled) {
        
        if( enabled ) {
            _digitalZoom = true;
        } else {
            _digitalZoom = false;
        }
    };

    /**
     * Enable or disable the fade effect on tiles when they are loaded or
     * first displayed.
     * @param {boolean} set to true to enable fading (default : true)
     */
    this.setTileFadingEnabled = function(enabled) {
        
        _mapTileFading = enabled;
    };

	this.getTileFading = function(){
		return _mapTileFading;
	}


    /**
     * Enable or disable the mouse scroll wheel zoom
     * @param {boolean} set to true to enable wheel zoom (default : false)
     */
    this.setWheelZoomEnabled = function(enabled) {
        
        _wheelZoom = enabled;
    };

    /**
     * Set the delay between animated map pan frames in milliseconds.
     * @param {number} [timeoutDelay=37] Number of milliseconds between each
     * frame of a map pan. The default of 37 equates to ~27 frames a second.
     */
    this.setPanTimeoutDelay = function(timeoutDelay) {
        
        _mapPanTimeoutDelay = timeoutDelay || 37;
    };

    ////----------------------------------------------------------------------------
    // Group: Overlay
    ////----------------------------------------------------------------------------


    /**
     * Adds a shape to the map. If {@link Map#setShapeRendering} is set to
     * "client" the shape will be drawn immediately. If
     * {@link Map#setShapeRendering} is set to "server" the shape will be
     * queued up to draw on the next map refresh. If using server side
     * rendering for shapes, it is best to pass every shape to addOverly and
     * then make one map refresh call rather than refreshing the map each time
     * addOverlay is called. If using client side rendering, it is better to
     * pass in an Array containing all overlays so as not to force a redraw
     * for every shape.
     * @param {object} overlay required Method can take either a single DDSShape
     * derived object, or the method can take an array of DDSShape derived
     * objects. Whether or not an array is passed in as an arg, the function
     * assumes all objects, or array elements, are valid DDSShapes.
     * @see DDSShape
     * @see Map#reDrawMap
     */
    this.addOverlay = function( overlay ) {
        
        if(!overlay) return;
        if (deCarta.Array.isArray(overlay)) {
            // Array of overlays
            var numOverlays = overlay.length;
            for ( var i = 0; i < numOverlays; i++ ) {
                overlay[i].map = self;
                _xmlRecFac.overlays.push(overlay[i]);
                this.drawShape(overlay[i]);
            }
        }
        else {
            // A single overlay object
            overlay.map = self;
            _xmlRecFac.overlays.push(overlay);
            this.drawShape(overlay);
        }
    // Draw only after all overlays have been added
    //draw();


    };



    /**
     * function to draw single shape
     * @param {DDSShape} shape
     * @param {boolean} noCanvasCheck If true, then it will draw without checking if canvas changed. This is
     * used by map's internal function drawShape(shape,true). Normally we can ignore this parameter.
     *
     *
     */
    this.drawShape = function(shape, noCanvasCheck){
        
        if( !(shape instanceof  DDSShape)) return ;
        if (shape.rendering == "server" || (_rendering == "server" && shape.rendering != "client")) {
            // Skip this shape if we shouldn't render it
            return ;
        }

        if ( !shape.isVisible ) {
            // 4.4.1 account for hidden shapes by skipping them
            return ;
        }
        // Reasons not to draw the canvas
        if(!self.getTileDiv()) return ;

        var paper=_raphael_paper;
        if(!paper){
            _raphael_paper=paper=constructRaphaelPaper() ;

        }


        var newCanvasBbox=self.getBoundingBox();
        var bbox=paper.bbox;

        if(!noCanvasCheck && needResetCanvas(shape,newCanvasBbox,bbox)){
            draw();
            return;
        }

        if(shape.raphael_element) shape.raphael_element.remove();

        // We use this in multiple places
        var currentZoomLevel = _zoom.getZoomLevel();
        // Scaling for Mercator Pixel math
        var sl = Utilities.radsPerPixelAtZoomLevel(_tileSize, currentZoomLevel);

        var posTR = new Position(bbox.maxPosition.lat+" "+bbox.minPosition.lon);
        var trY = Math.round(Utilities.lat2pix(posTR.lat, sl));
        var trX = Math.round(Utilities.lon2pix(posTR.lon, sl));

        var borderColor="rgb("+shape.borderColorRed+","+shape.borderColorGreen+","+shape.borderColorBlue+")";
        var fillColor="rgb("+shape.fillColorRed+","+shape.fillColorGreen+","+shape.fillColorBlue+")";
        var fillOpacity=shape.fillOpacityFloat;
        var borderWidth=shape.getBorderWidth();
        var strokeOpacity=shape.strokeOpacityFloat;

        var ele=null;

        var mercPixels = [];
        //------------------------------------------------ Begin Drawing
        //            ctx.beginPath();
        // * ******************* POLYGON or LINE
        if(shape.type == "polygon" || shape.type == "line"){
            // Stores converted Canvas pixels, see below for why
            var path="";
            var canvasPixX = [];
            var canvasPixY = [];

            // Line specific things
            if ( shape.type == "line" ) {
                //ctx.lineWidth = shape.getWidth();
                borderWidth=shape.getWidth();
                fillColor="none";
                // Is clipping turned on for this line
                if ( shape.clip || _clipShapes ) {
                    // The clipping will return a two-dimensional array
                    mercPixels = shape.getMercPixelsClipped( currentZoomLevel, _tileSize, bbox );
                }
                else {
                    // getMercPixels returns only a single dimensional array
                    mercPixels[0] = shape.getMercPixels(currentZoomLevel, _tileSize);
                }
            }
            else if (shape.type == "polygon") {
                // We must work in mercator pixels for screen coordinate conversion
                // getMercPixels returns only a single dimensional array
                mercPixels[0] = shape.getMercPixels(currentZoomLevel, _tileSize);
            }
            else {
                throw new Exception ("Map inner function draw: fell through to unacceptable situation with line/polygon client side rendering.");
            }

            //from the distance of the two boundingbox tell the direction of the line between point and ul corner of bbox
            var halfEarthMercX=Math.round(Utilities.lon2pix(180, sl));
            var bboxShape=shape.getBoundingBox();
            var bboxDistance=bbox.minPosition.lon-bboxShape.minPosition.lon;


            // As usual, I curse IE. Because the Canvas specification a
            // path is only required to keep state until stroke OR fill
            // is called. The ExplorerCanvas implementation of Canvas for
            // Internet Explorer sticks to the specification to the letter,
            // whereas it appears that Mozilla hasn't. To be able to both
            // stroke and fill a shape in IE, we must trace the polygon
            // twice, once for fill and once for stroke.
            // 4.4.2 we take into account that we might need to perform clipping
            // on lines, and maybe in the future polygons on the client side
            // to skirt problems with Canvas in Firefox and IE.
            // This shouldn't be a problem, clipped lines come back as an array
            // of arrays. If the array of arrays contains only 1 element in
            // the first dimension, we'll draw as normal.
            var numMercClippings = mercPixels.length;

            for( var i = 0; i < numMercClippings; i++ ) {
                // One for each clipping
                var numMercPixels = mercPixels[i].length;
                // Create additional additional arrays for IE future handling
                // of polygon clipping, if it is necessary.
                canvasPixX[i] = [];
                canvasPixY[i] = [];
                for ( var j = 0; j < numMercPixels; j++ ) {
                    var p = mercPixels[i][j];
                    // Store just in case this is IE
                    canvasPixX[i][j] = parseInt(trX - p.x);
                    if(bboxDistance>180) canvasPixX[i][j]=canvasPixX[i][j]-2*halfEarthMercX;
                    else if(bboxDistance<(-180)) canvasPixX[i][j]=canvasPixX[i][j]+2*halfEarthMercX;
                    //if(canvasPixX[i][j]>halfEarthMercX) canvasPixX[i][j]=canvasPixX[i][j]-2*halfEarthMercX;
                    //else if(canvasPixX[i][j]<(-halfEarthMercX)) canvasPixX[i][j]=canvasPixX[i][j]+2*halfEarthMercX;
                    canvasPixY[i][j] = parseInt(trY - p.y);
                    // Place pen at the first point on the canvas
                    if (j == 0) {
                        //ctx.moveTo((canvasPixX[i][j]*-1), (canvasPixY[i][j]));
                        path+="M "+canvasPixX[i][j]*-1+" "+canvasPixY[i][j]+" ";
                    }else{
                        // Connect from previous point
                        //ctx.lineTo((canvasPixX[i][j]*-1), (canvasPixY[i][j]));
                        path+="L "+canvasPixX[i][j]*-1+" "+canvasPixY[i][j]+" ";
                    }
                }
            }
            if(shape.type=="polygon") path+="z";

            ele=paper.path(path);


        // * ******************* CIRCLE
        } else if(shape.type=="circle"){


            var pos = shape.getPosition();
            var pY = Math.round(Utilities.lat2pix(pos.lat,sl));
            var pX = Math.round(Utilities.lon2pix(pos.lon,sl));
            var ex=parseInt(trX-pX);
            var ey=parseInt(trY-pY);

            var r = shape.getRadius().getDegrees();
            var rY = Math.round(Utilities.lat2pix(pos.lat+r,sl));
            var ry=parseInt(rY-pY);
            ele=paper.circle(-ex,ey,ry);



        }
        ele.attr({
            stroke: borderColor,
            fill: fillColor,
            "fill-opacity":fillOpacity,
            "stroke-width":borderWidth,
            "stroke-opacity":strokeOpacity
        });

        for(var ev in shape.eventListenerMap){
            if(shape.eventListenerMap.hasOwnProperty(ev)){
                if(typeof (shape.eventListenerMap[ev]) == 'function'){
                    ele.node[ev]= function(e){
                        e = e ? e : window.event;
                        var s=this.raphael.owner_shape;
                        var eType=e.type;
                        eType='on'+eType;
                        var func=s.eventListenerMap[eType];
                        func(s);
                    };
                }

            }
        }
        ele.owner_shape=shape;
        if(shape.passEventToMap){
            deCarta.IdManager.setTag( ele.node, "ignoreForMapEvents", false);
        }else{
            deCarta.IdManager.setTag( ele.node, "ignoreForMapEvents" );
        }
        shape.raphael_element=ele;

    //tell if the shape cross or out of canvas



    }

    /**
     * Return an array object containing references to all DDSShape objects
     * currently added to this map. If you wish to remove objects, take the
     * object reference from the array
     * and pass it back to the {@link Map#removeOverlay}. If you modify the
     * shape or style of any objects, make sure to call the respective redraw
     * function for the type of shape rendering your application uses:
     * {@link Map#redraw} for client side rendering and {@link Map#reDrawMap} for
     * server side shapes.
     * You may dispose of the array when you are complete, the Map instance will
     * retain it's reference to the overlays.
     * @returns {Array} contains all overlay objects that have been added
     * to the map. Array will be empty (length 0) if no overlays are associated
     * with the map.
     */
    this.getOverlays = function() {
        
        var overlaysArray = [];
        var numOverlays = _xmlRecFac.overlays.length;
        for ( var i = 0; i < numOverlays; i++ ) {
            overlaysArray[i] = _xmlRecFac.overlays[i];
        }
        return overlaysArray;
    };

    this.getOverlayById = function(id){
        for ( var i = 0; i < _xmlRecFac.overlays.length; i++ ) {
            if(_xmlRecFac.overlays[i] && _xmlRecFac.overlays[i].id==(id)) {
                return _xmlRecFac.overlays[i];

            }
        }
        return null;
    }

    /**
     * Remove a shape from the map. If {@link Map#setShapeRendering} is set to
     * "client" the shape will be removed immediately. If
     * {@link Map#setShapeRendering} is set to "server" the shape will be queued
     * up to be removed on the next map refresh. If using server side rendering
     * for shapes, it is best to pass every shape to removeOverlay and then make
     * one map refresh call rather than refreshing the map each time
     * removeOverlay is called.
     * @param {DDSShape} overlay required The DDSShape object (or one of the
     * extended objects) to be removed from the map.
     * @see DDSShape
     * @see Map#reDrawMap
     */
    this.removeOverlay = function( overlay ) {
        
        if(!overlay) return;
        overlay.map = null;
        var tmp = new Array();
        for ( var i = 0; i < _xmlRecFac.overlays.length; i++ ) {
            if ( _xmlRecFac.overlays[i] && !_xmlRecFac.overlays[i].equals(overlay) ) {
                tmp.push(_xmlRecFac.overlays[i]);
            }
        }
        _xmlRecFac.overlays = tmp;

        if(overlay.raphael_element) overlay.raphael_element.remove();
        overlay.raphael_element=null;
    //4.3.1sp01
    //        if ( tmp.length == 0 ) {
    //            draw(true);
    //        }
    //        else {
    //            draw();
    //        }
    };

    /**
     * Removes a shape of specific id from a map. If
     * {@link Map#setShapeRendering} is set to "client" the shape will be
     * removed immediately. If {@link Map#setShapeRendering} is set to "server"
     * the shape will be queued up to be removed on the next map refresh.
     * @param {String} id required The id of the shape to remove.
     * @see DDSShape
     * @see Map#reDrawMap
     */
    this.removeOverlayById = function( id ) {
        
        var tmp = new Array();
        for ( var i = 0; i < _xmlRecFac.overlays.length; i++ ) {
            if( _xmlRecFac.overlays[i] && _xmlRecFac.overlays[i].id != (id) ) {
                tmp.push( _xmlRecFac.overlays[i] );
            } else if(_xmlRecFac.overlays[i] && _xmlRecFac.overlays[i].id==(id)) {
                _xmlRecFac.overlays[i].map = null;
                if(_xmlRecFac.overlays[i].raphael_element){
                    _xmlRecFac.overlays[i].raphael_element.remove();
                    _xmlRecFac.overlays[i].raphael_element=null;
                }

            }
        }
        _xmlRecFac.overlays = tmp;
    //4.3.1sp01
    //        if ( tmp.length == 0 ) {
    //            draw(true);
    //        }
    //        else {
    //            draw();
    //        }
    };

    /**
     * Remove all shapes from a map. If {@link Map#setShapeRendering} is set to
     * "client" all shapes will be removed immediately. If
     * {@link Map#setShapeRendering} is set to "server" all shapes will be
     * queued up to be removed on the next map refresh.
     * @see DDSShape
     * @see Map#reDrawMap
     */
    this.removeAllOverlays = function() {
        
        if (_xmlRecFac==null || _xmlRecFac.overlays==null || (_xmlRecFac.overlays.length <= 0) )  {
            return;
        }
        // else actually perform a redraw and page refresh
        for ( var i = _xmlRecFac.overlays.length-1; i >=0; i-- ) {
            var overlay=_xmlRecFac.overlays[i];
            if(overlay.eventListenerMap){
                overlay.eventListenerMap["onclick"]=null;
            }
            if(overlay.raphael_element){
                overlay.raphael_element.owner_shape=null;
                if(overlay.raphael_element.node){
                    overlay.raphael_element.node["onclick"]=null;
                }
                overlay.raphael_element.remove();
            }
            overlay.raphael_element=null;
            _xmlRecFac.overlays[i]=null;
        }
        _xmlRecFac.overlays=[];
        draw(true);
    };

    /**
     * Sets a RouteID string, retrieved from a successful query with a
     * {@link RouteQuery} object, to be overlaid on map tiles as a server
     * side drawn shape. The route will only be drawn when the map
     * is set draw shapes on the server side.
     * NOTE: Do not attempt to use a made up RouteID. Do not taunt RouteID.
     * Do not puncture RouteID. Use only a deCarta approved RouteID.
     * @private
     * @param {string} routeID required The RouteID to be added as a overlay.
     */
    this.addRouteIDOverlay = function( routeID ) {
        
        _xmlRecFac.routeIDOverlay = routeID;
    };

    /**
     * Removes a RouteID string from the list of items that are overlaid on
     * map tiles as a server side drawn shape.
     * NOTE: Do not attempt to use a made up RouteID. Do not taunt RouteID.
     * Do not puncture RouteID. Use only a deCarta approved RouteID.
     * @private
     */
    this.removeRouteIDOverlay = function() {
        
        _xmlRecFac.routeIDOverlay = null;
    };

    /**
     * Sets the map object to render shapes on either the client side or (by
     * default) on the server side. When the server draws the shapes, the shapes
     * will be drawn directly on the map tiles. When the map object draws the
     * shapes on the client side, the shapes can be dynamically redrawn without
     * redrawing the entire map.
     * @param {String} style required Valid arguments are 'client' or 'server'
     * @see DDSShape
     */
    this.setShapeRendering = function(style){
        
        if(!style || !style=="client" || !style=="server"){
            throw new Exception("map.setShapeRendering() error: use 'client' or 'server'")
        }
        if(style=="server"){
            clear();
        }else{
            _rendering=style;
            _xmlRecFac.rendering=style;
            draw();
        }
        _rendering=style;
        _xmlRecFac.rendering=style;
    };

    /**
     * Returns the type of shape rendering that the map object is using. The
     * values are either 'client' or (default) 'server'.
     * @return {String} style either 'client' or (default) 'server'
     */
    this.getShapeRendering = function(){
        
        return _rendering;
    };

    function needResetCanvas(shape,newCanvasBbox,oldCanvasBbox){
        if(!newCanvasBbox) return false;
        if(!oldCanvasBbox) return true;
        if(oldCanvasBbox.equals(newCanvasBbox) || oldCanvasBbox.containsBoundingBox(newCanvasBbox)) return false;

        var shapeBbox=shape.getBoundingBox();
        if(oldCanvasBbox.containsBoundingBox(shapeBbox)) return false;
        var overlapOld=shapeBbox.getOverlapBoundingBox(oldCanvasBbox);
        var overlapNew=shapeBbox.getOverlapBoundingBox(newCanvasBbox);
        if(overlapNew && (!overlapOld || !overlapOld.containsBoundingBox(overlapNew))){
            return true;

        }
        else return false;



    }


   /**
     * This allows you to register a callback for when the tile grid rotates
     * either a row or column of tiles.  This is useful if you are building
     * a continuous search app where you want to refire search as the map moves.
     * You can measure movement in terms of ratios of the entire grid.
     * To remove the callback, pass in null;
     * @param {Function} callback required
     */
    this.onRotate = function( callback ) {
        _onRotateCallback=callback;
    }


    /**
     * redraw will re-render the client-side shapes on the map without
     * reloading the map.
     */
    this.redraw = function(){
        
        var needRedraw=false;
        var shapeStore = _xmlRecFac.overlays;
        if(!_raphael_paper) return;
        if(!self.getTileDiv()) return ;
        //        var newCanvasBbox=self.getBoundingBox();
        //        var oldCanvasBbox=_raphael_paper.bbox;
        //        if(oldCanvasBbox.containsBoundingBox(newCanvasBbox)) return;
        //        for (var ii = 0; ii < shapeStore.length; ii++) {
        //            // Local reference of shape in array for speedier access
        //            if(needResetCanvas(shapeStore[ii],newCanvasBbox,oldCanvasBbox)){
        //                needRedraw=true;
        //                break;
        //            }
        //
        //        }
        //
        //        if(needRedraw) draw();
        draw();
    };

    ////----------------------------------------------------------------------------
    // Group: Panning
    ////----------------------------------------------------------------------------


    /**
     * Smoothly pans the map to the west. The number of pixels panned is
     * defined by GLOBALS.PAN_PIXEL_DISTANCE.
     * @see GLOBALS#PAN_PIXEL_DISTANCE
     */
    this.panWest = function(){
        
        slider(GLOBALS.PAN_PIXEL_DISTANCE,0);
    }
    /**
     * Smoothly pans the map to the east. The number of pixels panned is defined
     * by GLOBALS.PAN_PIXEL_DISTANCE.
     * @see GLOBALS#PAN_PIXEL_DISTANCE
     */
    this.panEast = function(){
        
        slider(-GLOBALS.PAN_PIXEL_DISTANCE,0);
    }
    /**
     * Smoothly pans the map to the north. The number of pixels panned is
     * defined by GLOBALS.PAN_PIXEL_DISTANCE.
     * @see GLOBALS#PAN_PIXEL_DISTANCE
     */
    this.panNorth = function(){
        
        slider(0,GLOBALS.PAN_PIXEL_DISTANCE);
    }
    /**
     * Smoothly pans the map to the south. The number of pixels panned is
     * defined by GLOBALS.PAN_PIXEL_DISTANCE.
     * @see GLOBALS#PAN_PIXEL_DISTANCE
     */
    this.panSouth = function(){
        
        slider(0,-GLOBALS.PAN_PIXEL_DISTANCE);
    }
    /**
     * Smoothly pans the map to the southeast. The number of pixels panned is
     * defined by GLOBALS.PAN_PIXEL_DISTANCE.
     * @see GLOBALS#PAN_PIXEL_DISTANCE
     */
    this.panSouthEast = function(){
        
        slider(-GLOBALS.PAN_PIXEL_DISTANCE,-GLOBALS.PAN_PIXEL_DISTANCE);
    }
    /**
     * Smoothly pans the map to the northeast. The number of pixels panned is
     * defined by GLOBALS.PAN_PIXEL_DISTANCE.
     * @see GLOBALS#PAN_PIXEL_DISTANCE
     */
    this.panNorthEast = function(){
        
        slider(-GLOBALS.PAN_PIXEL_DISTANCE,GLOBALS.PAN_PIXEL_DISTANCE);
    }
    /**
     * Smoothly pans the map to the southwest. The number of pixels panned is
     * defined by GLOBALS.PAN_PIXEL_DISTANCE.
     * @see GLOBALS#PAN_PIXEL_DISTANCE
     */
    this.panSouthWest = function(){
        
        slider(GLOBALS.PAN_PIXEL_DISTANCE, -GLOBALS.PAN_PIXEL_DISTANCE);
    }
    /**
     * Smoothly pans the map to the northwest. The number of pixels panned is
     * defined by GLOBALS.PAN_PIXEL_DISTANCE.
     * @see GLOBALS#PAN_PIXEL_DISTANCE
     */
    this.panNorthWest = function(){
        
        slider(GLOBALS.PAN_PIXEL_DISTANCE,GLOBALS.PAN_PIXEL_DISTANCE);
    }



    ////----------------------------------------------------------------------------
    // Group: Scale Bar
    ////----------------------------------------------------------------------------



    /**
     * Add a scale bar to the map that tracks earth distance to pixels, and auto
     * adjusts when the map pans and zooms.
     * @param {ScaleBar} sb required Instance of a ScaleBar object to add to
     * this map.
     * @see ScaleBar
     */
    this.addScaleBar = function(sb) {
        
        _scaleBar = sb;
        // Need to do this first before adding to the map
        self.addMapControl( _scaleBar );
    }

    /**
     * return the current scale bar instance
     */
    this.getScaleBar = function(){
        

        return _scaleBar;
    }


    ////----------------------------------------------------------------------------
    // Group: MapTypeController
    ////----------------------------------------------------------------------------



    /**
     * Adds a MapTypeController object to a map. The MapTypeController
     * allows a user to switch map views between the standard street view, a
     * hybrid of labeled street and satellite images, and a satellite image
     * only view. Prior to adding a MapTypeController to a map, access to the
     * satellite images must be configured.
     * @param {MapTypeController} mapTypeController required An initialized
     * MapTypeController to add to the map.
     * @see MapTypeController
     * @see Credentials
     */
    this.addMapTypeController = function( mapTypeController ) {
        
        if( !mapTypeController ) {
            throw new Exception("error adding mapTypeController to map");
        }

        // Cross reference everything
        _chooser = mapTypeController;
        // Associate with the map and append the MapTypeController DOM element
        // to the map
        self.addMapControl( _chooser );
    }

    /**
     * Automatically changes the map type to either a street view, a hybrid
     * view, or a satellite image only. To view hybrid or satellite maps,
     * you must have configured access to the aerial imagery within the
     * {@link Credentials}.
     * @param {String} mapType required Choices that match the values of
     * GLOBALS.STREET, GLOBALS.HYBRID, or GLOBALS.SATELLITE.
     * @see MapTypeController
     * @see Credentials#dgkey
     */
    this.setMapType = function(mapType){

        
        if(!(mapType==GLOBALS.STREET || mapType==GLOBALS.HYBRID || mapType==GLOBALS.SATELLITE)){
            throw new Exception("unsupported mapType. Use '"+GLOBALS.STREET+"' || '"+GLOBALS.HYBRID+"' || '"+GLOBALS.SATELLITE+"'");
        }

        // 4.4.1 Removed automatic reset of Credentials.mapType
        _xmlRecFac.mapType = mapType;
        // 4.4.2 Determine if we need a map refresh.
        // Why? Any new layer that is inited will need to be seeded with the
        // correct map tile url. Determine if we need to perform a map refresh.
        var needRefresh = false;

        // This is the only function that can initiate anything other than a default
        // so this acts as a choke point for the lazy loading of the map layers.
        if(!_mapLayers || Utilities.isObjectEmpty(_mapLayers)) {
            return;
        }


		if (_zoomLayer){
			_zoomLayer.hide();
		}
		if (!_mapLayers[mapType]){
			initDefaultMapLayer(mapType);
            needRefresh = true;
		}
		for (layerType in _mapLayers){
			if (layerType == mapType) {
				_mapLayers[layerType].show();
				if (mapType == GLOBALS.HYBRID) _mapLayers[GLOBALS.SATELLITE].show();
			} else {
				if (mapType == GLOBALS.HYBRID){
					if (layerType != GLOBALS.SATELLITE) _mapLayers[layerType].hide();
				} else {
					_mapLayers[layerType].hide();
				}
			}
		}

        if(_mapOverviewController && _mapOverviewController.frame)
            _mapOverviewController.setMapType(mapType);

        if ( needRefresh ) {
            // Refresh the map to initialize lazy loaded map layers
            this.centerOnPosition(self.getCenterPosition());
        }
    } /* end setMapType */

    ////----------------------------------------------------------------------------
    // Group: ZoomController
    ////----------------------------------------------------------------------------



    /**
     * Adds a ZoomController object to the Map. The ZoomController provides the
     * user of the map with the ability to zoom in and out on a map. See the
     * {@link ZoomController} class for more details.
     * @param {ZoomController} zoomController required The initialized
     * ZoomController to add to the Map.
     * @see ZoomController
     */
    this.addZoomController = function(zoomController){
        
        _zoom = zoomController;
        self.addMapControl( _zoom );
        if(_panController){
            _zoom.frame.style.top="61px"
            _zoom.frame.style.left="21px"
        }
    }

    this.addShapeDrawingTool = function(shapeDrawingTool){
        
        _shapeDrawingTool = shapeDrawingTool;
        self.addMapControl( _shapeDrawingTool );

    }
    /**
     * Adds a PanController object to the Map.
     * @param {PanController} panController required The initialized
     * @see PanController
     */
    this.addPanController = function(panController){
        
        _panController = panController;
        self.addMapControl( _panController );
        if(_zoom){
            _zoom.frame.style.top="61px"
            _zoom.frame.style.left="21px"
        }
    }

    this.addMapOverviewController = function(mapOverviewController){
        
        _mapOverviewController = mapOverviewController;
        self.addMapControl( _mapOverviewController );

    }

    /**
     * Retrieve the ZoomController, if there is one, associated with the map.
     * @return {ZoomController} zoom
     */
    this.getZoomController = function(){
        
        return _zoom;
    }

    /**
     * Retrieve the PanController, if there is one, associated with the map.
     * @return {PanController} zoom
     */
    this.getPanController = function(){
        
        return _panController;
    }

    this.getXmlRecFac = function(){
        return _xmlRecFac;
    }

    ////----------------------------------------------------------------------------
    ////-- Group: On screen dimensions
    ////----------------------------------------------------------------------------

    /**
     * Resizes the div HTML element that the Map object exists inside of,
     * and thereby changes the Map size itself. This will force a redraw the map.
     * @param {int} height required The new height of the Map in pixels.
     * @param {int} width required The new width of the Map in pixels.
     * @param {function} callBack optional A callBack function that will be called when
     * the map has been resized. The center position of the map will be passed
     * as an argument to the callBack function. The function will only be called
     * if the map has already been initialized.
     */
    //    this.resize = function( height, width, callBack ) {
    //        
    //        self.mapDiv.style.height = parseInt(height)+_px;
    //        self.mapDiv.style.width = parseInt(width)+_px;
    //        // 4.4.1 Reposition the map controls
    //        self.positionMapControls();
    //        // Sends a signal to reDrawMap to rebuild the _mapArrayDiv
    //        _hasResized = true;
    //        if ( _mapArrayDiv ) {
    //            self.reDrawMap( callBack );
    //        }
    //    };

    this.resize = function( height, width, callback){
        
        var oldWidth=parseInt(self.mapDiv.style.width);
        var oldHeight=parseInt(self.mapDiv.style.height);
        self.mapDiv.style.height = parseInt(height)+_px;
        self.mapDiv.style.width = parseInt(width)+_px;
        self.positionMapControls();

        if(!_mapArrayDiv) return;

        //we add mapTile to the existing mapLayer, not initialize all map tiles on resizing
        // Calculate the number of tiles and enforce odd tile grid.
        //var old_verticalTiles=_verticalTiles;
        //        _verticalTiles = Math.ceil(parseInt(height) / _tileSize) + _tileBuffer;
        //        if(_verticalTiles % 2 == 0) {
        //            _verticalTiles++;
        //        }
        //        //var old_horizontalTiles=_horizontalTiles;
        //        _horizontalTiles = Math.ceil(parseInt(width) / _tileSize) + _tileBuffer;
        //        if( _horizontalTiles % 2 == 0) {
        //            _horizontalTiles++;
        //        }
        configureGridSize();

        //if(old_verticalTiles==_verticalTiles && old_horizontalTiles==_horizontalTiles){
        //callback(self.getCenterPosition());
        //return;
        //}

        //resize the mapLayer, add map tiles to the existing tile array.
        for(var z in _mapLayers){
            if(_mapLayers.hasOwnProperty(z)){
                var mapLayer=_mapLayers[z];
                mapLayer.resize(_horizontalTiles,_verticalTiles);
            }
        }

        //reset the centerPosition.
        var pixelDiffX = _mapDivX - _mapDivXorigin - (parseInt(width)-oldWidth)/2;
        var pixelDiffY = _mapDivY - _mapDivYorigin - (parseInt(height)-oldHeight)/2;;
        // Else we've moved, find the original center position
        var cpix = self.posToMercPix( _centerPosition );
        // add together and send to pix2pos
        cpix.x -= pixelDiffX;
        cpix.y += pixelDiffY;
        _centerPosition = self.mercPixToPos( cpix );
        _mapDivXorigin=_mapDivX;
        _mapDivYorigin=_mapDivY;

        //call back
        if(typeof callback=="function"){
            callback(self.getCenterPosition());
        }

        if(_mapOverviewController && _mapOverviewController.frame){
            _mapOverviewController.panToPosition(self.getCenterPosition());
        }
		destroyZoomLayer();
		initZoomLayer();

    };


    ////----------------------------------------------------------------------------
    ////-- Group: Map dimensions: Bounding Box extents
    ////----------------------------------------------------------------------------

    /**
     * Returns a BoundingBox instance representing the area of the tile grid
     * (including tiles of map offscreen).
     * @return {BoundingBox} Represents all tiles (visible and not) in the
     * map grid.
     * @see BoundingBox
     */
    this.getBoundingBox = function() {
        
        var cpix = self.posToMercPix( self.getCenterPosition() );
        // Find the "radius" of the rectangle in pixels
        var halfHeight = (_verticalTiles * _tileSize/2);
        var halfWidth = (_horizontalTiles * _tileSize/2);
        // Find the equivalent pixel points of the bounding box
        var maxPix = new PixelPoint(cpix.x+halfWidth, cpix.y+halfHeight);
        var minPix = new PixelPoint(cpix.x-halfWidth, cpix.y-halfHeight);
        // Find the equivalent positions
        var maxPos = self.mercPixToPos( maxPix );
        var minPos = self.mercPixToPos( minPix );
        // and finally the bounding box
        var bbox = new BoundingBox( minPos, maxPos );
        return bbox;
    };

    /**
     * Returns a BoundingBox instance representing only the area of the tile
     * grid visible.
     * @return {BoundingBox} boundingBox Represents all tiles (only visible)
     * in the map grid.
     * @see BoundingBox
     */
    this.getBoundingBoxViewable= function() {
        
        // Grab the center position as a mercator pixel
        var centerMercPix = self.posToMercPix( self.getCenterPosition() );
        // Find the "radius" of the rectangle in pixels
        var halfHeight = parseInt(self.mapDiv.style.height) / 2;
        var halfWidth = parseInt(self.mapDiv.style.width) / 2;
        
        // Build the max and min corners in mercator pixels
        var upperRightMercPix = new PixelPoint( centerMercPix.x + halfWidth, centerMercPix.y + halfHeight );
        var lowerLeftMercPix = new PixelPoint( centerMercPix.x - halfWidth, centerMercPix.y - halfHeight );
        // Build the positions from the mercator pixels
        var upperRightPosition = self.mercPixToPos( upperRightMercPix );
        var lowerLeftPosition = self.mercPixToPos( lowerLeftMercPix );

        // return the viewable bounding box
        var vbbox = new BoundingBox( lowerLeftPosition, upperRightPosition );
        
        return vbbox;
    };



    ////----------------------------------------------------------------------------
    ////-- Group: Map dimensions: Tiles
    ////----------------------------------------------------------------------------


    /**
     * Determines whether all map tiles should make an HTTP GET request to
     * the server or whether only tiles within the viewport should retrieve
     * map images from the server.
     * By default tiles will make a GET request for the map image at the moment
     * they are placed into the map, whether or not they are in view.
     * NOTE: For this setting to take effect, it must be called before a
     * map full redraw. This function will not change how tiles are drawn on
     * a map if called after the map has been drawn the first time (e.g.
     * {@link Map#centerOnPosition}.
     * @param {boolean} [onlyLoadInViewport=false] If set to true, will only load tiles
     * that are within the viewport. A false value, the default for JSAPI maps,
     * will only load all tile images whether or not they are within the viewport.
     * @see Map#getOnlyLoadTilesInViewport
     */
    this.setOnlyLoadTilesInViewport = function(onlyLoadInViewport) {
        _onlyLoadTilesInViewport = (onlyLoadInViewport) ? true : false;
    };

    /**
     * Returns whether all map tiles should make an HTTP GET request to
     * the server or whether only tiles within the viewport should retrieve
     * map images from the server.
     * @return {boolean} If true only load tiles that are within the viewport.
     * If false only load all tile images whether or not they are within the
     * viewport.
     * @see Map#setOnlyLoadTilesInViewport
     */
    this.getOnlyLoadTilesInViewport = function() {
        return _onlyLoadTilesInViewport;
    };

    /**
     * Concatenates the number of vertical and horizontal tiles into a string.
     * Total number of tiles equals vertical multiplied by horizontal. This
     * counts all tiles, including those not visible.
     * @returns {String} The vertical number of tiles followed by a space followed
     * by the horizontal number of tiles.
     */
    this.getGridSize = function(){
        
        return _verticalTiles + " " + _horizontalTiles;
    }

    /**
     * Sets whether to add a buffer of full tiles around the outside of the
     * viewable area of the map. By default this is true. If this is set to
     * false you have a higher chance of seeing blank tiles as the user
     * might pan faster than the map can be refreshed.
     * @param {Boolean} buffer required (default) 'true' to add a border of
     * map tiles around the edge of the viewable map, 'false' to remove the
     * extra tiles.
     */
    this.setTileBuffer = function(buffer){
        
        if(buffer){
            _tileBuffer=2;
        }else{
            _tileBuffer=1;
        }
    }

    /**
     * Draws a dashed border around each tile. This should usually only be
     * used for diagnostics.
     * As of 4.4.2 the different default map layers (satellite, hybrid, street)
     * are lazy loaded. Given this function is mainly a diagnostic function,
     * we do not force lazy loading of the tiles through this function.
     * If borders are needed on all map layers, call this function after
     * setting the map type.
     * @param {Boolean} border required 'true' to turn this feature on,
     * (default) 'false' to turn this feature off.
     * @see Map#setMapType
     */
    this.setTileBorder = function(border){
        
        if(border){
            _tileBorder=1;
        }else{
            _tileBorder=0;
        }
        for ( var z in _mapLayers ) {
            if ( _mapLayers.hasOwnProperty(z) ) {
                if ( _mapLayers[z].tileArray ) {
                    for(var y=0;y<_verticalTiles;++y){
                        for(var x=0;x<_horizontalTiles;++x){
                            _mapLayers[z].tileArray[x][y].border = _tileBorder;
                        }
                    }
                }
            }
        }
    }

    /**
     * Retrieve the current tile pixel size of the map.
     * Tiles must always be square, returned value is the size in pixels of
     * one side.
     * @returns {int} The current tile pixel size of a map tile.
     * @private
     */
    this.getTileSize = function() {
        
        return _tileSize;
    }

    /**
     * Sets the size, in pixels, of the map tile.
     * Map tiles are always square. This sets the size of one side in pixels.
     * After calling this function, make sure to force a tile refresh with the
     * map.reDrawMap() method.
     * @param {int} sidepx required The length, in pixels, of one side of a
     * square map tile.
     * @private
     */
    this.setTileSize = function(sidepx) {
        
        // If we change the tileSize, we need to change the _threshold
        // of when we choose the map tiles
        _tileSize = parseInt(sidepx, 10);
        // _threshold must be reset, too
        _threshold = _tileSize
        if (_mapArrayDiv) {
            // Signal... for now, we are going to also use the _hasResized
            _hasResized = true;
        }
        
    }

    ////----------------------------------------------------------------------------
    ////---------------------------------------------- Group: Unit Conversion
    ////----------------------------------------------------------------------------

    /**
     * Translate a Position to map layer screen pixel coordinate.
     * Note: This is not really documented anywhere, so I'm overdocumenting
     * it here. The deCarta.js doesn't yet have the map layers abstracted, but
     * there are map layers.
     * The mapContainer, or the on page div containing the map layers and
     * referred to internal to this class as the this.mapDiv field, is
     * relatively positioned.
     * The map layers under control of the mapContainer must be absolutely
     * placed within the map div, although the screen pixel for placement must
     * be calculated depending on how far the map layers have slid.
     * The purpose of this function is to isolate the translation of real world
     * coordinate Positions (lat/lons) into a map layer x, y pixel. DOM objects
     * placed on the map layer with this pixel will be at the equivalent
     * location as their real world location, at the current map zoom level.
     * For those familiar with Mercator Pixels, the results of this function,
     * as screwy as they can sometimes look, are the screen pixels and are not
     * Mercator Pixels.
     * @param {Position} pos required The real world coordinate to translate
     * to a map layer pixel.
     * @throws {Exception} Only if arg is falsey or the map has not yet had a
     * first draw.
     * @returns {PixelPoint} The equivalent onscreen, map layer pixel point.
     */
    this.positionToMapLayerPixel = function( pos ) {
        
        if ( !pos || !_centerPosition ) {
            throw new Exception( "Map.positionToMapLayerPixel: bad input: " + pos );
        }

        // We can figure out the center position in Mercator Pixels
        var centerPos=self.getCenterPosition();
        var cpix = self.posToMercPix( centerPos );
        // Find the "radius" of the rectangle in pixels
        var halfHeight = parseInt(self.mapDiv.style.height) / 2;
        var halfWidth = parseInt(self.mapDiv.style.width) / 2;
        // We can figure out what would be the upper left viewable screen Mercator Pixel
        // Mercator Pixels are signed as lat/lon, not as top/left so we reverse
        // the signage of the _mapDiv Y values because in Merc Pixels down (positive top) is up
        //        var ulpix = new PixelPoint( cpix.x-halfWidth+_mapDivX, cpix.y+halfHeight-_mapDivY );
        //        var posPix = this.posToMercPix( pos );
        //        var x = -(ulpix.roundX()-posPix.roundX());
        //        var mapLayerPix = new PixelPoint( x, (ulpix.roundY()-posPix.roundY()) );

        var ulpix = new PixelPoint( cpix.x-halfWidth, cpix.y+halfHeight);
        // We can figure out the new position Mercator Pixels
        var posPix = this.posToMercPix( pos );
        var scale =  Utilities.radsPerPixelAtZoom(_tileSize, _zoom.getGXConvertedZoomLevel());
        var halfEarthMercX = Utilities.lon2pix(180, scale);
        var x = -(ulpix.roundX()-posPix.roundX());
        if(x>halfEarthMercX) x-=halfEarthMercX*2;
        else if(x<(-halfEarthMercX)) x+=halfEarthMercX*2;
        // And now it's simply the difference between the two to get the screen coordinates
        // along with a conversion of signage suitable for top/left screen reference
        // we need to reverse signage for the top (x) screen coordinates
        var mapLayerPix = new PixelPoint( x-_mapDivX, ulpix.roundY()-posPix.roundY()-_mapDivY );
        return mapLayerPix;
    }



    ////----------------------------------------------------------------------------
    ////---------------------------------------------- Group: General Map Control
    ////----------------------------------------------------------------------------
    /**
     *  Place a generic map control object under the control of this Map instance.
     *  To qualify as a map control, objects must provide an expected interface.
     *  Only one type of each map control may be added to each instance of
     *  a map. This will never be a problem for deCarta standard map controls
     *  (ZoomController, MapTypeController, etc). Adding a control on top of a
     *  pre-existing control will destroy the old control.
     *  @example
     *  // Expected interface on a map type control
     *  // Methods
     *  .show() -> Makes visible the onscreen control. Make an empty function
     *  if you never wish to show the control.
     *  .hide() -> Makes invisible the onscreen control. Make an empty function
     *  if you never wish to hide the control from view.
     *  .position( DOMDimensionsArg ) -> Passed a deCarta.DOMDimensions object to aid
     *  in positioning the control on the screen. Make an empty function if you
     *  never wish to move the control.
     *  .appendThis() -> Returns the base DOM element to append to the map, or a falsey
     *  value if there is nothing to append.
     *  .removeThis() -> Returns the base DOM element to append to the map, or
     *  a falsey value if there is nothing to append.
     *  // Fields
     *  .passEventsToMap -> If truthy, events will be passed through the control
     *  to the map. If false, events will be blocked from the map.
     *  .map -> A back reference from the map control to the map it is associated
     *  with.
     *  .type -> The type of map control this is. This name must be unique.
     *  @param {Object} mapControl requried Associate a map control with this
     *  instance of the map.
     *  @private
     */
    this.addMapControl = function( mapControl ) {
        
        if ( !mapControl ) {
            // If undefined control...
            throw new Exception( "adding invalid control to map.");
        }
        else if (!mapControl.type || mapControl.map) {
            // ...or there is no type, or the control is already associated with a map
            throw new Exception( "adding invalid control to map, with properties type:" + mapControl.type + " map:" +mapControl.map );
        }

        // Local vars
        var mcType = mapControl.type;

        // Check if the current control exists on the map,
        // clean up if it does
        if ( this.existsMapControl(mcType) ) {
            this.removeMapControl(mcType);
        }

        // Add to the map control hash...
        _mapControlList[mcType] = mapControl;
        // ...associate with map...
        mapControl.map = this;
        var elToAppend = mapControl.appendThis();
        if ( elToAppend ) {
            this.getMapDiv().appendChild( elToAppend );
        }
        // ...then position
        var dimensions = new deCarta.DOMDimensions( this.getMapDiv() );
        mapControl.position( dimensions );
    };

    /**
     * Checks to see if a type of control is currently added to this map.
     * @param {string} mcType required The type of control to check for association
     * with this map.
     * @returns {boolean} true if the type is currently associated with this map
     * and false if not.
     * @private
     */
    this.existsMapControl = function( mcType ) {
        
        if ( _mapControlList[mcType] ) {
            return true;
        }
        else {
            return false;
        }
    };

    /**
     * Remove and destroy a particular type of map control associated with
     * the map. Ignores bad removal attempts.
     * @param {string} mcType required The type of control to remove and
     * destroy.
     * @private
     */
    this.removeMapControl = function( mcType ) {
        
        if ( !mcType || !(mcType && _mapControlList[mcType]) ) {
            // Just ignore bad removal attempts
            return;
        }

        // Clean up
        var oldControl = _mapControlList[mcType];
        _mapControlList[mcType] = undefined;
        // Remove from the map
        this.getMapDiv().removeChild( oldControl.removeThis() );
        // Destroy
        // Since this function is so rarely called, purge no matter what
        Utilities.purge( oldControl );
    };

    /**
     * Forces a (re)position of all map controls relative to the current
     * size of the map div.
     * @private
     */
    this.positionMapControls = function() {
        
        var i; // Counter
        // Pass in to the position objects so the controls can reposition
        // themselves
        var ddim = new deCarta.DOMDimensions( this.getMapDiv() );

        // Cycle through all controls
        for ( i in _mapControlList ) {
            // deal with JavaScript idiosyncracies and perhaps unexpected
            // prototype inheritence
            if ( _mapControlList.hasOwnProperty(i) && _mapControlList[i].position ) {
                _mapControlList[i].position( ddim );
            }
        }
    };

    ////----------------------------------------------------------------------------
    ////---------------------------------------------- Group: MapLayers
    ////----------------------------------------------------------------------------

    /**
     * Get access to the stack of MapLayers that make up this map.
     * Designed for the Image Cache Pre-renderer to allow easier access to
     * the map tiles, and prior to normalizing public access to the MapLayers.
     * @returns {Object} associative array of MapLayers associated with this map.
     * Access the various map layers by key:
     * GLOBALS.STREET, GLOBALS.HYBRID, GLOBALS.SATELLITE
     * @private
     */
    this.getMapLayers = function() {
        
        return _mapLayers;
    };

    ////----------------------------------------------------------------------------
    ////---------------------------------------------- Group: Unit Conversion
    ////----------------------------------------------------------------------------

    /**
     * Make this Map object invisible on the page.
     */
    this.hide = function() {
        
        this.getMapDiv().style.display = "none";
    };

    /**
     * Make this Map object visible on the page.
     */
    this.show = function() {
        
        this.getMapDiv().style.display = "block";
        // Just to make sure, replace the controls on the map
        this.positionMapControls();
    };

    ////----------------------------------------------------------------------------
    ////---------------------------------------------- Group: Browser Compatibility
    ////----------------------------------------------------------------------------



    /**
     * Should never need to be used in reality, but offers some relief for
     * potential browser incompatibility problems. Current valid settings are:
     * <ul>
     * <li>"restrictDragtoDiv" -- Mozilla FireFox 1.5 and 2.0, and perhaps
     * other browsers, can potentially have problems when
     * the mouse dragging the map moves outside of the browser window. If you
     * are noticing the "map sticking to your mouse" after leaving the browser
     * window, set this compatibility flag to true. This setting will force
     * all drags to occur within the map div. Note: This will override any
     * "mouseout" registered events attached to this map div.</li>
     * @param {string} flag required Specific compatibility flag to set.
     * @param {boolean} toggle required Set to true to turn on the compatibility
     * fix and false to turn off the compatiblity fix.
     * @throws {Exception} if an invalid flag is passed in.
     */
    this.setCompatibility = function( flag, toggle ) {
        
        switch(flag) {
            case "restrictDragToDiv":
                if(toggle) {
                    this.addEventListener( "mouseout", endDrag );
                } else {
                    this.clearListeners( "mouseout" );
                }
                break;
            default:
                throw new Exception("Map.setCompatibility: illegal flag: " + flag.toString() + " passed in as argument.");
                break;
        }
    }


    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ END PRIVILAGED PUBLIC INTERFACE
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^



    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BEGIN PRIVATE METHODS
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv



    ////----------------------------------------------------------------------------
    // Privates: Constructor like functions
    ////----------------------------------------------------------------------------

    /*
     * make reusable bubble div
     * @private
     */
    function initBubble() {
        
        //_bubble = new InfoWindow();
        _bubble = new DefaultInfoWindow({
            autoHeight:true
        });
    }


    ////----------------------------------------------------------------------------
    // Privates: Event Handling
    ////----------------------------------------------------------------------------


    /*
     * Given an event string name and function, register an event to this
     * map. Note: This function provides no protection against registering
     * improper or erroneous events.
     * @private
     * @param {string} event required "Dictionary" lookup for this event.
     * @param {function} callBack required Function to be called at
     * execution time of event.
     */
    this.addEventListener = function(event, callBack) {
        
        var alreadyRegistered = false;
        for ( var i = 0; i < _events.length; i++) {
            if( _events[i] == event ) {
                _events[event] = callBack;
                alreadyRegistered = true;
                break;
            }
        }
        if ( !alreadyRegistered ) {
            // Record the event string name in the array itself...
            _events.push(event);
            // ...and add the event function on as a "dictionary" reference
            _events[event] = callBack;
        }
    }

    this.getEventListener = function(event) {
        
        for ( var i = 0; i < _events.length; i++) {
            if( _events[i] == event ) {
                return _events[event];

            }
        }
        return null;
    }

    /*
     * Clear all events from this map instance.
     * @private
     */
    this.clearInstanceListeners = function(){
        
        for( var i=0; i < _events.length; i++ ){
            // Event names are stored in the numeric array
            // Event callbacks are stored in the dictionary against the event name
            _events[_events[i]] = null;
            _events[i] = null;
        }
    }

    /*
     * Clear a single event type.
     * @param {string} event required Name of the event to clear.
     * @private
     */
    this.clearListeners = function(event){
        
        for( var i=0; i < _events.length; i++ ) {
            // Event names are stored in the numeric array
            // Event callbacks are stored in the dictionary against the event name
            if( _events[i] == event ) {
                _events[_events[i]] = null;
                _events[i] = null;
            }
        }
    }

    /**
     * this is used to control whether the user has performed a click or
     * a drag by using a click timer
     * @inner
     */
    function capture(e){

        // Logging here causes too much noise. Manually turn on if needed.
        //
        // Quick exit if events should be ignored
        if (!GLOBALS.ALLOWDOMEVENTS) {
            return true;
        }
        e = e ? e : window.event; /* get IE event ( not passed ) */
        var eventSource;
        if (e.target) {
            eventSource = e.target; // W3C/Mozilla
        }
        else if (e.srcElement) {
            eventSource = e.srcElement; // IE
        }
        if (eventSource && eventSource.nodeType == 3) {
            eventSource = eventSource.parentNode; // defeat Safari bug
        }
        // Ignore tagged user interface elements that shouldn't trigger a
        // map event.
        if ( deCarta.IdManager.checkTag(eventSource, "ignoreForMapEvents" ) ) {
            // don't override default ops
            return true;
        }

        // 4.4.1 Removing the bubbling prevention on request of bug 6229.
        // JO: It seems as if customer is correct and while there might have
        // been a need to prevent propagation in the past, there is no
        // longer a need. Click+dblclick events will both fire when registered
        // and this has been happening since 4.3.2 (farthest back I tested).
        //e.stoppropagation ? e.stoppropagation() : e.cancelBubble = true;
        if(e.type=="mouseup"){
            _mouseUpClock = new Date();
            var clickScreenPix = new PixelPoint( e.clientX, e.clientY );
            var p = self.screenPixToPos(clickScreenPix);

            if( _events["mouseup"] ) {
                _events["mouseup"](p);
            }
            //endDrag(e);

            if ((_mouseUpClock-_mouseDownClock)<300 && _events["rightclick"] && ((_isIE && e.button == 2) || (!_isIE && e.which == 3))){                
                if (this.rtClickBoxUpHandler){
                    this.rtClickBoxUpHandler(e);
                }
                
                _events["rightclick"](p, e);
                
                e.preventDefault();
                e.stopPropagation();
                return false;
            }

        }

        else if(e.type=="dblclick"){
            // incase the map is still easing
            if(_dragEasingIntervalID){
                clearTimeout(_dragEasingIntervalID);
                _dragEasingIntervalID=undefined;
            }
            doubleClick(e);
        }
        else if(e.type=="click" && ((_mouseUpClock-_mouseDownClock)<300)){
            click(e);
        }
    /* We can't rely on contextmenu event, because not all browser support this event,
         * instead, we need to implement rightclick on right mouse down event in startDrag
         * function.
        else if(e.type=="contextmenu" && ((_mouseUpClock-_mouseDownClock)<300)){
            rightclick(e);
            return false;
        }
        else if(e.type=="contextmenu" && ((_mouseUpClock-_mouseDownClock)>=300)){
            return false;
        }
        */
    } /* end capture function */


    /*
    function rightclick(e) {
        // Logging here causes too much noise. Manually turn on if needed.
        // 

        e = e ? e : window.event;
        var eventSource;
        if (e.target) {
            eventSource = e.target; // W3C/Mozilla
        }
        else if (e.srcElement) {
            eventSource = e.srcElement; // IE
        }
        if (eventSource && eventSource.nodeType == 3) {
            eventSource = eventSource.parentNode; // defeat Safari bug
        }
        // Ignore tagged user interface elements that shouldn't trigger a
        // map event.
        if ( deCarta.IdManager.checkTag(eventSource, "ignoreForMapEvents" ) ) {
            return false;
        }

        //self.mapDiv.style.cursor = "pointer";
        _tilesContainer.style.cursor = "pointer";
        //self.mapDiv.unselectable = "on";
        _tilesContainer.unselectable = "on";

        // Grab the screen pixel coordinates of the click and calculate position
        var clickScreenPix = new PixelPoint( e.clientX, e.clientY );
        var p = self.screenPixToPos(clickScreenPix);

        //if (_events["rightclick"] && ((_isIE && e.button == 2) || (!_isIE && e.which == 3))){
        if (_events["rightclick"] && ((_isIE && e.button == 0) || (!_isIE && e.which == 3))){
            _events["rightclick"](p);
            return false;
        }

        return false;
    }
    */

    /**
     * Handle the actual click events.
     * @inner
     */
    function click(e) {
        // Logging here causes too much noise. Manually turn on if needed.
        // 

        e = e ? e : window.event; /* get IE event ( not passed ) */
        var eventSource;
        if (e.target) {
            eventSource = e.target; // W3C/Mozilla
        }
        else if (e.srcElement) {
            eventSource = e.srcElement; // IE
        }
        if (eventSource && eventSource.nodeType == 3) {
            eventSource = eventSource.parentNode; // defeat Safari bug
        }
        // Ignore tagged user interface elements that shouldn't trigger a
        // map event.
        if ( deCarta.IdManager.checkTag(eventSource, "ignoreForMapEvents" ) ) {
            return false;
        }

        //self.mapDiv.style.cursor = "pointer";
        _tilesContainer.style.cursor = "pointer";
        //self.mapDiv.unselectable = "on";
        _tilesContainer.unselectable = "on";

        // Grab the screen pixel coordinates of the click and calculate position
        var clickScreenPix = new PixelPoint( e.clientX, e.clientY );
        var p = self.screenPixToPos(clickScreenPix);

        if( _events["dblclick"] && e.type=="dblclick"){ // _events["dblclick"]){
            _events["dblclick"](p);
            return false;
        }

        if(_events["click"] && e.type=="click"){ //_events["click"]){
            _events["click"](p);
            return false;
        }
        return false;
    }

    /**
     * Handles the beginning of the map dragging. This function should be
     * attached to the onmousedown event for the map.
     * NOTE: Handler currently prevents right and middle mouse clicks from
     * causing a map drag.
     * @inner
     * @param {event} e required Event object check: usual FF vs. IE shiznick
     * with handling placed internal to the function.
     * @return {boolean} true if the event doesn't fire, false if the event
     * is handled.
     */
    function startDrag( e ) {
        // Logging here causes too much noise. Manually turn on if needed.
        //

        // incase the map is still easing
        //        if(_dragEasingIntervalID){
        //            clearTimeout(_dragEasingIntervalID);
        //            _dragEasingIntervalID=undefined;
        //        }

        // Quick exit if events should be ignored
        if (!GLOBALS.ALLOWDOMEVENTS) {
            return true;
        }

        e = e ? e : window.event; /* get IE event ( not passed ) */
        _mouseDownClock = new Date();

        var eventSource;
        if (e.target) {
            eventSource = e.target; // W3C/Mozilla
        }
        else if (e.srcElement) {
            eventSource = e.srcElement; // IE
        }
        if (eventSource && eventSource.nodeType == 3) {
            eventSource = eventSource.parentNode; // defeat Safari bug
        }
        // Ignore tagged user interface elements that shouldn't trigger a
        // map event.
        if ( deCarta.IdManager.checkTag(eventSource, "ignoreForMapEvents" ) ) {
            // Allow default actions if the map should ignore the event
            return true;
        }

        var eventSource;
        if (e.target) {
            eventSource = e.target; // W3C/Mozilla
        }
        else if (e.srcElement) {
            eventSource = e.srcElement; // IE
        }
        if (eventSource && eventSource.nodeType == 3) {
            eventSource = eventSource.parentNode; // defeat Safari bug
        }
        // Ignore tagged user interface elements that shouldn't trigger a
        // map event.
        if ( deCarta.IdManager.checkTag(eventSource, "ignoreForMapEvents" ) ) {
            // Allow default actions if the map should ignore the event
            return true;
        }

        // Eject on a right or middle button press.
        // !_isIE is good for Safari, Opera, FF and Chrome
        // Hate to admit it, but IE does the button ident better than
        // the others. Damn groupthink.

        if ((!_isIE && e.which == 3) || (_isIE && e.button == 2)) {

            if(_rightClickBBoxZoomEnabled){ // START BBOX DRAWING TO ZOOM ROUTINE
                
                e.stopPropagation? e.stopPropagation() : e.cancelBubble = true;

                var dragBoxX = e.clientX;
                var dragBoxY = e.clientY;


                var boxDiv = document.getElementById('decarta-bbox-div');
                if (!boxDiv){
                    
                    boxDiv = document.createElement("div");
                    boxDiv.className = "decarta-bbox-div";
                    boxDiv.id = 'decarta-bbox-div';
                    _tilesContainer.appendChild(boxDiv);
                }
                boxDiv.style.display = 'block';
                boxDiv.style.width = null;
                boxDiv.style.height = null;

                var mapDivPageY = Utilities.getAbsoluteTop(self.mapDiv);
                var mapDivPageX = Utilities.getAbsoluteLeft(self.mapDiv);

                boxDiv.style.top=(dragBoxY-mapDivPageY)+"px";
                boxDiv.style.left=(dragBoxX-mapDivPageX)+"px";
                
                //self.mapDiv.appendChild(boxDiv);
                
                //self.mapDiv.style.cursor = "move";
                _tilesContainer.style.cursor = "move";

                this.rtClickBoxUpHandler = function(e){
                    if (!boxDiv) return;

                    _tilesContainer.style.cursor="default";
                    var maxPoint, minPoint;
                    if (boxDiv.style.width && boxDiv.style.height) {
                        maxPoint = new PixelPoint( parseInt(boxDiv.style.left)+Utilities.getAbsoluteLeft(self.mapDiv)+parseInt((boxDiv.style.width) ? boxDiv.style.width : 0),parseInt(boxDiv.style.top)+Utilities.getAbsoluteTop(self.mapDiv) );
                        minPoint = new PixelPoint( parseInt(boxDiv.style.left)+Utilities.getAbsoluteLeft(self.mapDiv),parseInt(boxDiv.style.top)+Utilities.getAbsoluteTop(self.mapDiv)+parseInt(boxDiv.style.height ? boxDiv.style.height : 0) );
                        var maxPosition = self.screenPixToPos(maxPoint);
                        var minPosition = self.screenPixToPos(minPoint);
                        var bbox = new BoundingBox(minPosition,maxPosition);

                        if (_zoomLayer) _zoomLayer.hide();
                        _zoom.setZoomLevel(_zoom.getZoomLevelToFitBoundingBox(bbox));
                        self.centerOnPosition(bbox.getCenterPosition(), function() {
                            if(_events["zoomend"]){
                                _events["zoomend"]();
                            }
                        });
                    }

                    boxDiv.style.display = 'none';
                    boxDiv = undefined;
                    self.rtClickBoxMoveHandler = null;
                    self.rtClickBoxUpHandler = null;
                    
                    return false;
                };

                document.body.onmouseup = this.rtClickBoxUpHandler;

                this.rtClickBoxMoveHandler = function(e){

                    if (!boxDiv) return;

                    e = e ? e : window.event; /* get IE event ( not passed ) */
                    var offsetX = e.clientX;
                    var offsetY = e.clientY;

                    // four directions of drawing

                    // SOUTH EAST
                    if(e.clientX > dragBoxX && e.clientY > dragBoxY){

                        boxDiv.style.height=(offsetY-dragBoxY)+"px";
                        boxDiv.style.width=(offsetX-dragBoxX)+"px";

                    // NORTH WEST
                    } else if(e.clientX < dragBoxX && e.clientY < dragBoxY){

                        boxDiv.style.height=(dragBoxY-offsetY)+"px";
                        boxDiv.style.width=(dragBoxX-offsetX)+"px";
                        boxDiv.style.top=(dragBoxY-(dragBoxY-offsetY) - mapDivPageY)+"px";
                        boxDiv.style.left=(dragBoxX-(dragBoxX-offsetX) - mapDivPageX)+"px";

                    // SOUTH WEST
                    } else if(e.clientX < dragBoxX && e.clientY > dragBoxY){

                        boxDiv.style.height=(offsetY-dragBoxY)+"px";
                        boxDiv.style.width=(dragBoxX-offsetX)+"px";
                        boxDiv.style.left=(dragBoxX-(dragBoxX-offsetX) - mapDivPageX)+"px";

                    // NORTH EAST
                    } else if(e.clientX > dragBoxX && e.clientY < dragBoxY){

                        boxDiv.style.height=(dragBoxY-offsetY)+"px";
                        boxDiv.style.width=(offsetX-dragBoxX)+"px";
                        boxDiv.style.top=(dragBoxY-(dragBoxY-offsetY) - mapDivPageY)+"px";

                    }
                    return false;
                    
                };
                document.body.onmousemove = this.rtClickBoxMoveHandler;
            //return true;
            } // END BBOX DRAWING TO ZOOM ROUTINE

            /* we move the rightclick treatment to capture.mouseup part for time check,
             * only when mouseuptime-mousedowntime<300, we fire rightclick listener.
            if(_events["rightclick"]) {
                click(e);
            }
            */
            
            return true;
        }
        if ((!_isIE && e.which == 2) || (_isIE && e.button == 4)) {
            // Middle click
            return true;
        }

        //register mapDiv mouseup after mousedown to not affect zoomController mouseup event
        //self.mapDiv.onmouseup = capture;
        //self.mapDiv.ondblclick = capture;
        //self.mapDiv.onclick = capture;

        //_mouseDownClock = new Date();
        // check for right click
        if ( _events["mousedown"] ) {
            var clickScreenPix = new PixelPoint( e.clientX, e.clientY );
            var p = self.screenPixToPos(clickScreenPix);
            _events["mousedown"](p);
        }
        // In order to handle mouse up events correctly, we must do so within the
        // the whileDragging function. We still set up everything as if we
        // are going to drag but let whiledragging deal with whether we actually
        // drag or not
        _drag=true;
        //self.mapDiv.style.cursor="move";
        _tilesContainer.style.cursor="move";
        _dragStartX = e.clientX;
        _dragStartY = e.clientY;
        document.body.onmousemove = whileDragging; // calls dragging
        //window.onmouseup = endDrag;
        document.body.onmouseup = endDrag;
        return false;
    }

    /*
     * Deal with the end of a drag
     * @private
     */
    function endDrag(e){
        // Logging here causes too much noise. Manually turn on if needed.
        //
        _drag=false;
        //self.mapDiv.style.cursor="default";
        _tilesContainer.style.cursor="default";
        document.body.onmousemove = null;
        //window.onmouseup = null;
        document.body.onmouseup = null;

        //after dragging down, remove registering mouseup event on mapDiv
        //        self.mapDiv.onmouseup = null;
        //        self.mapDiv.ondblclick = null;
        //        self.mapDiv.onclick = null;

        if(_didMove && _events["moveend"]){
            _events["moveend"]();
            _didMove=false;
        }
        // Update the scalebar display
        if(_scaleBar){
            _scaleBar.calculate();
        }
        // Update the map tiles in view
        for ( var z in _mapLayers ) {
            if ( _mapLayers.hasOwnProperty(z) ) {
                _mapLayers[z].showTilesInViewport();
            }
        }
        // 442: Call this function at the to make sure we redraw pins
        // when we flip around the globe. Bug #7434.
        realignPushPinsAfterMove();
        if(_dragEasing){ // means there is an easing ready
            easeEndDragStart();
            _dragEasing=false;
        }

        if(_mapOverviewController && _mapOverviewController.frame){
            _mapOverviewController.panToPosition(self.getCenterPosition());
        }

        return false;
    }

    function easeEndDragStart(){
        var x = (_dragEasingLastMoveXY.x-_dragEasingSecondToLastMoveXY.x);
        var y = (_dragEasingLastMoveXY.y-_dragEasingSecondToLastMoveXY.y);
        var howFarToSlideX = x * Math.abs(x);
        var howFarToSlideY = y * Math.abs(y);
        // cap distance at 256
        howFarToSlideX = howFarToSlideX > 256 ? 256 : howFarToSlideX;
        howFarToSlideX = howFarToSlideX < -256 ? -256 : howFarToSlideX;
        howFarToSlideY = howFarToSlideY > 256 ? 256 : howFarToSlideY;
        howFarToSlideY = howFarToSlideY < -256 ? -256 : howFarToSlideY;
        
        easeEndDrag( howFarToSlideX , howFarToSlideY, new Date().getTime(), 300, deCarta.Easing('sineout'), 0, 0);
    }
    function easeEndDrag(dX, dY, startTime, duration, easing, lastX, lastY){
        
        if(!dX && !dY){
            _dragEasingIntervalID = undefined;
            return;
        }

        var t = new Date().getTime() - startTime;
        if (t > duration) t = duration;
        var x = easing(t, 0, dX, duration);
        var y = easing(t, 0, dY, duration);
                
        var dtX = x - lastX;
        var dtY = y - lastY;
    
        _deltaX += dtX;
        _mapDivX += dtX;
        _deltaY += dtY;
        _mapDivY += dtY;
        
        // move
        move( _mapDivX, _mapDivY );
        // check rotate
        if ( Math.abs(_deltaX) > _threshold || Math.abs(_deltaY) > _threshold ){
            rotateTiles();
        }
        
        _dragEasingIntervalID = requestAnimFrame(function(){
            if (t < duration)
                easeEndDrag(dX, dY, startTime, duration, easing, x, y);
        });
    }
    /*
     * double click event handling
     * @private
     */
    function doubleClick(e){
        // Logging here causes too much noise. Manually turn on if needed.
        //
        var eventSource;
        if (e.target) {
            eventSource = e.target; // W3C/Mozilla
        }
        else if (e.srcElement) {
            eventSource = e.srcElement; // IE
        }
        if (eventSource && eventSource.nodeType == 3) {
            eventSource = eventSource.parentNode; // defeat Safari bug
        }
        // Ignore tagged user interface elements that shouldn't trigger a
        // map event.
        if ( deCarta.IdManager.checkTag(eventSource, "ignoreForMapEvents" ) ) {
            return false;
        }

        _dbclick = true;
        if(_events["dblclick"])
            click(e);
        if(!_doubleClickRecenteringEnabled)
            return;
        var clickX=e.clientX;
        var clickY=e.clientY;

        var divPosX = Utilities.getAbsoluteLeft(self.mapDiv)-Utilities.getScrollLeft();
        var divPosY = Utilities.getAbsoluteTop(self.mapDiv)-Utilities.getScrollTop();
        var moveX = (parseInt(clickX-divPosX) - Math.round(parseInt(self.mapDiv.style.width)/2))*-1;
        var moveY = (parseInt(clickY-divPosY) - Math.round(parseInt(self.mapDiv.style.height)/2))*-1;
        slider(moveX,moveY);
    }

    /*
     * Called while dragging the tiles (in increments) as the onmousemove event
     * and provides support for the movestart event.
     * @private
     * @param {event} e required Event object check: usual FF vs. IE shiznick
     * with handling placed internal to the function.
     * @returns {boolean} Prevent the standard browser handling of events with
     * false.
     */
    function whileDragging( e ) {
        // Logging here causes too much noise. Manually turn on if needed.
        //
        // potentially used to calculate click positions
        var clickScreenPix;
        var p;
        // Grab the correct event object
        e = e ? e : window.event;

        // movestart must only happen once, and happen only when onmousemove
        // actually fires, not before
        if( !_didMove ) {
            if( _events["movestart"] ) {
                _events["movestart"]();
            }
        }
        // Is the mouse moving? Most likely, we will use this when the
        // map is static and we are dragging the mouse across the map.
        if( _events["move"] ) {
            // @todo create a screenPixel to position function
            // reference notes within the click function
            clickScreenPix = new PixelPoint( e.clientX, e.clientY );
            p = self.screenPixToPos(clickScreenPix);
            _events["move"](p);
        }
        // We have a special exception here to help handle the mouseup event
        // when the map is set to not drag.
        // Placing this last allows us to check for move events first, even
        // if dragging isn't enabled
        if ( !_draggingEnabled ) {
            if( e.type=="mouseup" && _events["mouseup"] ) {
                clickScreenPix = new PixelPoint( e.clientX, e.clientY );
                p = self.screenPixToPos(clickScreenPix);
                _events["mouseup"](p);
                // Kill the drag event
                endDrag(e);
            }
            return false;
        }

        // Map is officially moving now, as such movestart won't fire anymore
        _didMove=true;

        if(!_drag)
            return false;
        var draggingX = e.clientX - _dragStartX;
        var draggingY = e.clientY - _dragStartY;

        _deltaX += draggingX;
        _deltaY += draggingY;
        
        if ( Math.abs(_deltaX) > _threshold || Math.abs(_deltaY) > _threshold )
            rotateTiles();

        // if easing is enabled and if we have not yet registered that the map is being dragged
        // set the dragEasing flag.
        if(!_dragEasing && _dragEasingEnabled){
            _dragEasing=true;
        }
        _dragEasingSecondToLastMoveXY.x=_mapDivX;
        _dragEasingSecondToLastMoveXY.y=_mapDivY;

        _mapDivX += draggingX;
        _mapDivY += draggingY;

        _dragEasingLastMoveXY.x=_mapDivX;
        _dragEasingLastMoveXY.y=_mapDivY;

        
        move( _mapDivX, _mapDivY );

        if(_mapOverviewController && _mapOverviewController.frame){
            //var factor=Math.pow(2,_mapOverviewController.getZoomDifNow());
            //_mapOverviewController.sliderMapDivWin(-draggingX/factor,-draggingY/factor);
            _mapOverviewController.panMapDivWinToPos(self.getCenterPosition());
        }

        _dragStartX = e.clientX;
        _dragStartY = e.clientY;
        return false;
    }

    /*
     * Utility function to aid in handling of mouseout events.
     * The existence of this event was created to handle
     * the quirky FF 1.5 and 2.0 problem described in bug 5330.
     * @private
     */
    function mouseout(e) {
        // Logging here causes too much noise. Manually turn on if needed.
        //
        // Quick exit if events should be ignored
        if (!GLOBALS.ALLOWDOMEVENTS) {
            return true;
        }
        // Catch event for IE or FF
        if (!e) {
            e = window.event;
        }
        // We want to know what actually fired this event
        var tg = e.target ? e.target : e.srcElement;
        // Now we have to deal with the annoying bubbling/capturing
        // of events to make sure we're only stopping the drag when
        // we leave the viewable map div.
        // Cross browser figuring out of where we ended up after our
        // mouseout.
        var reltg = (e.relatedTarget) ? e.relatedTarget : e.toElement;
        // Due to the way the map works, we rely on the ID of the map
        // to handle the potential capture/bubble event problems
        try {
            if ( reltg && tg && (reltg.id == tg.id) ){
                return true;
            }
        } catch(e){
        /* do nothing */
        }


        // Here we've left the map div.
        //Utilities.p("onmouseout event fired");
        if( _events["mouseout"] ) {
            _events["mouseout"]();
        }
    }

    /*
     *  Handles the mouseover event. 
     *  This exists since there needs to be a way to start observing the scroll
     *  wheel but only when the mouse is on the map
     *  @private
     */
    
  /*  function mouseover(e){
        startObservingWheel();
    }*/

    function handleWheel(event){
        if (!_wheelZoom) return;
        //Limit zooms to 1 every 300 msec
		var now = new Date().getTime();
		if ((now - this.lastWheelTime) < 300) return;

		this.lastWheelTime = now;

        var delta = 0;
        if (!event) /* For IE. */
                event = window.event;        

        delta = event.detail ? event.detail * -1 : event.wheelDelta / 40;

        delta = (delta > 0) ? 1 : -1;

        /* Center map on mouse, too
         * this is obviously not the right thing, probably should
         * be passing a position to the zoom controller to zoom in onto. 
         */

        var clickX=event.clientX;
        var clickY=event.clientY;

        var divPosX = Utilities.getAbsoluteLeft(self.mapDiv)-Utilities.getScrollLeft();
        var divPosY = Utilities.getAbsoluteTop(self.mapDiv)-Utilities.getScrollTop();
     /*   var moveX = (parseInt(clickX-divPosX) - Math.round(parseInt(self.mapDiv.style.width)/2))*-1;
        var moveY = (parseInt(clickY-divPosY) - Math.round(parseInt(self.mapDiv.style.height)/2))*-1;        */

        var moveX = parseInt(clickX-divPosX);
        var moveY = parseInt(clickY-divPosY);

        /** If delta is nonzero, handle it.
         * Basically, delta is now positive if wheel was scrolled up,
         * and negative, if wheel was scrolled down.
         */

        var currentZoom = self.getZoomController().getZoomLevel();
        var newLevel = self.getZoomController().getClosestValidLevel(currentZoom - delta);
        self.getZoomController().zoomToNewLevel(newLevel, moveX, moveY);

        /** Prevent default actions caused by mouse wheel.
         * That might be ugly, but we handle scrolls somehow
         * anyway, so don't bother here..
         */
        if (event.preventDefault)
                event.preventDefault();
	event.returnValue = false;

    }
    /*
     * Utility method to set up the wheel event listener
     *
     **/
    function startObservingWheel(){       
        if (window.addEventListener)
            /** DOMMouseScroll is for mozilla. */
            window.addEventListener('DOMMouseScroll', handleWheel, false);
        /** IE/Opera. */
        window.onmousewheel = document.onmousewheel = handleWheel;
    }

    /*
     *  Get rid of the event listener
     *
     **/
    function stopObservingWheel(){        
        if (window.removeEventListener)
                window.removeEventListener('DOMMouseScroll', handleWheel, false);
        window.onmousewheel = devnull;
    }


    ////----------------------------------------------------------------------------
    // Privates: Field accessor functions
    ////----------------------------------------------------------------------------


    /**
     * Get access to the viewport of the map, the on page DOM element that
     * restricts the viewable area of the map.
     * @returns {DOM Element} the viewport DIV.
     * @private
     */
    this.getMapDiv = function() {
        
        return self.mapDiv;
    };

    /**
     * InfoWindow (bubble) container.
     * @returns {InfoWindow} the current InfoWindow associated with this map.
     * @private
     * @deprecated Use {@link Map#getInfoWindow} instead.
     */
    this.getBubble = function(){
        
        return _bubble;
    };
    /**
     * MapTypeController (chooser).
     * @private
     */
    this.getChooser = function(){
        
        return _chooser;
    }
    /**
     * Copyright message.
     * @private
     */
    this.getCopyright = function(){
        
        return _copyright;
    }
    /**
     * Map image div.
     * @private
     */
    this.getTileDiv = function(){
        
        return _mapArrayDiv;
    }

    /**
     * check whether map is already waiting on zoom response
     * solves the click crazy user issue through serial zooming
     * @return {Boolean} boolean
     * @private
     */
    this.getZoomLck = function(){
        
        return _zoomLock;
    }

    /**
     * returns whether or not the map is loaded, i.e. inital centerOnPosition returned.
     * @return {Boolean} boolean
     */
    this.loaded = function(){
        
        return (_mapArrayDiv ? true : false);
    }


    ////----------------------------------------------------------------------------
    // Privates: Zoom Utilities
    ////----------------------------------------------------------------------------



    /**
     * hide pins before zoom
     * @private
     */
    this.hidePinsBeforeZoom = function(){
        
        _pinList.operateOnData( function(thisPin) {
            if( thisPin ) {
                thisPin.zoomHide();
            }
        });
    };

    /**
     * showPins after zoom
     * @private
     */
    this.showPinsAfterZoom = function(){
        
        // operateOnData takes an anonymous function and applies it to each
        // piece of underlying data within the _pinList, in this case a Pin
        // object
        _pinList.operateOnData( function(thisPin) {
            // Handly only pins that are hiden for zooms
            if( thisPin ) {
                thisPin.zoomShow();
            }
        });
    };

    /**
     * realign the pushpins when the map scale changes (zoom).
     * @inner
     */
    function realignPushPins(){
        

        // operateOnData takes an anonymous function and applies it to
        // each Pin instance stored within the LinkedList of _pinList
        _pinList.operateOnData( function(thisPin) {
            if ( !thisPin ) return;
            thisPin.setPosition( thisPin.position );
            thisPin.hideInfoWindow();
        });
        // Now it's time to show the pins
        self.showPinsAfterZoom();
    }
    /**
     * Realign push pins after a drag or pan to position.
     * This function won't close the info window if it is open, as to be
     * backwards compatible panning and dragging should not close an infowindow.
     * @inner
     */
    function realignPushPinsAfterMove(){
        

        // operateOnData takes an anonymous function and applies it to
        // each Pin instance stored within the LinkedList of _pinList
        _pinList.operateOnData( function(thisPin) {
            if ( !thisPin ) return;
            var moved = thisPin.setPosition( thisPin.position );
            if (moved) {
                // If the pin has been moved when we rotate around the 180 meridian
                // I have decided to handle the open InfoWindow by moving checking
                // to see if the InfoWindow was opened on the moved pin. If so,
                // move the InfoWindow. This function is not used for zooming,
                // the other function always closes the InfoWindow on a zoom or
                // other map reset call.
                var infoWindow = thisPin.map.getInfoWindow();
                var associatedPin = (infoWindow) ? infoWindow.associatedPin : null;
                if ( infoWindow && associatedPin && associatedPin.equals(thisPin) ) {
                    // Hiding and showing the infowindow should reposition it.
                    thisPin.hideInfoWindow();
                    thisPin.showInfoWindow();
                }
            }
        });
        // Now it's time to show the pins
        self.showPinsAfterZoom();
    }

    /**
     * Zooms map to a specified zoom level.
     * The default zoom range of a deCarta map is from 1 (all the way
     * zoomed in) to 17 (all the way zoomed out).
     * @param {int} newZoomLevel The level to zoom to. If the zoom level is
     * the same, no zoom is performed.
     * @param {function} [callBack] A reference to a function to be
     * called after the map has been zoomed. No arguments will be passed to
     * the function. This will be called even in the event that the map does
     * not actually perform a zoom (aka. newZoomLevel equals the current
     * zoom level).
     * @return {boolean} true if the map was actually zoomed, false if not.
     */
    this.zoomMap = function(newZoomLevel, callBack){
        
        if( !_mapLayers[GLOBALS.STREET] && !_mapLayers[GLOBALS.SATELLITE] && !_mapLayers[GLOBALS.HYBRID] ) {
            return false;
        }
        // Ignore any requests if a zoom is currently in progress
        if( _zoomLock ) {
            return false;
        }
        // Here we will definitely use the callBack if it exists
        if( typeof callBack == 'function'){
            _callBackArray["zoomMap"] = callBack;
        }
        else {
            // Callback is optional
            _callBackArray["zoomMap"] = null;
        }

        // Should we actually zoom
        var oldZoomLevel = _zoom.selected;
        if ( oldZoomLevel == newZoomLevel ) {
            // no zoom level change, quit out but call callback first
            if ( _callBackArray["zoomMap"] ) {
                _callBackArray["zoomMap"]();
                _callBackArray["zoomMap"] = undefined;
            }
            return false;
        }
        // Zoom is now in progress
        var currentCenterPosition = self.getCenterPosition();
        var requestId = Utilities.getRequestId();
        // Set the zoom level only after the center position has been retrieved
        _zoom.setZoomLevel(newZoomLevel);
        // 4.4.2 since we remake the XML, need to grab the sessionId
        self.hidePinsBeforeZoom();
        _zoomLock = true;

        // 4.4.1 Perform digital zoom
        if ( _digitalZoom && (Math.abs(oldZoomLevel - newZoomLevel) <= 2) ) {
            // 4.4.2 Lazy create the _zoomLayer
            if ( !_zoomLayer ) {
                initZoomLayer();
            }
            _zoomLayer.show();
            // Digital zoom works on one layer only. Hybrid maps consist of
            // two layers. To make sure everything works properly, we hide
            // the transparent layer. It will be turned back on in the
            // reset function called by updateUrlList.
            if ( (_xmlRecFac && _xmlRecFac.mapType == "HYBRID") || (!_xmlRecFac.mapType && Credentials.mapType == "HYBRID") ) {
                // Hide the transparency just for the length of the zoom
                _mapLayers[GLOBALS.HYBRID].hide();
            }
            for ( var z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].zoom( oldZoomLevel - newZoomLevel, _zoomLayer, _deltaX, _deltaY);
                }
            }
        } else {

            if (_zoomLayer){
                //Hide the digital zoom layer if it exists, it means we are
                //doing a "zoom jump" of more than 2 levels.
                _zoomLayer.hide(); // it works.
            }
			/* Appears to be redundant (or better, problematic).
            for ( var z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].hide();
                }
            }*/

        }

        for (var layerId in _mapLayers){
            if ( _mapLayers.hasOwnProperty(layerId) ) {
                if (_mapLayers[layerId].refUrl && _mapLayers[layerId].layerName == 'decarta-street'){
                    var seedUrl = _mapLayers[layerId].refUrl;
                }
                if (_mapLayers[layerId].refUrl && _mapLayers[layerId].layerName == 'decarta-satellite'){
                    var gxSeedUrl = _mapLayers[layerId].refUrl;
                }
            }
        }

        JSRequest.emulatedZoomRequest(currentCenterPosition, newZoomLevel, seedUrl, gxSeedUrl, zoomMapCallback);

        if(_mapOverviewController && _mapOverviewController.frame)
            _mapOverviewController.zoomMap();
        return true;


    }



    ////----------------------------------------------------------------------------
    // Privates: Utility functions, General
    ////----------------------------------------------------------------------------



    /**
     * generic function that returns false
     * @private
     */
    function devnull(){
        //
        return false;
    }


    /**
     * @param {String} ISOCountryCode required
     * @private
     */
    this.setCountryCode = function(ISOCountryCode){
        
        if(!ISOCountryCode){
            throw new Exception("error calling Map.setCountryCode()");
        }
        Credentials.ISOCountryCode = ISOCountryCode;
    }


    ////----------------------------------------------------------------------------
    // Privates: Utility functions, Conversion
    ////----------------------------------------------------------------------------



    /**
     * Convert a Position object to a Mercator Pixel relative to the current
     * settings of the instance of this Map.
     * @private
     * @deprecated use posToMercPix instead
     */
    this.getGXPixelPoint = function(pos){
        
        this.posToMercPix( pos );
    };

    /**
     * Convert a Position object to a Mercator Pixel relative to the current
     * settings of the instance of this Map.
     * @private
     * @param {Position} pos required The coordinates to convert to Mercator
     * Pixels at the current zoom of the map.
     * @returns {PixelPoint} The Mercator Pixel representative of the
     * passed in coordinate position.
     */
    this.posToMercPix = function( pos ) {
        
        var scale =  Utilities.radsPerPixelAtZoom(_tileSize, _zoom.getGXConvertedZoomLevel());
        var y = Utilities.lat2pix(pos.lat, scale);
        var x = Utilities.lon2pix(pos.lon, scale);
        return new PixelPoint( x, y );
    };

    /**
     * Convert a Mercator Pixel object to a Position relative to the
     * current settings of the instance of this Map.
     * @private
     * @param {PixelPoint} pix required A PixelPoint representing a Mercator
     * Pixel at the current zoom level of the map.
     * @returns {Position} The Position representative of the passed in
     * Mercator Pixel.
     */
    this.mercPixToPos = function( pix ) {
        
        var scale =  Utilities.radsPerPixelAtZoom( _tileSize, _zoom.getGXConvertedZoomLevel() );
        var lat = Utilities.pix2lat( pix.y, scale );
        var lon = Utilities.pix2lon( pix.x, scale );
        return new Position( lat, lon );
    };

    /**
     * Convert screen pixel coordinates into a position.
     * @private
     * @param {PixelPoint} pix required A PixelPoint representing the screen
     * coordinates relative to the map div.
     * @returns {Position} The Position that represents the click on the
     * screen relative to the map.
     */
    this.screenPixToPos = function( pix ) {
        
        // Find our click location relative to the upper left corner of
        // our mapArray div
        var top  = pix.y - Utilities.getAbsoluteTop(self.mapDiv) + Utilities.getScrollTop();
        var left = pix.x - Utilities.getAbsoluteLeft(self.mapDiv) + Utilities.getScrollLeft();
        //

        // Here's what I'm sure I know
        // I know the map center
        // I can calculate the clickable area from within the viewable map
        // I know my click location in screen coordinates relative to the upper
        // left of the map

        // All calculations happen from the current map center
        var tilegridCenterMercPix = self.posToMercPix( self.getCenterPosition() );
        //
        // Find the upper corner mercator pixel location of an unpanned map
        var tilegridLeft = tilegridCenterMercPix.x - (parseInt(self.mapDiv.style.width) / 2);
        var tilegridTop = tilegridCenterMercPix.y + (parseInt(self.mapDiv.style.height) / 2);
        var tilegridTopLeftMercPix = new PixelPoint(tilegridLeft, tilegridTop);
        //
        // Any and all clicks are relative to the top left
        // x is a shift from the left to right and so is additive
        // y is a shift from the top down and so is negative
        var clickMercPix = new PixelPoint( tilegridTopLeftMercPix.x + left, tilegridTopLeftMercPix.y - top );
        //
        // Convert back from pixels to Position
        var p = self.mercPixToPos( clickMercPix );
        //
        return p;
    }; /* end screenPixToPos */



    ////----------------------------------------------------------------------------
    // Privates: xmlhttp response handler functions
    ////----------------------------------------------------------------------------



    /**
     * Center map on position.
     * @param {string} data required Accepts a serialized DDS Web Services XML
     * string from the JSON callback.
     * @throws {Exception} On errors reported from the XML request.
     * @inner
     */
    function centerOnPositionCallback(data) {

        
        var reqId = data.XLS.Response.requestID;
        var lat,lon;
        var pans=data.XLS.Response.PortrayMapResponse.TileGrid[0].Pan;
        var results;
        if ( deCarta.JSONParser.parseErrors(data) ) {
            // Return expected error indicator
            results = null;
        }
        else {
            for(var i=0;i<pans.length;i++){
                if(pans[i].direction=="E"){
                    _fixedGridPixelOffset.x = parseFloat(pans[i].numTiles) * _tileSize;
                    lon=pans[i].toLon;
                } else {
                    _fixedGridPixelOffset.y = -parseFloat(pans[i].numTiles) * _tileSize;
                    lat=pans[i].toLat;
                }
            }
            var deCartaPos = data.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.CenterPoint.pos.content;
            //gxPos appears to be unused ? -A
            //var gxPos = data.XLS.Response.PortrayMapResponse.TileGrid[1].CenterContext.CenterPoint.pos.content;
            // prior to 4.4.1
            if(isNaN(lat) || isNaN(lon) ){
                _centerPosition=new Position(deCartaPos);
            }else{
                _centerPosition=new Position(lat,lon);
            }
            var tmpRadius  = data.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.Radius.content;
            _zoom.setRadius(  (parseFloat((tmpRadius))/1000) * _horizontalTiles );

            // 4.4.1sp01 Capture the imageHostAliasing if available. Right now we
            // only care about the deCarta Map layer
            var maxImageHostAliases=0;
            try {
                maxImageHostAliases = parseInt(JSRequest.maxHostAliases, 10);
            } catch(e) {}
            // Handle image layer URLs
            var urls = [
                 data.XLS.Response.PortrayMapResponse.TileGrid[0].Tile.Map.Content.URL,
                 data.XLS.Response.PortrayMapResponse.TileGrid[1].Tile.Map.Content.URL
            ];
            updateUrlList(urls, maxImageHostAliases);
            // before callback in case of adding pins in callback
            //in case the info window is associated with shapes
            if(_bubble) _bubble.hide();
            realignPushPins();
            results = self.getCenterPosition();
        }
        if ( (reqId >= 0) && _callBackArray[reqId] ) {
            _callBackArray[reqId]( results );
            _callBackArray[reqId] = undefined;
        }
    }


    /**
     * zoom map XML call and call back
     * @private
     * mobile-dev
     */
    function zoomMapCallback(data) {

        

        centerOnPositionCallback(data);
        // We're done with the zoom
        _zoomLock = false;
        // callbacks
        if(_events["zoomend"]){
            _events["zoomend"]();
        }
        // from the this.zoomMap function
        if ( _callBackArray["zoomMap"] ) {
            _callBackArray["zoomMap"]();
            _callBackArray["zoomMap"] = undefined;
        }
    }


    ////----------------------------------------------------------------------------
    // Privates: Tile handling
    ////----------------------------------------------------------------------------



    /**
     * Updates tiles from center then edges when the map is refreshed.
     * As of 4.3.4 we expect to retrieve only a 1x1 tilegrid and we modify the
     * Northing and Easting values of this url to fill the entire grid. This
     * requires less XML to be transferred back from the server, but does put
     * a bit more work on the client side.
     * @private
     * @param {Array} urlList required An array of xls:URL XML nodes that correspond
     * to the center map tile for the base map layers (deCarta and Satellite
     * images).
     * @param {number} maxImageHostAliases optional If included, the URL object
     * used to generate the image URLs will round robin them to the aliased
     * DDS Web Services. Requires that the DDS be set up with image host aliasing.
     */
    function updateUrlList(urlList, maxImageHostAliases) {
        
        if(_scaleBar){
            // Now it is safe to update the scaleBar.
            _scaleBar.calculate();
        }

        reset();

        // A bit of protection, because we need an integer.
        maxImageHostAliases = maxImageHostAliases || 0;

        // 4.4.1.sp01 perform aliasing within the jsapi
        // GlobeXplorer does not have image host aliasing
        //

        // mobile-dev
        //        var gxSeedUrl = new deCarta.MapLayerReferenceUrl(Sarissa.getText(urlList[1]));
        var gxSeedUrl = new deCarta.MapLayerReferenceUrl((urlList[1]));
        gxSeedUrl.createGlobeXplorerUrl();
        if (Credentials.projection=="EPSG:3857" && gxSeedUrl.isDGSpherical){
            gxSeedUrl.setParameter("format",self.dg3SatelliteImgFormat);
        }
        
        // mobile-dev
        //        var hybridSeedUrl = new deCarta.MapLayerReferenceUrl(Sarissa.getText(urlList[0]), maxImageHostAliases);
        var hybridSeedUrl = new deCarta.MapLayerReferenceUrl((urlList[0]), maxImageHostAliases);
        hybridSeedUrl.createDeCartaTransparentUrl();
        // 4.4.1 We cannot rely on the configuration being returned within the URL
        // and must manually add it.
        hybridSeedUrl.setParameter("config", _xmlRecFac.transparentConfiguration);

        //mobile-dev
        //        var streetSeedUrl = new deCarta.MapLayerReferenceUrl(Sarissa.getText(urlList[0]), maxImageHostAliases);
        var streetSeedUrl = new deCarta.MapLayerReferenceUrl((urlList[0]), maxImageHostAliases);
        streetSeedUrl.createDeCartaUrl();
        // 4.4.1 We cannot rely on the configuration being returned within the URL
        // and must manually add it.
        streetSeedUrl.setParameter("config", _xmlRecFac.configuration);

        // Populate only the initialized and the visible layers
        if ( _mapLayers[GLOBALS.SATELLITE] ) {
            _mapLayers[GLOBALS.SATELLITE].populate( gxSeedUrl );
        }
        if ( _mapLayers[GLOBALS.HYBRID] ) {
            _mapLayers[GLOBALS.HYBRID].populate( hybridSeedUrl );
        }
        if ( _mapLayers[GLOBALS.STREET] ) {
            _mapLayers[GLOBALS.STREET].populate( streetSeedUrl );
        }

        // Pan the fixed map to display the center
        // We assume the relativity of the pan directions-to-the map (+ or -)
        // have been set prior to here.
        _deltaX -= _fixedGridPixelOffset.x;
        _deltaY -= _fixedGridPixelOffset.y;
        
        draw();
    }

    /**
     * Initializes the map objects for first time use, handles map resizes,
     * or just simpy resets the DOM structure of the map for reuse after a
     * zoom, centerOnPosition, etc.
     * @private
     */
    function populateTiles(){
        

        if ( !_mapArrayDiv ) {
            // First time, initialize all default map DOM elements
            initializeMap();
            return;
        }

    //        else if ( _mapArrayDiv && _hasResized ) {
    //            // 4.4.1 If we have resized an existing map, reset the DOM elements
    //            // which is the only other time we'd call initializeMap again
    //            _hasResized = false;
    //            resizeMap();
    //            return;
    //        }
    //        else if ( _mapArrayDiv && !_hasResized ) {
    //            return;
    //        }
    //        else {
    //            throw new Exception( "populateTiles fell through to default." );
    //        }

    } /* end populateTiles */



    ////----------------------------------------------------------------------------
    // Privates: Map Initialization
    ////----------------------------------------------------------------------------


    /**
     * Performs first time initializations on a map. This function is designed
     * to be called once without exception, and will throw
     * @inner
     */
    function initializeMap() {
        

        //---------------------------------------------- Set up the map viewport
        var mapDivClassName = "decarta-mapviewport";
        // .id has already been set by app, don't reset
        // Take into account someone might have set a class on the viewport
        if( !self.mapDiv.className ) {
            self.mapDiv.className = mapDivClassName;
        }
        else {
            self.mapDiv.className += " "+mapDivClassName;
        }
        Utilities.setUnselectable( self.mapDiv );

        //---------------------------------------------- event registration
        //self.mapDiv.oncontextmenu = devnull;
        //self.mapDiv.onmousedown = startDrag;
        //self.mapDiv.onmouseout = mouseout;
        //self.mapDiv.onmouseup = capture;
        //self.mapDiv.ondblclick = capture;
        //self.mapDiv.onclick = capture;



        //add another static layer between mapDiv and controllers
        _tilesContainer=document.createElement("div");
        _tilesContainer.style.cssText="position:absolute;overflow:hidden;left:0px;top:0px;width:100%;height:100%;"
        Utilities.setUnselectable( _tilesContainer );
        self.mapDiv.appendChild(_tilesContainer);

        _tilesContainer.oncontextmenu = devnull;
        _tilesContainer.onmousedown = startDrag;
        _tilesContainer.onmouseout = mouseout;
        _tilesContainer.onmouseup = capture;
        _tilesContainer.ondblclick = capture;
        _tilesContainer.onclick = capture;
        //_tilesContainer.oncontextmenu = capture;

        /* Fun with the scroll wheel, just  playing. */
        self.mapDiv.onmouseover = startObservingWheel;
        self.mapDiv.onmouseout = stopObservingWheel;


        //--------------------------------------- Set up the maptile foundation
        _mapArrayDiv = document.createElement("div");
        var mapArrayDivClassName = "decarta-tiles";
        _mapArrayDiv.id = mapArrayDivClassName;
        _mapArrayDiv.className = mapArrayDivClassName;
        // Explicitly position so values are referenceable
        _mapArrayDiv.style.top  = 0+_px;
        _mapArrayDiv.style.left = 0+_px;
        Utilities.setUnselectable( _mapArrayDiv );
        // Add to view behind the viewable mapPaneDiv
        //add mapArrayDiv to as child of a static layer
        //self.mapDiv.appendChild( _mapArrayDiv );
        _tilesContainer.appendChild(_mapArrayDiv);

        //--------------------------------------- ZoomControl check and set
        if( !_zoom ) {
            _zoom = new ZoomController();
            self.addMapControl(_zoom);
            _zoom.hide();
        }

        //--------------------------------------- InfoWindow check and set
        if( !_bubble ) {
            initBubble();
        }
        // Add to the map
        _mapArrayDiv.appendChild( _bubble.bubble );

        // -------------------------------------- Tile Grid default
        buildDefaultTileGrid();
    }

    this.getTilesContainer = function(){
        return _tilesContainer;
    }

    /**
     * Initialize the default set of map tiles. Function created to prevent
     * code propagation.
     * As of 4.4.2 we lazy init the _zoomLayer to lighten up the load.
     * @throws {Exception} Will not build on top of tileGrids that already exist.
     * @inner
     */
    function buildDefaultTileGrid() {
        
        if ( _mapLayers[GLOBALS.SATELLITE] || _mapLayers[GLOBALS.HYBRID] || _mapLayers[GLOBALS.STREET] ) {
            throw new Exception( "buildDefaultTileGrid called on existing tile grid" );
        }
        // Associative array of map layers: _mapLayers[Zreference].tileArray[x][y]
        // Lazy load only the layers that we need displayed
        if ( _xmlRecFac.mapType == GLOBALS.STREET ) {
            initDefaultMapLayer(GLOBALS.STREET);
        }
        else if ( _xmlRecFac.mapType == GLOBALS.HYBRID ) {
            initDefaultMapLayer(GLOBALS.HYBRID);
        }
        else if ( _xmlRecFac.mapType == GLOBALS.SATELLITE ) {
            initDefaultMapLayer(GLOBALS.SATELLITE);
        }
    // Init the _zoomLayer on the first zoom.
    }

    /**
     * Initializes a default map layer and appends it to the DOM.
     * Does not check to see if the layer is already init'd.
     * @param {string} layerName required The name of the layer to initialize.
     * @throws {Exception} if a non-default map layer is passed in.
     * @inner
     */
    function initDefaultMapLayer( layerName ) {
        if ( layerName != GLOBALS.SATELLITE && layerName != GLOBALS.HYBRID && layerName != GLOBALS.STREET ) {
            throw new Exception( "initDefaultMapLayer called with bad value: "+layerName );
        }
        // Local vars
        var mapDivHeight = parseInt(self.mapDiv.style.height);
        var mapDivWidth  = parseInt(self.mapDiv.style.width);

        // Calculate the number of tiles and enforce odd tile grid.
        //        _verticalTiles = Math.ceil(mapDivHeight / _tileSize) + _tileBuffer;
        //        if(_verticalTiles % 2 == 0) {
        //            _verticalTiles++;
        //        }
        //        _horizontalTiles = Math.ceil(mapDivWidth / _tileSize) + _tileBuffer;
        //        if( _horizontalTiles % 2 == 0) {
        //            _horizontalTiles++;
        //        }
        configureGridSize();
        // Figure out the offset of the upper left corner of the map tiles
        // relative to the upper left corner of the _mapArrayDiv
        _offsetX = -Math.floor(((_horizontalTiles*_tileSize) - mapDivWidth)/2);
        _offsetY = -Math.floor(((_verticalTiles*_tileSize) - mapDivHeight)/2);
        
        if ( layerName == GLOBALS.SATELLITE ) {
            _mapLayers[GLOBALS.SATELLITE] = new deCarta.MapLayer( _horizontalTiles, _verticalTiles, _offsetX, _offsetY, _tileSize, "decarta-satellite", 1, self );
            _mapLayers[GLOBALS.SATELLITE].show();
            _mapLayers[GLOBALS.SATELLITE].appendTiles( _mapArrayDiv );
            return;
        }
        else if ( layerName == GLOBALS.HYBRID ) {
            // Need to make sure Satellite isn't already init'd
            if ( !_mapLayers[GLOBALS.SATELLITE] ) {
                _mapLayers[GLOBALS.SATELLITE] = new deCarta.MapLayer( _horizontalTiles, _verticalTiles, _offsetX, _offsetY, _tileSize, "decarta-satellite", 1, self );
                _mapLayers[GLOBALS.SATELLITE].show();
                _mapLayers[GLOBALS.SATELLITE].appendTiles( _mapArrayDiv );
            }
            _mapLayers[GLOBALS.HYBRID] = new deCarta.MapLayer( _horizontalTiles, _verticalTiles, _offsetX, _offsetY, _tileSize, "decarta-transparent", 2, self );
            _mapLayers[GLOBALS.HYBRID].show();
            _mapLayers[GLOBALS.HYBRID].appendTiles( _mapArrayDiv );
            return;
        }
        else if ( layerName == GLOBALS.STREET ) {
            _mapLayers[GLOBALS.STREET] = new deCarta.MapLayer( _horizontalTiles, _verticalTiles, _offsetX, _offsetY, _tileSize, "decarta-street", 3, self );
            _mapLayers[GLOBALS.STREET].show();
            _mapLayers[GLOBALS.STREET].appendTiles( _mapArrayDiv );
            return;
        }
    }

    /**
     * Lets us lazy create the zoom layer, and only when we need to do so.
     * We assume that the original zoom layer functionality: the _zoomLayer
     * will be repositioned when it is actually needed for a digital zoom.
     * This might cause the first digital zoom to be slower, but so be it.
     */
    function initZoomLayer() {
        // 4.4.1 Create the ZoomLayer and add it to the DOM
        // We assume the ZoomLayer starts hidden by default.
        _zoomLayer = new deCarta.ZoomLayer( _horizontalTiles, _verticalTiles, _tileSize );
        _zoomLayer.appendTiles( _mapArrayDiv );
    }

	/**
	 * Destroys the zoom layer (useful on map resize)
	 */
	function destroyZoomLayer(){
		if (_zoomLayer && _digitalZoom) {
			_zoomLayer.destroy();
			delete _zoomLayer;
		}
	}

    /**
     * Only to be called after a map has been initialized. Assumes a resize
     * of the viewport (mapDiv) of the Map instance and resets the elements
     * that need to be reset.
     * @throws {Exception} if the _mapArrayDiv already exists.
     * @inner
     */
    function resizeMap() {
        
        if ( !_mapArrayDiv ) {
            throw new Exception( "resizeMap called without an existing map." );
        }

        // work in order
        //----------------------------------------------- Destroy old map layers
        for ( var z in _mapLayers ) {
            if ( _mapLayers.hasOwnProperty(z) ) {
                _mapLayers[z].hide();
                _mapLayers[z].destroy();
                _mapLayers[z] = undefined;
            }
        }
        _mapLayers = {};
        //----------------------------------------------- Reset location of _mapArrayDiv
        _mapArrayDiv.style.top  = 0+_px;
        _mapArrayDiv.style.left = 0+_px;
        // ---------------------------------------------- Rebuild new tile grid
        buildDefaultTileGrid();

        // ---------------------------------------------- Reset state variables
        _mapDivX            =0;
        _mapDivY            =0;
        _dragStartX         =0;
        _dragStartY         =0;
        _drag               =false;
        _deltaX             =0;
        _deltaY             =0;
    }

    /**
     * @private
     */
    function reset() {
        

        // 4.4.1 reset the map layers/tiles
        _mapDivXorigin = _mapDivX;
        _mapDivYorigin = _mapDivY;

        //when resize the map, the _offsetX and _offsetY is not changed according the the map size,
        //we should recalculate it when reset the map tiles when render map again.
        var mapDivHeight = parseInt(self.mapDiv.style.height);
        var mapDivWidth  = parseInt(self.mapDiv.style.width);

        // Calculate the number of tiles and enforce odd tile grid.
        //        _verticalTiles = Math.ceil(mapDivHeight / _tileSize) + _tileBuffer;
        //        if(_verticalTiles % 2 == 0) {
        //            _verticalTiles++;
        //        }
        //        _horizontalTiles = Math.ceil(mapDivWidth / _tileSize) + _tileBuffer;
        //        if( _horizontalTiles % 2 == 0) {
        //            _horizontalTiles++;
        //        }
        configureGridSize();
        // Figure out the offset of the upper left corner of the map tiles
        // relative to the upper left corner of the _mapArrayDiv
        _offsetX = -Math.floor(((_horizontalTiles*_tileSize) - mapDivWidth)/2);
        _offsetY = -Math.floor(((_verticalTiles*_tileSize) - mapDivHeight)/2);



        for ( var z in _mapLayers ) {
            if ( _mapLayers.hasOwnProperty(z) ) {
                var visible = _mapLayers[z].isVisible;
                _mapLayers[z].reset( -_mapDivX-_fixedGridPixelOffset.x, -_mapDivY-_fixedGridPixelOffset.y, _offsetX,_offsetY );
                //When a layer is reset the visibility is reset too.
                //This coauses problems, so we persist it. 
                if (visible){
                    _mapLayers[z].show();
                }
            }
        }
        // 4.4.1 Must turn the correct layers back on as reset hides the layers
        // except that we control what gets turned back on differently for
        // a digital zoom vs. anything else
        var layersToShow = [];
        if ( _xmlRecFac.mapType == GLOBALS.STREET ) {
            layersToShow.push( _mapLayers[GLOBALS.STREET] );
        }
        else if ( _xmlRecFac.mapType == GLOBALS.HYBRID ) {
            layersToShow.push(_mapLayers[GLOBALS.SATELLITE]);
            layersToShow.push(_mapLayers[GLOBALS.HYBRID]);
        }
        else if ( _xmlRecFac.mapType == GLOBALS.SATELLITE ) {
            layersToShow.push(_mapLayers[GLOBALS.SATELLITE]);
        }
        else {
            throw new Exception( "Map.reset: encountered unexpected _xmlRecFac.mapType of " + _xmlRecFac.mapType );
        }
        // Allows digital zoom to 'splash' the loaded images onto the page,
        // all other resets are just normal
        resetLayers( layersToShow );
        // Reset map properties
        _dragStartX         =0;
        _dragStartY         =0;
        _drag               =false;
        _deltaX             =0;
        _deltaY             =0;
    }

    /**
     * Allows control over when MapLayers are shown during after a digital zoom,
     * and benignly turns the correct layers back on for all other resets.
     * @param {Array} layersToShow required An array of MapLayer objects.
     * @inner
     */
    function resetLayers( layersToShow ) {
        

        // For Closure (during digital zoom reset)
        var layers = layersToShow;
        var numLayers = layers.length;
        // Counter
        var i;

        // Handle the majority of occurances that are not digital zooms
        if ( !_zoomLock || !_digitalZoom ) {
            for ( i = 0; i < numLayers; i++ ) {
                layers[i].show();
            }
            // Exit early
            return;
        }

		// With the new zoom fading i can simply show the layer, as tiles
		// that load with fade in nicely over the zoom layer - there is really no reason
		// (that i can see) (right now) to wait for a certain # of tiles to be loaded.
		// so :
		var nextCheck = 100;

		setTimeout( zoomCompleteCheck, nextCheck );

		function zoomCompleteCheck(){
			var digitalZoomComplete = (_zoomLayer) ? (_zoomLayer.zoomComplete) : true;
            if( digitalZoomComplete ) {
                for ( i = 0; i < numLayers; i++ ) {
                    layers[i].show();
				}
			} else {
				setTimeout( zoomCompleteCheck, nextCheck );
			}
		}

		return;
		// The rest of this code is staying for reference purpose
		// In case I got it all wrong.

		/*
        // else, digital zoom...
        // Mark the layer(s) as loading
        for( i = 0; i < numLayers; i++ ) {
            layers[i].delayedLoading = true;
        }
        // Number of milliseconds between each check
        var nextCheck = 200;
        // The total number of possible tiles to load
        var totalNumTiles = _horizontalTiles * _verticalTiles;
        // The number of tiles we expect to be loaded before showing
        // Show whenever we've loaded 80 percent or more tiles
        var tileLoadThreshold = totalNumTiles * 0.8;
        // Total number of times we'll check before just showing the layers
        var toleranceThreshold = 6;

       setTimeout( showTilesAfterZoom, nextCheck );
		*/
        /**
         * Will be called repeatedly, up to our tolerance limit, and will
         * check to see just how many tiles have loaded. If we have loaded enough
         * then show everything.
         * @inner
         */
      /*  function showTilesAfterZoom() {
            var digitalZoomComplete = (_zoomLayer) ? (_zoomLayer.zoomComplete) : true;
			console.log('Checking showtiles: NumLoaded ' + layers[0].numTilesLoaded + ' dzComp ' + digitalZoomComplete);
			console.log('Layer : ', layers[0]);
            // We'll only ever check the bottom most layer against the threshold
            if( (layers[0].numTilesLoaded >= tileLoadThreshold || toleranceThreshold <= 0 ) && digitalZoomComplete ) {
                for ( i = 0; i < numLayers; i++ ) {
                    layers[i].show();
                    // Right now we need to manually turn off the delayed loading
                    layers[i].delayedLoading = false;
                }
                // Hide the digital zoom layer
                if ( _zoomLayer ) {
                    // Not needed since the new layer shows ontop
                    //_zoomLayer.hide();
                }
                // and we're done
                return;
            }
            // One less time to check
            toleranceThreshold--;
            // try again
            setTimeout( showTilesAfterZoom, nextCheck );
        }	*/
    }

    /**
     * rotate the tiles as a rotating buffer
     * @private
     */
    function rotateTiles(){
        //console.log('rotateTiles();');
        
        var z; // counters

        if(_onRotateCallback){
            _onRotateCallback();
        }

        if( _deltaX <= -_threshold ) {
            _deltaX = _deltaX + _threshold;
            for ( z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].rotateTiles( 0, 1 );
                }
            }
            //draw();
            self.redraw();
        } else if( _deltaX >= _threshold ) {
            _deltaX = _deltaX - _threshold;
            for ( z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].rotateTiles( 0, -1 );
                }
            }
            //draw();
            self.redraw();
        }
        if( _deltaY <= -_threshold ) {
            _deltaY = _deltaY + _threshold;
            // Initiate a rotate event on all layers
            for ( z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].rotateTiles( -1, 0 );
                }
            }
            // Redraw the canvas
            //draw();
            self.redraw();
        } else if( _deltaY >= _threshold ) {
            _deltaY = _deltaY - _threshold;
            // Initiate a rotate event on all layers
            for ( z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].rotateTiles( 1, 0 );
                }
            }
            // Redraw the canvas
            //draw();
            self.redraw();
        }
    }


    /**
     * Move the in browser display of map tile container by a certain pixel
     * distance. Make sure only integers are passed in.
     * @param {integer} x required The new x location for the map div passed
     * in as a negative offset -> -100 will set the map dive to a +100 left
     * value.
     * @param {integer} y required The new y location for the map div passed
     * in as a negative offset -> -100 will set the map dive to a +100 top
     * value.
     * @inner
     */
    function move( x, y ) {
        // Function generates too much noise, turn on manually
        //
        _mapArrayDiv.style.left = x + _px;
        _mapArrayDiv.style.top = y + _px;
        
        if(_bubble 
            && _bubble.autoAdjustPos
            && _bubble.bubble.style.display=='block'
            ){
            _bubble.position();
        }
        
    }

    /**
     * Set-up to pan the map a number of screen pixels.
     * Designed as a first call to slide: this is a hack to correct a single
     * pix drift in the algorithm below.
     * @param {integer} x required Number of horizontal pixels to pan. Negative
     * values pan east, positive values pan west.
     * @param {integer} y required Number of vertical pixels to pan. Negative
     * values pan south, positive values pan north.
     * @inner
     */
    function slider( x , y ) {
        
        if ( _sliding ) {
            return;
        }
        // __This fix must be modified if slide is ever modified__
        // The slide function doesn't actually move the map in the direction
        // unless the pixel distance is greater than 1, so don't correct
        // unless the slide distance is more than 1
        if( x > 1 )
            _mapArrayDiv.style.left = parseInt(_mapArrayDiv.style.left) + 1+_px;
        else if ( x < -1 )
            _mapArrayDiv.style.left = parseInt(_mapArrayDiv.style.left) - 1+_px;
        // Vertical pan
        if( y > 1 )
            _mapArrayDiv.style.top = parseInt(_mapArrayDiv.style.top) + 1+_px;
        else if ( y < -1 )
            _mapArrayDiv.style.top = parseInt(_mapArrayDiv.style.top) - 1+_px;

        _sliding = true;
        slide( x, y, true);
    }


    /**
     * Slide the map in half-life increments from the current location to new
     * pixel coordinates. Once called, this function will be called repeatedly
     * until the destination is arrived at.
     * @param {integer} x required Number of horizontal pixels to pan. Negative
     * values pan east, positive values pan west.
     * @param {integer} y required Number of vertical pixels to pan. Negative
     * values pan south, positive values pan north.
     * @param {boolean} first optional Determines if this is the initial call
     * to begin sliding the map. In the case of the first call, this should
     * be set to true. In all other calls, this argument can be ignored.
     * @inner
     */
    function slide( x, y, first ) {
        
        // Note on oddity: looks like setTimeout passes a rogue argument in as
        // argument[0] on Mozilla FF 3.0. Yikes, watch out.
        // On the first call, set-up our final destination
        if ( first ) {
            pixelsToSlideX = x;
            pixelsToSlideY = y;
        }

        // Set-up to move 30% of the distance
        var percentX = Math.round( Math.abs(pixelsToSlideX)*0.3 );
        var percentY = Math.round( Math.abs(pixelsToSlideY)*0.3 );
        

        // Perform the incremental map pan
        if( percentX > 0 || percentY > 0 ){
            // first call through n - 1 call
            if (pixelsToSlideX < 0) {
                pixelsToSlideX += percentX;
                _deltaX -= percentX;
                _mapDivX -= percentX;
            } else if( pixelsToSlideX > 0 ){
                pixelsToSlideX -= percentX;
                _deltaX += percentX;
                _mapDivX += percentX;
            }
            if( pixelsToSlideY < 0 ) {
                pixelsToSlideY += percentY;
                _deltaY -= percentY;
                _mapDivY -= percentY;
            }else if( pixelsToSlideY > 0 ) {
                pixelsToSlideY -= percentY;
                _deltaY += percentY;
                _mapDivY += percentY;
            }
            // Actually "slide" the map
            move( _mapDivX, _mapDivY );
            if ( Math.abs(_deltaX) > _threshold || Math.abs(_deltaY) > _threshold )
                rotateTiles();
            setTimeout(slide, _mapPanTimeoutDelay);
        } else {
            // last call! aka. the end of the slide

            // Notify other functions we are done with these events
            //Moved this here since sometimes a callback might cause another slide
            //so we want this flag to be false for it to happen. 
            _sliding=false;

            // Perform event handling and map object updates
            if(_events["moveend"]){
                _events["moveend"]();
            }
            // 4.4.1
            // Added the potential for a callBack function to handle activities
            // post animation.
            if ( _callBackArray["panToPosition"] ) {
                _callBackArray["panToPosition"]( self.getCenterPosition() );
                _callBackArray["panToPosition"] = undefined;
            }
            if(_scaleBar){
                _scaleBar.calculate();
            }
            if ( _dbclick && _dbclickZoom ) {
                self.getZoomController().zoomInOneLevel();
            }

			_dbclick=false;
            // Redraw overlays on the map
            //draw();
            //when slide, if not rotate tiles, we don't need to redraw because the buffering.
            //redraw();

            // Trigger the new tiles to be shown
            for ( var z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].showTilesInViewport();
                }
            }

            // 442: Call this function at the to make sure we redraw pins
            // when we flip around the globe. Bug #7434.
            realignPushPinsAfterMove();
            


        }
        
        
    } // end function slide



    ////----------------------------------------------------------------------------
    // Privates: Client side Overlay Utilities
    ////----------------------------------------------------------------------------


    /*
     * lazy create canvas
     * @private
     */
    function getCanvas(){
        
        if(!self.getTileDiv()){
            return null;
        }
        //var canvas = document.getElementById("svgvml_canvas");
        var canvas=_canvas;

        if(!canvas){
            canvas =  document.createElement('div') ;
            canvas.id="svgvml_canvas";
            self.getTileDiv().appendChild(canvas);

        }
        canvas.style.position = "absolute";
        // Need to reset the zIndex each time
        canvas.style.zIndex = 100;
        _canvas=canvas;
        return canvas;
    }

    /**
     * Remove Overlays from the map. This is performed by an explicit clear
     * of the entire canvas. Canvas does not currently allow id'ing or clearing
     * of Overlay objects.
     * @inner
     */
    function clear(){
        
        if(_rendering=="server"){
            return;
        }
        var canvas = getCanvas();
        //var ctx = canvas.getContext("2d");
        //ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.innerHTML="";
    }

    function constructRaphaelPaper(){
        // lazy create canvas
        if(!self.getTileDiv() ) return null;
        var canvas = getCanvas();


        // check for resize
        var g = self.getGridSize().split(" ");
        var gWidth = parseInt(g[1])*_tileSize;
        var gHeight = parseInt(g[0])*_tileSize;
        // Resetting the width or height of the canvas performs a clear of the
        // canvas. Go figure.
        canvas.style.width = gWidth+_px;
        canvas.style.height = gHeight+_px;
        // determine canvas offset to align with tiles.
        var tp = self.mapDiv;
        var _offsetX = -Math.floor((gWidth - parseInt(tp.style.width))/2);
        var _offsetY = -Math.floor((gHeight - parseInt(tp.style.height))/2);
        var t = _mapArrayDiv;
        // Reset canvas location
        canvas.style.left=_offsetX-parseInt(t.style.left)+_px;
        canvas.style.top=_offsetY-parseInt(t.style.top)+_px;
        canvas.innerHTML="";

        var raphael_paper=Raphael(canvas);
        raphael_paper.bbox=self.getBoundingBox();
        return raphael_paper;
    }


    /**
     * Client side rendering. Draw shapes on the canvas element.
     * @param {boolean} clear optional If truthy, the map will be cleared no
     * matter what.
     * @inner
     */
    //draw function using Raphael library to implement svg/vml
    function draw( clear ) {
        
        clear = clear || false;

        // Reasons not to draw the canvas
        if( _xmlRecFac.overlays.length == 0 && !clear ){
            _raphael_paper=null;
            return;
        }

        if( _sliding || !self.getTileDiv() )
            return;


        _raphael_paper=constructRaphaelPaper();


        // Retrieve all shapes stored in the xmlRequestFactory instance
        var shapeStore = _xmlRecFac.overlays;

        for (var ii = 0; ii < shapeStore.length; ii++) {
            // Local reference of shape in array for speedier access
            var shape = shapeStore[ii];
            shape.raphael_element=null;

            self.drawShape(shape, true);

        }
    } // end draw (inner)
    //



    this.getRaphaelPaper = function(){
        return _raphael_paper;
    }

    this.getMapOverviewController = function(){
        return _mapOverviewController;
    }

    function configureGridSize(){
        var mapDivHeight = parseInt(self.mapDiv.style.height);
        var mapDivWidth  = parseInt(self.mapDiv.style.width);
        // Calculate the number of tiles and enforce odd tile grid.
        _verticalTiles = Math.ceil(mapDivHeight / _tileSize) + _tileBuffer;
        if(_verticalTiles % 2 == 0) {
            _verticalTiles++;
        }
        _horizontalTiles = Math.ceil(mapDivWidth / _tileSize) + _tileBuffer;
        if( _horizontalTiles % 2 == 0) {
            _horizontalTiles++;
        }
        var tileArrayHeight=_verticalTiles*_tileSize;
        var tileArrayWidth=_horizontalTiles*_tileSize;
        _mapArrayDiv.style.width=tileArrayWidth+_px;
        _mapArrayDiv.style.height=tileArrayHeight+_px;
    }


//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ END PRIVATE METHODS
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

} /* END MAP CLASS */

/**
 * @fileoverview Abstract map layer components and objects.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class MapLayers provide the user, and this API, a way to overlay different
 * map data on the map. MapLayers are two dimensional arrays of image tiles
 * where each tile is one chunk of the visible map on the screen. As the
 * map is dragged around the user screen, the MapLayer will flip the tiles
 * thus reusing the image (IMG) elements used to make the maps.
 * A MapLayer is itself not a DOM object, but rather is an access to the
 * image elements that make up the tiles on screen. A MapLayer is useless
 * without a {@link Map}.
 * @description Construct a new map layer.
 * @param {number} xTiles The integer number tiles in a horizontal
 * direction.
 * @param {number} yTiles The integer number of tiles in a vertical
 * direction.
 * @param {number} [xOffset] An integer number of pixels to offset this
 * MapLayer in the horizontal direction. If the MapLayer could be thought of as
 * one giant div, this is the initial css left offset.
 * @param {number} [yOffset] An integer number of pixels to offset this
 * MapLayer in the vertical direction. If the MapLayer could be thought of as
 * one giant div, this is the initial css top offset.
 * @param {number} tileSize The pixel dimensions square of each tile
 * in this layer.
 * @param {string} [layerName] An indentifying name for this layer.
 * @param {number} [cssZIndex] The zIndex that gets associated with this
 * MapLayer instance.
 * @param {boolean} owner The map object that this layer will be tied to.
 * @param {boolean} [fx] fading and other effects on / off
 * @private
 * @constructor
 */

deCarta.MapLayer = function( xTiles, yTiles, xOffset, yOffset, tileSize, layerName, cssZIndex, owner, fx) {
    this.init( xTiles, yTiles, xOffset, yOffset, tileSize, layerName, cssZIndex, owner , fx);
};


/**
 * this is a static variable used to cycle through the digital globe host name
 * alias'.
 */
deCarta.MapLayer.dgAliasIndex=0;
/**
 * max number of digital globe alias', this is zero based so 3 will generate:
 * www0
 * www1
 * www2
 * www3
 */
deCarta.MapLayer.dgAliasMax=3;


//
//
//
// MapLayer fields

/**
*	Speed (in ms) for fade effects on tiles.
*/
deCarta.MapLayer.prototype.fadeSpeed = 300;
/**
 * Parent object of this MapLayer.
 * @type Map
 * @default null
 * @private
 */
deCarta.MapLayer.prototype.owner = null;
/**
 * Should MapTiles associated with this map layer only be shown within the
 * viewport?
 * @type boolean
 * @default false
 * @private
 */
deCarta.MapLayer.prototype.onlyLoadTilesInViewport = false;
/**
 * The number of horizontal tiles in this map layer.
 * Consider access to this property read-only.
 * @type number
 * @default null
 */
deCarta.MapLayer.prototype.xTiles = null;
/**
 * The number of vertical tiles in this map layer.
 * Consider access to this property read-only.
 * @type number
 * @default null
 */
deCarta.MapLayer.prototype.yTiles = null;
/**
 * An integer number of pixels to offset this MapLayer in the horizontal
 * direction on layer initialization and reset. If the MapLayer could be
 * thought of as one giant div, this is the initial css left offset.
 * Consider access to this property read-only.
 * @type number
 * @default 0
 */
deCarta.MapLayer.prototype.xOffset = 0;
/**
 * An integer number of pixels to offset this MapLayer in the vertical
 * direction on layer initialization and reset. If the MapLayer could be
 * thought of as one giant div, this is the initial css top offset.
 * Consider access to this property read-only.
 * @type number
 * @default 0
 */
deCarta.MapLayer.prototype.yOffset = 0;
/**
 * The current X index of the origin, or upper left, tile. For many reasons,
 * the tile grid reuses its original allotment of images. As the map pans,
 * the img tiles on the page will "flip", or quite literally change their
 * position from one boundary edge to the other, but their location will not
 * change in the array. We keep track of the current upper left, or origin,
 * tile via this and another property.
 * We use CSS notation as this tells which X index in the array of tiles
 * equals the left edge of the on screen map.
 * @type number
 * @default 0
 */
deCarta.MapLayer.prototype.leftIndex = 0;
/**
 * The current Y index of the origin, or upper left, tile. For many reasons,
 * the tile grid reuses its original allotment of images. As the map pans,
 * the img tiles on the page will "flip", or quite literally change their
 * position from one boundary edge to the other, but their location will not
 * change in the array. We keep track of the current upper left, or origin,
 * tile via this and another property.
 * We use CSS notation as this tells which Y index in the array of tiles
 * equals the top edge of the on screen map.
 * @type number
 * @default 0
 */
deCarta.MapLayer.prototype.topIndex = 0;
/**
 * The pixel dimension of MapTile within the MapLayer. Each tile is required
 * to be square.
 * Consider access to this property read-only.
 * @type number
 * @default null
 */
deCarta.MapLayer.prototype.tileSize = null;
/**
 * An identifying name for this MapLayer, should one be desired.
 * @type string
 * @default "mapLayer"
 */
deCarta.MapLayer.prototype.layerName = "mapLayer";
/**
 * A CSS className string that will be associated with this MapLayer.
 * Consider access to this property read-only.
 * @type string
 * @default "decarta-maptile"
 */
deCarta.MapLayer.prototype.cssClass = "decarta-maptile";
/**
 * The default CSS z-index applied to the tiles within this layer.
 * Consider access to this property read-only.
 * @type number
 * @default 0
 */
deCarta.MapLayer.prototype.cssZIndex = 20;
/**
 * Holds the array of DOM elements (most likely IMG elements) that make up
 * the on screen view of this MapLayer.
 * Consider access to this property read-only.
 * @type Array (2 dimensional)
 * @default null
 */
deCarta.MapLayer.prototype.tileArray = null;
/**
 * Location of an image placeholder for when this image layer is meant to be
 * invisible.
 * This is usually a transparent PNG or GIF (for old IE6). Set during map
 * layer construction. Feel free to reset this to an "invisible" image of
 * your choice after the MapLayer has been constructed.
 * @type string
 * @default null
 */
deCarta.MapLayer.prototype.srcOnHidden = null;
/**
 * Location of an image placeholder for when loading an image produces an error.
 * Set during the map layer construction. Feel free to reset to an error image
 * of your choice after the MapLayer has been constructed.
 * @type string
 * @default null
 */
deCarta.MapLayer.prototype.srcOnError = null;
/**
 * Indicator of viewability of this maplayer. This should be treated as a
 * read only field and not modified directly: use the show and hide methods
 * instead.
 * Consider access to this property read-only.
 * @type boolean
 * @default false
 * @private
 */
deCarta.MapLayer.prototype.isVisible = false;
/**
 * The total number of tiles that have been loaded. This number can be used
 * in conjunction with tile-loading events.
 * Consider access to this property read-only.
 * @type number
 * @default 0
 * @private
 */
deCarta.MapLayer.prototype.numTilesLoaded = 0;
/**
 * Layers can be marked for delayed loading. Currently this only is used for
 * digital zoom.
 * @type boolean
 * @default false
 * @private
 */
deCarta.MapLayer.prototype.delayedLoading = false;
/**
 * The reference URL generates the map tile img src urls as the map is panned.
 * This gets regenerated each time the map is refreshed.
 * @type deCarta.MapLayerReferenceUrl
 * @default null
 * @private
 */
deCarta.MapLayer.prototype.refUrl = null;
//
//
//
// MapLayer public methods
/**
 * Initialize all settings. Called automatically from the constructor.
 * Please see the constructor for documentation on the parameters.
 * @private
 */
deCarta.MapLayer.prototype.init = function( xTiles, yTiles, xOffset, yOffset, tileSize, layerName, cssZIndex, owner) {
    
    // Local Variables
    // Counters
    var x, y;
    // Init constructor fields
    this.xTiles = xTiles;
    this.yTiles = yTiles;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
    this.tileSize = tileSize;

    if (layerName) {
        this.layerName = layerName;
    }
    if (cssZIndex) {
        this.cssZIndex = cssZIndex;
    }
    this.owner = owner;
    // Set when tiles should be drawn
    this.onlyLoadTilesInViewport = this.owner.getOnlyLoadTilesInViewport();

    // Init automatic fields
    this.tileArray = [];       // Make 2 dimensional below

    this.setDefaultSrc();

    // Build MapTiles and populate tileArray
    // Horizontal in first array, vertical filled "down" in 2nd dimension
    for ( x = 0; x < this.xTiles; x++ ) {
        // Add 2nd dimension
        this.tileArray[x] = [];
        // Create the initial MapLayer grid of images such that we can simply
        // call an offset later.
        for ( y = 0; y < this.yTiles; y++ ) {
            this.tileArray[x][y] = this.mapTileFactory( x, y );
            if(this.owner.type=="MapOverviewController")
                deCarta.IdManager.setTag( this.tileArray[x][y], "ignoreForMapEvents" );
        }
    }
};
/**
 * Configures the default images for this MapLayer.
 * Uses settings from the Credentials object.
 */
deCarta.MapLayer.prototype.setDefaultSrc = function() {
    
    if (!Utilities.ie6) {
        this.srcOnHidden = Credentials.transparentPNG;
        // This is to support historical usage of invisible images on error.
        // Perhaps this is because people didn't like the satellite image
        // error tiles.
        this.srcOnError = Credentials.transparentPNG;
    }
    else {
        // yippeee IE6....
        this.srcOnHidden = Credentials.transparentGIF;
        this.srcOnError = Credentials.transparentGIF;
    }
};
/**
 * The basic onerror event for images in this MapLayer. This function should be
 * tied into a map tile onerror event.
 * @param {Event} event required Passed in by most browsers or not on IE
 * browsers.
 */
deCarta.MapLayer.prototype.mapTileOnError = function(event) {
    
    var tile;
    if ( !event ) {
        tile = window.event.srcElement;
    } else {
        tile = event.currentTarget;
    }
    if ( tile && tile.src && tile.srcOnError ) {
        tile.src = tile.srcOnError;
    }
};

/**
 * Used to generate a Maptile, which is essentially a class wrapped around
 * a DOM Image object for convenience.
 * @param {number} x required Integer horizontal array index position of the
 * mapTile in the layer.
 * @param {number} y required Integer vertical array index position of the
 * mapTile in the layer.
 * @returns {Image} Image DOM element configured with default Map tile
 * properties and styles.
 */
deCarta.MapLayer.prototype.mapTileFactory = function( x, y ) {
    

    // used in calculations below
    var centerX = Math.floor( this.xTiles/2 );
    var centerY = Math.floor( this.yTiles/2 );

    var mapTile = document.createElement("IMG");
    //
    // Custom settings for this image
    // Set the owner of this particular tile, make sure to clean this up on IE6
    mapTile.ownerLayer = this;
    // Relative distance of this tile from the center of the tile grid
    mapTile.fromCenterX = x - centerX;
    mapTile.fromCenterY = centerY - y;
    // Unique ID for the tile
    mapTile.id = 'Tile_' + x + '_' + y + '_' + mapTile.ownerLayer.layerName;
    // Propagate the MapLayer general defaults onto this image
    mapTile.className = this.cssClass;
    if ( this.srcOnHidden ) {
        mapTile.altSrc = this.srcOnHidden;
        mapTile.src = this.srcOnHidden;
    }
    else {
        mapTile.altSrc = "";
        mapTile.src = "";
    }
    mapTile.style.display = "none";
    mapTile.style.zIndex = this.cssZIndex;
    mapTile.style.height = this.tileSize+"px";
    mapTile.style.width = this.tileSize+"px";
    mapTile.onerror = this.mapTileOnError;
    // The screen pixel location must be offset per tile
    mapTile.style.left = (x*this.tileSize)+this.xOffset+"px";
    mapTile.style.top = (y*this.tileSize)+this.yOffset+"px";
    // Make the map tiles unselectable by errant drags
    Utilities.setUnselectable(mapTile);

    // Coordinates of this particular map tile
    mapTile.coords = new Object();
    mapTile.coords.ul = null;
    mapTile.coords.ur = null;
    mapTile.coords.lr = null;
    mapTile.coords.ll = null;
    // Has this tile been viewed yet?
    mapTile.tileViewed = false;
    // New mapTile functions
    mapTile.setTileCoords = deCarta.MapLayer.setTileCoords;
    mapTile.isTileInViewPort = deCarta.MapLayer.isTileInViewPort;

    mapTile.loaded = false;
    // How we set the MapTile src
    mapTile.setSrc = deCarta.MapLayer.setSrc;    
    // We create a different loader for IE6 vs. everything else
    if (Utilities.ie6 ) {
        // IE6 = we must do more to support
        // The fixPNG will block browser events if it is run on a PNG in
        // view. Blocking happens until the PNG is actually rendered on the
        // screen. As such we load the PNG in the background, "fix" it
        // and then load it into the foreground.
        mapTile.loader = document.createElement("img");
        mapTile.loader.owner = mapTile; // An event safe reference to the greater Self
        mapTile.loader.loadTile = function() {
            this.owner.style.filter="progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+this.src+"')";
            this.owner.src = Credentials.transparentGIF;
            //this.owner.src = this.src;
            this.owner.ownerLayer.numTilesLoaded++;            
            return true;
        };
        mapTile.loader.onload = mapTile.loader.loadTile;
        mapTile.onload = function() {
            if (this.src == Credentials.transparentGIF) return;
            //alert("Tile " + this.id + " has loaded and will now show " + this.src);
            mapTile.style.display = "block";
        //Utilities.setOpacity(this, 100);
        };
        mapTile.show = function(){
            this.style.display = "block";
            this.style.zIndex = 30;
        //Utilities.setOpacity(this, 100);
        }
        mapTile.hide = function(){
            this.style.display = "none";
        }

    } else {
        // !IE6
        mapTile.loader = document.createElement("img");
        mapTile.loader.owner = mapTile; // An event safe reference to the greater Self
        mapTile.delayedShow = false;
        mapTile.show = function(){
            if (!this.loaded)
                return;
            if (this.fading)
                return;
            if (!this.ownerLayer.isVisible )
                return;

            if (this.ownerLayer.owner.getTileFading()){
                this.fading = true;
                this.style.display = "block";
                Utilities.fade(this, {
                    from: 0,
                    to: 100,
                    duration: this.ownerLayer.fadeSpeed,
                    onComplete: function (elem){
                        elem.fading = false
                        }
                    });
        } else {
            this.style.display = "block";
            Utilities.setOpacity(this, 100);
        }
    }
        mapTile.hide = function(){
            if (this.ownerLayer.owner.getTileFading()){
                Utilities.fade(this, {
                    from: 100,
                    to: 0,
                    duration: this.ownerLayer.fadeSpeed,
                    onComplete: function (elem){
                        elem.style.display = 'none';
                        elem.fading = false;
                    }
                });
        } else {
            this.style.display = "none";
            Utilities.setOpacity(this, 0);
        }
    }
        mapTile.loader.loadTile = function() {

            if (this.src == this.owner.src) return;
            /*          the loader should never load a transparency. ..
                                if (this.src.indexOf(Credentials.transparentPNG) != -1) {
                        return;
                    }
        */
            this.owner.loaded = true;
            Utilities.setOpacity(this.owner, 0);
            this.owner.style.display = 'block';
            this.owner.style.zIndex = 30;
            this.owner.src = this.src;

            this.owner.ownerLayer.numTilesLoaded++;
            this.owner.show();
            return;
        };
        mapTile.loader.onload = mapTile.loader.loadTile;
        mapTile.fading = false;
    }
    return mapTile;
};

/**
 * Will force all previously not viewed tiles to be checked whether or not they
 * are within the viewport. A tile will be shown if it is now within the viewport.
 */
deCarta.MapLayer.prototype.showTilesInViewport = function() {
    // Quit out early
    if ( this.onlyLoadTilesInViewport ) {
        for ( var x = 0; x < this.xTiles; x++ ) {
            for ( var y = 0; y < this.yTiles; y++ ) {
                var tile = this.tileArray[x][y];
                if ( !tile.tileViewed ) {
                    tile.setSrc(tile.altSrc);
                }
            }
        }
    }
};

/**
 * Used by non-ie6 browsers to set the source of a map tile.
 * @static
 */
deCarta.MapLayer.setSrc = function( src ) {
    // Too much noise in this function. Turn on Manually.
    //
    if (this.src == src) return;

    //cycle the dg alias
    if(this.ownerLayer.layerName == "decarta-satellite"){
        if(deCarta.MapLayer.dgAliasIndex >= deCarta.MapLayer.dgAliasMax){
            deCarta.MapLayer.dgAliasIndex=0;
        } else {
            deCarta.MapLayer.dgAliasIndex++;
        }
        //Added a "." to the end here, was going through multiple subs.
        src=src.replace(/\/\/www\./,"//www"+ deCarta.MapLayer.dgAliasIndex + ".");
    }
    // We always update the altSrc

    this.loaded = false;
    this.altSrc = src;
    Utilities.setOpacity(this, 0);

    if (this.ownerLayer.isVisible){
        if (Utilities.ie){
            
            //this checks for the blank tile problem in ie 8 + (7+?)
            var tile = this;
            var checkeroo = function(){
                if (tile.loaded && (tile.altSrc != tile.src )){
                    tile.src = tile.altSrc;
                } else {
                    setTimeout(checkeroo, 250);
                }
            };
            setTimeout(checkeroo, 250);
            
        }
        this.loader.src = src;
        this.src = Credentials.transparentPNG;
        if (Utilities.ie6) this.src = Credentials.transparentGIF;
        this.show();
    }
    return;
};

/**
 * Used by the MapTiles to set their bounding box coordinates.
 * @param {deCarta.MapLayerReferenceUrl} refUrl The reference URL associated with
 * this layer.
 * @static
 */
deCarta.MapLayer.setTileCoords = function( refUrl ) {
    // this references here should refer to the MapTile

    if(!refUrl) return;
    var props = refUrl.dynamicProps;
    var llMinString = props.llMin.split(",");  // String representation (lat,lon) of the reference tile minimum bounding box corner.
    //var llMaxString = props.llMax.split(",");  // String representation (lat,lon) of the reference tile maximum bounding box corner.
    var n = parseInt(props.northing,10);         // Northing value of center map tile from the reference.
    var e = parseInt(props.easting,10);          // Easting value of center map tile from the reference.

    var ol = this.ownerLayer;
    var map = ol.owner;
    var zoomLevel = map.getZoomController().getZoomLevel();
    var tileSize = map.getTileSize();
    var scale = Utilities.radsPerPixelAtZoomLevel(tileSize, zoomLevel);
    var llMinRef = new Position(parseFloat(llMinString[0]), parseFloat(llMinString[1]));
    //var llMaxRef = new Position(parseFloat(llMaxString[0]), parseFloat(llMaxString[1]));

    // llMinSeed should always be 0,0, but just in case.
    var lowerLatRefPix = Math.round(Utilities.lat2pix(llMinRef.lat, scale));
    var lowerLonRefPix = Math.round(Utilities.lon2pix(llMinRef.lon, scale));
    //var upperLatRefPix = Math.round(Utilities.lat2pix(llMaxRef.lat, scale));
    //var upperLonRefPix = Math.round(Utilities.lon2pix(llMaxRef.lon, scale));
    // adjust the box by pixels
    var lowerLatTilePix = lowerLatRefPix + (n*tileSize) + (this.fromCenterY*tileSize);
    var lowerLonTilePix = lowerLonRefPix + (e*tileSize) + (this.fromCenterX*tileSize);
    //var upperLatTilePix = upperLatRefPix + (n*tileSize) + (this.fromCenterY*tileSize);
    //var upperLonTilePix = upperLonRefPix + (e*tileSize) + (this.fromCenterX*tileSize);
    var upperLatTilePix = lowerLatTilePix+ol.tileSize;
    var upperLonTilePix = lowerLonTilePix+ol.tileSize;
    // boundary in coords
    var lowerLatTile = Utilities.pix2lat( lowerLatTilePix, scale );
    var lowerLonTile = Utilities.pix2lon( lowerLonTilePix, scale );
    var upperLatTile = Utilities.pix2lat( upperLatTilePix, scale );
    var upperLonTile = Utilities.pix2lon( upperLonTilePix, scale );
    // coords to set, this == mapTile
    this.coords.ul = new Position(upperLatTile, lowerLonTile);
    this.coords.ur = new Position(upperLatTile, upperLonTile);
    this.coords.lr = new Position(lowerLatTile, upperLonTile);
    this.coords.ll = new Position(lowerLatTile, lowerLonTile);
};

/**
 * Is this tile visible within the map viewport?
 * @return {boolean} true if any part of the tile is visible within the viewport,
 * false if not.
 */
deCarta.MapLayer.isTileInViewPort = function() {
    var i;
    var coords = this.coords;
    var bbox = this.ownerLayer.owner.getBoundingBoxViewable();

    // test each point
    var isInView = false;
    for ( i in coords ) {
        if ( coords.hasOwnProperty(i) ) {
            if ( bbox.contains(coords[i]) ) {
                isInView = true;
                break;
            }
        }
    }
    // corner case test: is the tilesize larger than the viewport
    if ( !isInView ) {
        var mapViewportCoords = {};
        mapViewportCoords.ul = new Position(bbox.maxPosition.lat, bbox.minPosition.lon);
        mapViewportCoords.ur = new Position(bbox.maxPosition.lat, bbox.maxPosition.lon);
        mapViewportCoords.lr = new Position(bbox.minPosition.lat, bbox.maxPosition.lon);
        mapViewportCoords.ll = new Position(bbox.minPosition.lat, bbox.minPosition.lon);
        var tileBBox = new BoundingBox(coords.ll, coords.ur);
        for ( i in mapViewportCoords ) {
            if ( mapViewportCoords.hasOwnProperty(i) ) {
                if ( tileBBox.contains(mapViewportCoords[i]) ) {
                    isInView = true;
                    break;
                }
            }
        }
    }

    if ( isInView ) {
        return true;
    }
    else {
        return false;
    }
};

/**
 * Applies the images within a MapLayer to the passed in DOM object.
 * @param {DOM Element} mapDOMElement required The DOM element to append the map tiles
 * to.
 */
deCarta.MapLayer.prototype.appendTiles = function( mapDOMElement ) {
    
    for ( var x = 0; x < this.xTiles; x++ ) {
        for ( var y = 0; y < this.yTiles; y++ ) {
            mapDOMElement.appendChild( this.tileArray[x][y] );
        }
    }
};

/**
 * Hides a layer from view. Only performs if the layer is not currently shown.
 */
deCarta.MapLayer.prototype.hide = function() {

    
    if ( !this.isVisible ) {
        return;
    }
    // else...
    var x, y; // counters

    // Set layer status
    // This status change will also affect the way setSrc is used
    this.isVisible = false;
    for ( x = 0; x < this.xTiles; x++ ) {
        for ( y = 0; y < this.yTiles; y++ ) {
            this.tileArray[x][y].hide();
        /*this.tileArray[x][y].style.display = "none";
            Utilities.setOpacity(this.tileArray[x][y], 0);*/
        }
    }
};

/**
 * Makes a layer visible. Only performs if the layer is currently hidden.
 */
deCarta.MapLayer.prototype.show = function() {

    
    if ( this.isVisible ) {
        return;
    }
    // else...
    var x, y; // counters

    // Layer status will affect how setSrc was used, but we rely on
    // altSrc always being available
    this.isVisible = true;
    for ( x = 0; x < this.xTiles; x++ ) {
        for ( y = 0; y < this.yTiles; y++ ) {
            var currentTile = this.tileArray[x][y];
            // We cheat here, assuming the src is already blank
            //currentTile.style.display = "block";
            //currentTile.setSrc(currentTile.altSrc);
            var altSrc = currentTile.altSrc.replace(/\:80/,"");
            var src = currentTile.src.replace(/\:80/,"");

            if (altSrc != src && this.refUrl){
                currentTile.setSrc(currentTile.altSrc);
            }
            currentTile.show();
        /*

            if(altSrc!=src && this.refUrl){
                currentTile.setSrc(currentTile.altSrc);
            }
            if (currentTile.style.opacity == 0 && currentTile.delayedShow ){
                this.delayedShow = false;
                currentTile.show();
                /*
                Utilities.setOpacity(currentTile, 0);
                currentTile.style.display = "block";
                Utilities.fade(currentTile, {from: 0, to: 70});*/
        //}
        }
    }
};

/**
 * Resets all previously created tiles to their initial position, the initial
 * src, and resets the tiles and the layer to the inital state of hidden.
 * This is a forceful function and will perform no matter the current
 * state of the MapLayer. Do not call this function prior to initialization.
 * @param {number} addOffsetX optional Additional offsetX to be applied to
 * the tile repositioning. Designed to be used after the map div has been
 * dragged and not reset to the initial starting position.
 * @param {number} addOffsetY optional Additional offsetY to be applied to
 * the tile repositioning. Designed to be used after the map div has been
 * dragged and not reset to the initial starting position.
 * @param {number} xOffset optional Reset the xOffset value
 * @param {number} yOffset optional Reset the yOffset value
 */
deCarta.MapLayer.prototype.reset = function( addOffsetX, addOffsetY, xOffset,yOffset ) {
    
    this.refUrl=null;
    if(xOffset) this.xOffset=xOffset;
    if(yOffset) this.yOffset=yOffset;
    var x, y; // counters
    var mapTileLeft, mapTileTop, currentTile;
    var px = "px";
    // Additional offsets if needed to correctly position the tiles
    addOffsetX = addOffsetX || 0;
    addOffsetY = addOffsetY || 0;

    // Assuming that we'll be reloading the tiles, reset the numTilesLoaded
    this.numTilesLoaded = 0;
    this.isVisible = false;
    // Indexes are back at zero
    this.leftIndex = 0;
    this.topIndex  = 0;
    // Update from center values
    this.updateFromCenterVals();
    for ( x = 0; x < this.xTiles; x++ ) {
        mapTileLeft = this.xOffset+addOffsetX+(x*this.tileSize);
        for ( y = 0; y < this.yTiles; y++ ) {
            currentTile = this.tileArray[x][y];
            currentTile.tileViewed = false;
            currentTile.style.display = "none";
            //when reset, we should set the src to srcOnHidden or "";
            if ( this.srcOnHidden ) {
                currentTile.altSrc = this.srcOnHidden;
                currentTile.src = this.srcOnHidden;
                if(currentTile.loader) currentTile.loader.src=this.srcOnHidden;
            }
            else {
                currentTile.altSrc = "";
                currentTile.src = "";
                if(currentTile.loader) currentTile.loader.src="";
            }
            // Reposition
            mapTileTop = this.yOffset+addOffsetY+(y*this.tileSize);
            currentTile.style.left = mapTileLeft+px;
            currentTile.style.top = mapTileTop+px;
        }
    }
};
/**
 * Reloads all of the src attributes of the MapTile img tags. To be used when
 * a url within a layer has been changed dynamically.
 */
deCarta.MapLayer.prototype.refresh = function() {
    
    var x, y;
    for ( x = 0; x < this.xTiles; x++ ) {
        for ( y = 0; y < this.yTiles; y++ ) {
            var tileToRefresh = this.tileArray[x][y];
            tileToRefresh.setSrc( this.refUrl.getRelSrc(tileToRefresh.fromCenterY, tileToRefresh.fromCenterX) );
        }
    }
};
/**
 * When the threshold of the tiles is passed, a flip event will be executed
 * by the map and this method will be called on each layer. This function
 * will change the index reference of the MapLayer and flip the on screen map
 * tiles. The terminology used here for cardinal directions are all relative
 * to the viewport of the map. For example, a click and mouse drag to the
 * west part of the screen is actually panning viewport to the east by moving
 * the map beneath the viewport.
 * @param {number} ns required Positive number indicates that the map has been
 * panned to the north and boundary edge tiles will be flipped from the bottom
 * to the top. Negative number indicates that the map has been panned to the
 * south and the boundary edge tiles will be flipped from top to bottom. Falsey
 * values will not cause a north/south flip.
 * @param {number} ew required Positive number indicates that the map has been
 * panned to the east and boundary edge tiles will be flipped from the left to
 * the right. Negative number indicates that the map has been dragged to the
 * west and the boundary edge tiles will be flipped from right to left. Falsey
 * values will not cause a east/west flip.
 */
deCarta.MapLayer.prototype.rotateTiles = function( ns, ew ) {
    

    // Loop counters
    var x, y;
    // Local access for variables
    var yTiles = this.yTiles;
    var xTiles = this.xTiles;
    var tileSize = this.tileSize;
    // The actual tile we will flip
    var tileToFlip;
    // What index of tiles will we be moving
    var tileIndexToFlip;
    // Used to compute the new on page tile location, either left or top
    var newTilePosition = 0;
    // For computation of the new Northing and Easting
    var flipDirection;
    // URL handling
    var tmp;
    // We should only ever call one flip or the other at a time, so we only
    // do the first value that works.
    if ( ns ) {
        // If we get a North pan event, that means that all the tiles on the bottom
        // row need to be flipped to the new top row.
        // If we get a South pan event, that means that all the tiles on the top
        // row need to be flipped to the new bottom row.
        // Flip is either positive or negative at this point because 0 will fail
        if ( ns > 0 ) {
            // NORTH pan, top to bottom rotate
            // Remember that -1 from the upper left corner should put us, with
            // the correction below, at the bottom.
            this.topIndex -= 1;
            // Correct the index first
            if ( this.topIndex < 0 ) {
                this.topIndex = yTiles - 1;
            }
            tileIndexToFlip = this.topIndex;
            newTilePosition -= yTiles*tileSize;
            // The northing is unconstrained
            flipDirection = 1;
        }
        else {
            // ns < 0
            // SOUTH pan, bottom to top rotate
            tileIndexToFlip = this.topIndex;
            this.topIndex += 1;
            // Correct the index
            if ( this.topIndex >= yTiles ) {
                this.topIndex = 0;
            }
            // Flip from the top to the bottom
            newTilePosition += yTiles*tileSize;
            // The northing is unconstrained
            flipDirection = -1;
        }
        // Before we update the tiles, update their relative locations
        this.updateFromCenterVals();
        this.refUrl.pan(flipDirection, 0);


        var sortArray = [];
        for ( x = 0; x < xTiles; x++ ) {

            sortArray.push( this.tileArray[x][tileIndexToFlip]);


        }
        sortTiles( sortArray );

        for(x=0;x<sortArray.length;x++){
            //for ( x = 0; x < xTiles; x++ ) {
            // Move the tile relative to the type of rotate/flip this is
            //tileToFlip = this.tileArray[x][tileIndexToFlip];
            tileToFlip = sortArray[x];
            tmp = parseInt(tileToFlip.style.top) + newTilePosition;
            tileToFlip.style.top = (tmp)+"px";

            if (this.onlyLoadTilesInViewport) {
                tileToFlip.setTileCoords( this.refUrl );
            }

            tileToFlip.setSrc( this.refUrl.getRelSrc(tileToFlip.fromCenterY, tileToFlip.fromCenterX) );
        }
        // Break out of the function when done
        return;
    }
    if ( ew ) {
        // If we get an East pan event, that means that all the tiles in the left
        // column need to be flipped to the new right column.
        // If we get a West pan event, that means that all the tiles in the right
        // column need to be flipped to the new left row.
        // Flip is either positive or negative at this point because 0 will fail
        if ( ew > 0 ) {
            // EAST
            // The tile to actually flip when going east is the "right"
            // Remember that -1 from the upper left corner should put us, with
            // the correction below, into the correct new left
            tileIndexToFlip = this.leftIndex;
            this.leftIndex += 1;
            // Correct the index
            if ( this.leftIndex >= xTiles ) {
                this.leftIndex = 0;
            }
            // Flip from the left
            newTilePosition += xTiles*tileSize;
            // The easting is unconstrained
            flipDirection = 1;
        }
        else {
            // ew < 0
            // WEST
            this.leftIndex -= 1;
            // Correct the index first
            if ( this.leftIndex < 0 ) {
                this.leftIndex = xTiles - 1;
            }
            tileIndexToFlip = this.leftIndex;
            newTilePosition -= xTiles*tileSize;
            // The easting is unconstrained
            flipDirection = -1;
        }
        // Before we update the tiles, update the relative locations
        this.updateFromCenterVals();
        this.refUrl.pan(0, flipDirection);

        sortArray = [];
        for ( y = 0; y < yTiles; y++ ) {
            sortArray.push( this.tileArray[tileIndexToFlip][y]);
        }
        //@TODO : change this to a sortArray.sort(function())
        sortTiles( sortArray );

        for(y=0;y<sortArray.length;y++){
            //for ( y = 0; y < yTiles; y++ ) {
            // Move the tile relative to the type of rotate/flip this is
            //tileToFlip = this.tileArray[tileIndexToFlip][y];
            tileToFlip = sortArray[y];
            tmp = parseInt(tileToFlip.style.left) + newTilePosition;
            tileToFlip.style.left = (tmp)+"px";

            if (this.onlyLoadTilesInViewport) {
                tileToFlip.setTileCoords( this.refUrl );
            }

            tileToFlip.setSrc( this.refUrl.getRelSrc(tileToFlip.fromCenterY, tileToFlip.fromCenterX) );
        }
    }


    //------------------------------------------------------------- Sort Utils
    /**
     * bubble sort the tiles according to distance from the center of screen.
     * @inner
     */
    function sortTiles(array2) {
        for (var pass = 1; pass < array2.length; pass++) {
            for (var element = 0; element < array2.length - 1; element++) {
                if ( (Math.abs(array2[element].fromCenterX)+Math.abs(array2[element].fromCenterY)) >
                    (Math.abs(array2[element+1].fromCenterX)+Math.abs(array2[element+1].fromCenterY)) ) {
                    swap( array2, element, element+1 );
                }
            }
        }
    }
    /**
     * utility ordering function for sortTiles
     * @inner
     */
    function swap(array3, first, second) {
        var hold;
        hold = array3[first];
        array3[first] = array3[second];
        array3[second] = hold;
    }
}; /* end MapLayer rotateTiles */



/**
 * Perform a digital zoom on the MapLayer, which pushes the standard map images
 * to the background and digitally zooms them in or out, leaving the front
 * map images ready to be refilled with new tiles.
 * NOTE: ONLY 1 MapLayer should ever have zoom called on it at a time and
 * only when no other zoom is being performed.
 * @param {number} factor required The integer level to zoom in (positive) or
 * out (negative).
 * @param {ZoomLayer} zoomLayer required What we will use to perform the zoom.
 * @param {number} deltaX optional The sub-tilesize shift currently in effect
 * in the X direction.
 * @param {number} deltaY optional The sub-tilesize shift currently in effect
 * in the Y direction.
 */
deCarta.MapLayer.prototype.zoom = function( factor, zoomLayer, deltaX, deltaY, callback) {
    
    if ( !this.isVisible ) {
        // No zoom when invisible
        return;
    }
    // Fire off the zoom for 'this' MapLayer, pass on other vars
    zoomLayer.zoom( factor, this, deltaX, deltaY, callback);
};


/**
 * Called by the Map instance and is fed the URL for the center
 * tile. It is the job of this method to fill the remainder of the tiles in
 * the MapLayer from this initial URL.
 * @param {deCarta.MapLayerReferenceUrl} refUrl required A url generator object
 * that corresponds to the center tile of the Map tile grid.
 */
deCarta.MapLayer.prototype.populate = function( refUrl ) {
    

    // Set our reference tile
    this.refUrl = refUrl;

    // Gather up the tiles in an array.
    var x, y, i;
    var sortArray = [];
    var sortIndex = 0;
    var numTiles;
    for ( x = 0; x < this.xTiles; x++ ) {
        for ( y = 0; y < this.yTiles; y++ ) {
            sortArray[sortIndex] = this.tileArray[x][y];
            sortIndex++;
        }
    }
    numTiles = sortArray.length;
    sortTiles( sortArray );

    // Populate the tiles with the correct urls
    for ( i = 0; i < numTiles; i++ ) {
        if ( this.onlyLoadTilesInViewport ) {
            sortArray[i].setTileCoords( refUrl );
        }
        // Change northing and easting and display the tile
        sortArray[i].setSrc( refUrl.getRelSrc(sortArray[i].fromCenterY, sortArray[i].fromCenterX) );
    }

    //------------------------------------------------------------- Sort Utils
    /**
     * bubble sort the tiles according to distance from the center of screen.
     * @inner
     */
    function sortTiles(array2) {
        for (var pass = 1; pass < array2.length; pass++) {
            for (var element = 0; element < array2.length - 1; element++) {
                if ( (Math.abs(array2[element].fromCenterX)+Math.abs(array2[element].fromCenterY)) >
                    (Math.abs(array2[element+1].fromCenterX)+Math.abs(array2[element+1].fromCenterY)) ) {
                    swap( array2, element, element+1 );
                }
            }
        }
    }
    /**
     * utility ordering function for sortTiles
     * @inner
     */
    function swap(array3, first, second) {
        var hold;
        hold = array3[first];
        array3[first] = array3[second];
        array3[second] = hold;
    }

};

/**
 * Updates the map tile distance from the center tile values relative to the
 * current leftIndex and topIndex values. This will most likely be called on
 * a tile flip.
 */
deCarta.MapLayer.prototype.updateFromCenterVals = function() {
    
    // Boundary conditions, used to help with round-world grid calculations
    var xTiles = this.xTiles;
    var yTiles = this.yTiles;
    var maxX = Math.floor( xTiles/2 );
    var minX = -maxX;
    var maxY = Math.floor( yTiles/2 );
    var minY = -maxY;
    var leftIndex = this.leftIndex;
    var topIndex = this.topIndex;
    // Figure out the array index location of the current center tile
    var centerX, centerY;
    if ( leftIndex > maxX ) {
        centerX = leftIndex - maxX - 1;
    } else {
        centerX = leftIndex + maxX;
    }
    if ( topIndex > maxY ) {
        centerY = topIndex - maxY - 1;
    } else {
        centerY = topIndex + maxY;
    }
    var tileArray = this.tileArray;
    var x, y;
    // We know the array index of our center tile, now figure out the relative
    // distance of the tiles from our center, conforming to the X and Y boundaries
    // (maxX, minX, maxY, minY)
    for ( x = 0; x < xTiles; x++ ) {
        for ( y = 0; y < yTiles; y++ ) {
            var tile = tileArray[x][y];
            // X first: distance between array elements
            var arrayXDist = x - centerX;
            // Enforce boundaries and "wrapping" in X direction
            if ( arrayXDist > maxX ) {
                tile.fromCenterX = arrayXDist - xTiles;
            } else if ( arrayXDist < minX ) {
                tile.fromCenterX = arrayXDist + xTiles;
            } else {
                // No boundary wrapping needed
                tile.fromCenterX = arrayXDist;
            }
            // Y second:  distance between array elements
            var arrayYDist = centerY - y;
            // Enforce boundaries and "wrapping" in X direction
            if ( arrayYDist > maxY ) {
                tile.fromCenterY = arrayYDist - yTiles;
            } else if ( arrayYDist < minY ) {
                tile.fromCenterY = arrayYDist + yTiles;
            } else {
                // No boundary wrapping needed
                tile.fromCenterY = arrayYDist;
            }
        }
    }

};

/**
 *Called when map layere needs resize, add or remove map tiles to the existing tile array div
 */
deCarta.MapLayer.prototype.resize = function(xTiles, yTiles){
    if(xTiles == this.xTiles && yTiles == this.yTiles){
        return;
    }

    var tileArray = [];       // Make 2 dimensional below
    var top=parseInt(this.tileArray[this.leftIndex][this.topIndex].style.top);
    var left=parseInt(this.tileArray[this.leftIndex][this.topIndex].style.left);
    var centerX=Math.floor(this.xTiles/2);
    var centerY=Math.floor(this.yTiles/2);

    //remove unused tiles when resize
    var x=0;
    var y=0;
    var relX;
    var relY;
    for(x=0;x<this.xTiles;x++){
        for(y=0;y<this.yTiles;y++){
            relX=(x-this.leftIndex);
            if(relX<0) relX+=this.xTiles;
            relY=(y-this.topIndex);
            if(relY<0) relY+=this.yTiles;
            if(relX>=xTiles || relY>=yTiles){
                //remove this tile, and destroy it
                this.owner.getTileDiv().removeChild(this.tileArray[x][y]);
                this.tileArray[x][y]=null;
            }
        }
    }

    //add additional tiles when resize
    for ( x = 0; x < xTiles; x++ ) {
        // Add 2nd dimension
        tileArray[x] = [];
        // Create the initial MapLayer grid of images such that we can simply
        // call an offset later.
        for ( y = 0; y < yTiles; y++ ) {
            if(x<this.xTiles && y<this.yTiles){
                relX=(this.leftIndex+x) % this.xTiles;
                relY=(this.topIndex+y)%this.yTiles;
                tileArray[x][y]=this.tileArray[relX][relY];
            }
            else {
                tileArray[x][y] = this.mapTileFactory( x, y );
                tileArray[x][y].style.top=(top+y*this.tileSize)+"px";
                tileArray[x][y].style.left=(left+x*this.tileSize)+"px";
                if (this.onlyLoadTilesInViewport) {
                    tileArray[x][y].setTileCoords( this.refUrl );
                }
                tileArray[x][y].setSrc(this.refUrl.getRelSrc(centerY-y,x-centerX ));
                this.owner.getTileDiv().appendChild(tileArray[x][y]);
            }


        }

    }
    this.refUrl.pan(-(yTiles-this.yTiles)/2, (xTiles-this.xTiles)/2);
    this.tileArray=tileArray;
    this.xTiles=xTiles;
    this.yTiles=yTiles;
    this.leftIndex=0;
    this.topIndex=0;
    this.updateFromCenterVals();


};

/**
 * Called when this map layer needs to purge the DOM elements that it contains.
 * Provided to prevent IE memory leakage.
 */
deCarta.MapLayer.prototype.destroy = function() {
    
    var x, y;

    for ( x = 0; x < this.xTiles; x++ ) {
        for ( y = 0; y < this.yTiles; y++ ) {
            Utilities.purge( this.tileArray[x][y] );
        }
    }
};



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------


/**
 * @class To lighten the load on the map layers, a ZoomLayer controls digital
 * zooming of a map. It operates independently from the other map layers; map
 * tile information is passed to the zoom layer and the zoom is performed by
 * this object.
 * A ZoomLayer is useless without a {@link Map} and {@link MapLayer}s to be
 * zoomed.
 * @description Construct a new ZoomLayer.
 * @param {number} xTiles required The integer number tiles in a horizontal
 * direction.
 * @param {number} yTiles required The integer number of tiles in a vertical
 * direction.
 * @param {number} tileSize required The pixel dimensions square of each tile
 * in this layer.
 * @private
 * @constructor
 */
deCarta.ZoomLayer = function( xTiles, yTiles, tileSize ) {
    this.init( xTiles, yTiles, tileSize );
};
//
//
//
// ZoomLayer fields
/**
 * The total number of frames to use in a digital zoom animation.
 * @type number
 * @default 3
 */
deCarta.ZoomLayer.prototype.framesTotal = 4;
/**
 * Frames per second in the zooming animation
 * @type number
 * @default 30
 **/
deCarta.ZoomLayer.prototype.fps = 20;
/**
 * Amount of time between each frame of zoom animation.
 * @type number
 * @default Calculated on FPS
 */
deCarta.ZoomLayer.prototype.msPerFrame = 1000 / deCarta.ZoomLayer.prototype.fps;

/**
 * The number of horizontal tiles.
 * Consider access to this property read-only.
 * @type number
 * @default null
 */
deCarta.ZoomLayer.prototype.xTiles = null;
/**
 * The number of vertical tiles.
 * Consider access to this property read-only.
 * @type number
 * @default null
 */
deCarta.ZoomLayer.prototype.yTiles = null;
/**
 * The pixel dimension of each MapTile. Each tile is required
 * to be square.
 * Consider access to this property read-only.
 * @type number
 * @default null
 */
deCarta.ZoomLayer.prototype.tileSize = null;
/**
 * An identifying name. Required by other Map methods.
 * Consider access to this property read-only.
 * @type string
 * @default "zoomLayer"
 */
deCarta.ZoomLayer.prototype.layerName = "zoomLayer";
/**
 * A CSS className string that will be associated with each tile in the zoom
 * layer.
 * Consider access to this property read-only.
 * @type string
 * @default "decarta-maptile"
 */
deCarta.ZoomLayer.prototype.cssClass = "decarta-maptile";
/**
 * The default CSS z-index applied to the tiles within this layer.
 * Consider access to this property read-only.
 * @type number
 * @default 0
 */
deCarta.ZoomLayer.prototype.cssZIndex = 20;
/**
 * Holds the array of DOM elements (most likely IMG elements) that make up
 * the on screen view.
 * Consider access to this property read-only.
 * @type Array (2 dimensional)
 * @default null
 */
deCarta.ZoomLayer.prototype.tileArray = null;
/**
 * Location of an image placeholder for when this image layer is meant to be
 * invisible.
 * This is usually a transparent PNG or GIF (for old IE6). Set during map
 * layer construction. Feel free to reset this to an "invisible" image of
 * your choice after the ZoomLayer has been constructed.
 * @type string
 * @default null
 */
deCarta.ZoomLayer.prototype.srcOnHidden = null;
/**
 * Location of an image placeholder for when loading an image produces an error.
 * Set during the map layer construction. Feel free to reset to an error image
 * of your choice after the ZoomLayer has been constructed.
 * @type string
 * @default null
 */
deCarta.ZoomLayer.prototype.srcOnError = null;
/**
 * Indicator of viewability of this maplayer. This should be treated as a
 * read only field and not modified directly: use the show and hide methods
 * instead.
 * Consider access to this property read-only.
 * @type boolean
 * @default false
 * @private
 */
deCarta.ZoomLayer.prototype.isVisible = false;
//
//
//
// ZoomLayer public methods
/**
 * Initialize all settings. Called automatically from the constructor.
 * Documentation for the paramters exists with the constructor.
 * @private
 */
deCarta.ZoomLayer.prototype.init = function( xTiles, yTiles, tileSize ) {
    
    // Local Variables
    // Counters
    var x, y;
    // Init constructor fields
    this.xTiles = xTiles;
    this.yTiles = yTiles;
    this.tileSize = tileSize;

    // Init automatic fields
    this.tileArray = [];       // Make 2 dimensional below
    this.setDefaultSrc();

    /* Create a container DIV for the zoom layer. Makes things easier
		and _maybe_ faster. We shall see.
	*/
    this.domElement = document.getElementById('decarta-digitalZoomLayer');
    if (!this.domElement)
        this.domElement = document.createElement('div');

    this.domElement.id = 'decarta-digitalZoomLayer';
    this.domElement.style.position = 'absolute';
    this.domElement.style.top = 0;
    this.domElement.style.left = 0;
    this.domElement.style.width = (xTiles * tileSize) + 'px';
    this.domElement.style.height = (yTiles * tileSize) + 'px';

    // Build MapTiles and populate tileArray
    // Horizontal in first array, vertical filled "down" in 2nd dimension
    for ( x = 0; x < this.xTiles; x++ ) {
        // Add 2nd dimension
        this.tileArray[x] = [];
        // Create the initial ZoomLayer grid of images such that we can simply
        // call an offset later.
        for ( y = 0; y < this.yTiles; y++ ) {
            this.tileArray[x][y] = this.mapTileFactory( x, y );
        }
    }
};
/**
 * Configures the default images for this ZoomLayer.
 * Uses settings from the Credentials object.
 */
deCarta.ZoomLayer.prototype.setDefaultSrc = function() {
    
    if (!Utilities.ie6) {
        this.srcOnHidden = Credentials.transparentPNG;
        // This is to support historical usage of invisible images on error.
        // Perhaps this is because people didn't like the satellite image
        // error tiles.
        this.srcOnError = Credentials.transparentPNG;
    }
    else {
        // yippeee IE6....
        this.srcOnHidden = Credentials.transparentGIF;
        this.srcOnError = Credentials.transparentGIF;
    }
};
/**
 * The basic onerror event for images.
 * This function should be tied into a map tile onerror event.
 * @param {Event} event required Passed in by most browsers or not on IE
 * browsers.
 */
deCarta.ZoomLayer.prototype.mapTileOnError = function(event) {
    
    var tile;
    if ( !event ) {
        tile = window.event.srcElement;
    } else {
        tile = event.currentTarget;
    }
    if ( tile && tile.src && tile.srcOnError ) {
        tile.src = tile.srcOnError;
    }
};
/**
 * Used to generate a Maptile specific to the ZoomLayer.
 * The MapTile is an extended HTML DOM Img.
 * Zoom tiles are simplified since they are repositioned before a zoom.
 * @returns {Image} Image DOM element configured with default Map tile
 * properties and styles.
 */
deCarta.ZoomLayer.prototype.mapTileFactory = function(x, y) {
    

    // used in calculations below
    var px = "px";
    var centerX = Math.floor( this.xTiles/2 );
    var centerY = Math.floor( this.yTiles/2 );

    var mapTile = document.createElement("IMG");
    //
    // Custom settings for this image
    // Relative distance of this tile from the center of the tile grid
    mapTile.fromCenterX = x - centerX;
    mapTile.fromCenterY = centerY - y;
    // @todo each tile should get an ID
    // Propagate the ZoomLayer general defaults onto this image
    mapTile.className = this.cssClass;
    mapTile.altSrc = this.srcOnHidden;
    mapTile.src = this.srcOnHidden;
    mapTile.style.zIndex = this.cssZIndex;
    mapTile.style.height = this.tileSize+px;
    mapTile.style.width = this.tileSize+px;
    mapTile.onerror = this.mapTileOnError;
    mapTile.id = "Tile_" + x + "_" + y +"_zoom";
    // Unlike normal map tiles, we don't need to set the zoom layer offsets
    // Make the map tiles unselectable by errant drags
    Utilities.setUnselectable(mapTile);

    mapTile.setSrc = deCarta.ZoomLayer.setSrc;
    return mapTile;
};

/**
 * Used by non-ie6 browsers to set the source of a map tile.
 * @static
 */
deCarta.ZoomLayer.setSrc = function( src ) {
    // Too much noise, turn logging on manually.
    //

    // If the layer is visible, also update the regular src
    this.src = src;
};

/**
 * Applies the images within a ZoomLayer to the passed in DOM object.
 * @param {DOM Element} mapDOMElement required The DOM element to append the map tiles
 * to.
 */
deCarta.ZoomLayer.prototype.appendTiles = function( mapDOMElement ) {

    /* modify to append to the domElement, which will be appended to the main map elem */
    
    for ( var x = 0; x < this.xTiles; x++ ) {
        for ( var y = 0; y < this.yTiles; y++ ) {
            this.domElement.appendChild( this.tileArray[x][y] );
        }
    }
    mapDOMElement.appendChild(this.domElement);
};
/**
 * Hides a layer from view. Only performs if the layer is not currently shown.
 */
deCarta.ZoomLayer.prototype.hide = function() {
    
    if ( !this.isVisible ) {
        return;
    }
    // else...
    var x, y; // counters

    // Set layer status
    // This status change will also affect the way setSrc is used
    this.isVisible = false;

    for ( x = 0; x < this.xTiles; x++ ) {
        for ( y = 0; y < this.yTiles; y++ ) {
            //eliminated this since setting display to none should be sufficient
            //this.tileArray[x][y].setSrc( this.srcOnHidden );
            this.tileArray[x][y].style.display = "none";
        }
    }
};
/**
 * Makes the ZoomLayer visible. Only performs if the layer is currently hidden.
 */
deCarta.ZoomLayer.prototype.show = function() {
    
    if ( this.isVisible ) {
        return;
    }
    // else...
    var x, y; // counters

    this.isVisible = true;
    for ( x = 0; x < this.xTiles; x++ ) {
        for ( y = 0; y < this.yTiles; y++ ) {
            this.tileArray[x][y].style.display = "block";
        }
    }
};

/**
 * Takes a {@link MapLayer} and transfers it's contents into this ZoomLayer.
 * This method will reorganize the map images so that an animation can be
 * performed assuming the upper left corner is equal to 0,0.
 * A ZoomLayer can only hold the contents of one MapLayer. There currently
 * isn't a concept of stacking map layers; in hybrid maps, we just zoom the
 * satellite layer.
 * @param {MapLayer} layer required The map layer to set up for a zoom.
 */
deCarta.ZoomLayer.prototype.transferSrcFromMapLayer = function( layer ) {

    //As found out in the performZoom optimization, the speed is remarkably
    //increased if the element is temporarily removed from the dom.
    //so here I do it as well since this function is currently profiled at 127ms
    //After the change : 14msec.

    

    // loop variables
    var x, y, realX, realY;
    var px = "px";

    //We also need to check for size - if the map was resized _after_ the
    //zoom layer was initialized, it might have too few tiles to properly zoom
    //This is actually not true anymore, because I am destroying the layer
    //on a map resize (because several things were getting wonky)
    //but the checks might as well stay they will not hurt.

    // Move the src images of the maplayer (foreground) to the zoomLayer that
    // we assume to exist in the background.
    // Align the tiles ASSUMING the tiles exist on the same underlying div as
    // the map layer and will have the same offsets.
    // We also take into account and correct for any flippage that has occurred
    // in the tiles. The realX and realY variables correspond to the to the
    // current location the origin (upper left) tile in the mapLayer

    var restoreElement = Utilities.removeElementToReinsert(this.domElement);

    for ( x = 0; x < layer.xTiles; x++ ) {

        //make sure its there
        if (typeof this.tileArray[x] === 'undefined'){
            //add a column of tiles if necessary
            this.tileArray[x] = [];
        }

        realX = x + layer.leftIndex;
        if ( realX >= layer.xTiles ) {
            realX -= layer.xTiles;
        }
        for ( y = 0; y < layer.yTiles; y++ ) {

            //check for column tiles
            if (typeof this.tileArray[x][y] === 'undefined'){
                this.tileArray[x][y] = this.mapTileFactory(x, y); //and add them
            }

            realY = y + layer.topIndex;
            if ( realY >= layer.yTiles ) {
                realY -= layer.yTiles;
            }
            // this is our ZoomLayer
            //this.tileArray[x][y].setSrc( this.srcOnHidden ); //seems redundant
            this.tileArray[x][y].style.top = layer.tileArray[realX][realY].style.top;
            this.tileArray[x][y].style.left = layer.tileArray[realX][realY].style.left;
            this.tileArray[x][y].style.height = layer.tileSize+px;
            this.tileArray[x][y].style.width = layer.tileSize+px;

            this.tileArray[x][y].setSrc( layer.tileArray[realX][realY].src );
        }
    }
    this.xTiles = layer.xTiles;
    this.yTiles = layer.yTiles;

    restoreElement();
};

/**
 * Perform the digital zoom.
 * @param {number} factor required The integer level to zoom in (positive) or
 * out (negative).
 * @param {MapLayer} mapLayer required The MapTiles that we will zoom.
 * @param {number} deltaX optional The sub-tilesize shift currently in effect
 * in the X direction.
 * @param {number} deltaY optional The sub-tilesize shift currently in effect
 * in the Y direction.
 */
deCarta.ZoomLayer.prototype.zoom = function( factor, mapLayer, deltaX, deltaY, callback) {
    

    // A local copy of our zoomLayer for quicker access, and one that will
    // survive setTimeOut calls.
    var layer = this;

    // Show this particular layer, not a problem because it should always be
    // located below any other layer.
    layer.show();
    // Pull the src we need to our zoom
    layer.transferSrcFromMapLayer( mapLayer );
    // Show ourselves and hide the mapLayer
    // mapLayer.hide();

    // Local copies of our deltas
    var dX = deltaX;
    var dY = deltaY;

    // Work in integers, postive or negative is just fine
    var zoomFactor = Math.pow(2, factor);
    // The direction of the zoom, in (+1) or out (-1)
    var zoomDirection = factor > 0 ? +1 : -1;
    // Total number of frames of animation
    var framesTotal = this.framesTotal;
    // Animation time per frame
    var msPerFrame = this.msPerFrame;
    //var changePerFrame = Math.floor((zoomFactor*layer.tileSize - layer.tileSize) / (framesTotal*2));
    var changePerFrame = Math.floor((zoomFactor*layer.tileSize - layer.tileSize) / (framesTotal));

    // zooming of the images is interesting since the images are originally placed
    // on pane in absolute positining. The draggability of the map comes from
    // the fact that the underlying map foundation div moves around the page
    // and the images follow along.
    // Since that is the case we have to manually control the zoomed images
    // via a correction.
    // - The size of the image will be the same throughout the image matrix.
    // - The basic positioning of the image due to size will be the same throughout
    //   the image layer.
    // - All images will need to have an additional adjustment to their page
    //   position relative to the distance they are from the center image.
    // - The entire MapLayer, and thus the images on the layer, will need
    //   to be adjusted so that the map layer visual center stays in view.
    //   The "stay on center" adjustment is equivalent to the modulo of the
    //   the current real upper left corner to the tilesize of the images.
    //   This works because the relative center of the map is no more than
    //   1 tile off in any direction. This stay on center adjustment is
    //   a factor of the off center distance * the zoom factor.
    // NOTE: the following adjustment matrix only works because in this version
    // of the JSAPI the tile grids will always have a true center image and
    // they will always be odd.
    // The amount of movement will always be a multiplier of the basic zoom
    // factor by the number of array matrix units distance from the center
    var baseXAdjustment = -1 * Math.floor( layer.xTiles / 2 );
    var originalBaseXAdjustment = baseXAdjustment;
    var baseYAdjustment = -1 * Math.floor( layer.yTiles / 2 );
    var originalBaseYAdjustment = baseYAdjustment;
    // These adjustments make up for pan. In an ideal world we could just zoom
    // an image from the center, but in a map application, we need to adjust
    // for panned tiles. This is a uniform shift applied to all of the tiles in
    // the grid.
    // Assuming that an offset of 0,0 means we haven't panned, this doesn't
    // take affect. In our digital zoom, each zoom factor equals:
    //   x2 the linear dimensions
    //   x4 the produced digital area
    // A partially shifted view of the map will need to have its view adjusted
    // by _half_ the final zoomFactor multiplier according to the number of additional
    // pixels we must shift. A zoom in will shift the map more to the negative left
    // and negative top, a zoom out will shift the map more to to the positive left
    // and postive top.
    var stayOnCenterXAdjustment;
    var stayOnCenterYAdjustment;
    if ( factor > 0 ) {
        // We're zooming in
        stayOnCenterXAdjustment = Math.floor(zoomFactor*zoomDirection*dX / (2*framesTotal));
        stayOnCenterYAdjustment = Math.floor(zoomFactor*zoomDirection*dY / (2*framesTotal));
    } else {
        // Zooming out does not require the extra 1/2 adjustment for panning
        stayOnCenterXAdjustment = Math.floor(zoomFactor*zoomDirection*dX / (framesTotal));
        stayOnCenterYAdjustment = Math.floor(zoomFactor*zoomDirection*dY / (framesTotal));
    }
    this.zoomComplete = false;

    // perform the zoom
    performZoom();


    function performZoom() {
        //


        /*Tying something new.

		I have wrapped the tiles in a div. I will remove the div from the dom at the
		start of the update function, change all the css styles, and re-add it.
		According to the google, this reduces the number of full document redraws to 2
		instead of (35? how many tiles do you have) which might male the zoom smoother
		and nicer or it might flicker like crazy. we'll see.

		Profiler results tell us :
		before the change : avg time for performZoom is 28msec
		after the change : avg time is 3.161msec.

		I'd say we have a winner!

		*/
        var startTime = (new Date).getTime();

        var x, y;
        var px = "px"; // Create the template string once
        var xTiles = layer.xTiles;
        var yTiles = layer.yTiles;

        // remove the element - see Utilities for details.
        var restoreElement = Utilities.removeElementToReinsert(layer.domElement);

        /* These are constant for this zoom iteration, extracting them from the loop */
        var widthString = parseInt( layer.tileArray[0][0].style.width ) + changePerFrame + 'px';
        var heightString = parseInt( layer.tileArray[0][0].style.height ) + changePerFrame + 'px';

        for ( x = 0; x < xTiles ; x++ ) {
            //this is constant for the col, moving it out here
            var leftPos = parseInt( layer.tileArray[x][0].style.left ) - changePerFrame/2 + baseXAdjustment*changePerFrame + stayOnCenterXAdjustment+px;
            for ( y = 0; y < yTiles ; y++ ) {
                // Find the tile to operate on once
                var currentTile = layer.tileArray[x][y];
                // Bump the position the same factor as the width and height
                currentTile.style.width = widthString;
                currentTile.style.height = heightString;
                currentTile.style.left = leftPos;
                currentTile.style.top = parseInt( currentTile.style.top ) - changePerFrame/2 + baseYAdjustment*changePerFrame + stayOnCenterYAdjustment+px;
                // Adjust the Y factor adjustment
                baseYAdjustment += 1;
            }
            // Adjust the X factor adjustment
            baseXAdjustment += 1;
            // Reset for next round
            baseYAdjustment = originalBaseYAdjustment;
        }
        // Reset for next round
        baseXAdjustment = originalBaseXAdjustment;
        framesTotal -= 1;

        restoreElement();

        var endTime = (new Date).getTime();
        if ( framesTotal ){
            var elapsed = (endTime - startTime);
            var nextIteration = this.msPerFrame - elapsed;
            setTimeout( performZoom, Math.max(nextIteration, 25)); //40 fps is ok i think
        } else {
            layer.zoomComplete = true;
            if (typeof callback === 'function') callback();
        }
    // else quit
    } /* end performZoom() */
};

/**
 * Called when we need to purge the DOM elements.
 * Provided to prevent IE memory leakage.
 */
deCarta.ZoomLayer.prototype.destroy = function() {
    

    var x, y;

    for ( x = 0; x < this.xTiles; x++ ) {
        for ( y = 0; y < this.yTiles; y++ ) {
            var tile = this.tileArray[x][y];
            Utilities.purge( tile );
            if (tile.parentNode)
                tile.parentNode.removeChild(tile);
        }
    }
};

/**
 * @fileoverview URL generator for MapLayers.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class The MapLayerReferenceUrl class handles deCarta dynamic map tile
 * creation for the various {@link MapLayer}s when the map is panned. Constructed
 * inside by a {@link Map} object and passed to the MapLayer.
 * @description Construct a new MapLayerReferenceUrl object.
 * @param {string} url required Corresponds to the central image for the central
 * MapLayer tile.
 * @param {number} hostAliases optional If not falsey, an integer number of
 * alternate aliases that can be used to generate alternate URLs. Falsey values,
 * including 0, mean no host aliases will be generated.
 * @constructor
 * @private
 */
deCarta.MapLayerReferenceUrl = function( url, hostAliases ) {
    this.init(url, hostAliases);
};
/**
 * The base URL used to construct this object. Saved in case we need to reuse
 * it within other set-up functions, which we need to do right now.
 * Read only property.
 * @type string
 * @default null
 */
deCarta.MapLayerReferenceUrl.prototype.baseUrl = null;
/**
 * Array of imageHosts that can be used to round robin the map tile image
 * requests to. Helps work around the limited number of simultaneous connections
 * to a host problem in older browsers. If there is only one host associated
 * with this map layer, length is one.
 * The host of the src url for a map tile is considered to be the following:
 * http://host.name.plus.maybe:port/service/othername/TILE?
 * 
 * And the first alias is defined to be, taking the above example:
 * http://host-1.name.plus.maybe:port/service/othername/TILE?
 *
 * Read only property.
 * @type array
 * @default null
 */
deCarta.MapLayerReferenceUrl.prototype.imageHosts = null;
/**
 * Quick reference to the number of hosts associated with this url generator.
 * Must always equal the length of the hostAliases array. Must be 1 or more.
 * Read only property.
 * @type number
 * @default null
 */
deCarta.MapLayerReferenceUrl.prototype.numImageHosts = null;
/**
 * If image hosts are aliased, will be the value of the next host to be
 * used.
 * @type number
 * @default null
 */
deCarta.MapLayerReferenceUrl.prototype.nextImageHost = null;
/**
 * A string of static properties sent back to the server. These properties
 * will be appended directly to the host, and the dynamic properties will
 * be appended after this string.
 * @type string
 * @default null
 */
deCarta.MapLayerReferenceUrl.prototype.staticProps = null;
/**
 * An object containing access to the dynamic properties that are sent back
 * to the image server. These are special properties that are known to be
 * changed often within the JSAPI. The specific properties are set within the init
 * function and they are:
 * <ul>
 *   <li>dynamicProps.format (equivalent to %FORMAT=val)</li>
 *   <li>dynamicProps.config (equivalent to %CONFIG=val)</li>
 *   <li>dynamicProps.northing (equivalent to %N=val)</li>
 *   <li>dynamicProps.easting (equivalent to %E=val)</li>
 *   <li>dynamicProps.llMax (equivalent to %LLMAX=lat,lon) (will be kept as a string to prevent loss of precision)</li>
 *   <li>dynamicProps.llMin (equivalent to %LLMIN=lat,lon) (will be kept as a string to prevent loss of precision)</li>
 * </ul>
 * @type object
 * @default null
 */
deCarta.MapLayerReferenceUrl.prototype.dynamicProps = null;
/**
 * Static regex used to clean up the URL.
 * Read only property.
 * @type regex
 */
deCarta.MapLayerReferenceUrl.prototype.urlregx = new RegExp("\\amp;", "g");
/**
 * Initialize the MapLayerReferenceUrl. Please see the class constructor
 * for definition of the method parameters.
 */
deCarta.MapLayerReferenceUrl.prototype.init = function( url, hostAliases ) {
    
    this.baseUrl = url;
    // Set up the dynamic properties
    this.dynamicProps = {};
    this.dynamicProps.northing = 0;
    this.dynamicProps.easting = 0;
    this.llMax = null;
    this.llMin = null;
    this.dynamicProps.format = "";
    this.dynamicProps.config = "";
    // Create the host alias array and num hosts
    this.imageHosts = [];
    this.nextImageHost = 0;
    if ( hostAliases ) {
        this.numImageHosts = hostAliases + 1; // We work in total number of hosts
    } else {
        this.numImageHosts = 1; // We must have at least 1
    }
    // Because the three different layers require different set-up, they will
    // be initialized in their own config functions.
};
/**
 * Retrieves just the host name of our URL.
 * @returns {string} Whatever is passed into the URL as a fully qualified host
 * name, including the port if it exists.
 */
deCarta.MapLayerReferenceUrl.prototype.getFullHostName = function() {
    
    var hostEndIndex = this.baseUrl.indexOf("?");
    var baseHost = this.baseUrl.substr(0, hostEndIndex+1);
    // Remove the prefix, and return what's left
    var prefixRe = /^[\S]*\/\/([\S]+)/;
    var hostNamePlusMore = baseHost.replace(prefixRe, "$1");
    // Now we want everything before the slash
    var hostName = hostNamePlusMore.split("/")[0];
    return hostName;
};
/**
 * Retrieves just the protocol of this url.
 * @returns {string} Returns the full string protocol, like "http://" or "https://".
 */
deCarta.MapLayerReferenceUrl.prototype.getProtocol = function() {
    
    var hostEndIndex = this.baseUrl.indexOf("?");
    var baseHost = this.baseUrl.substr(0, hostEndIndex+1);
    // Remove the prefix, and return what's left
    var prefixRe = /^([a-zA-Z:]*\/\/)([\s\S]*)/;
    var protocol = baseHost.replace(prefixRe, "$1");
    // Now we want everything before the slash
    return protocol;
};
/**
 * Using the DDS Web Services scheme for generating host aliases, generate
 * image host aliases if they are available. Even if no image hosts are available
 * this method generates the required base host.
 * The staticProps must have been generated prior to running this method.
 */
deCarta.MapLayerReferenceUrl.prototype.generateHostAliases = function() {
    
    var i; // counter
    // Reset our image host list
    this.imageHosts = [];
    // Location of the '?' used to split the host out
    var hostEndIndex = this.baseUrl.indexOf("?");
    var baseHost = this.baseUrl.substr(0, hostEndIndex+1);

    // Simple one first
    if ( this.numImageHosts == 1 ) {
        this.imageHosts[0] = baseHost + this.staticProps;
        
        return;
    } else {

        // We assume that a host might be
        // * a server name plus a port
        // * a server name but no port
        // * a fully qualified server name plus a port
        // * a fully qualified server name but no port
        // and all along we assume that there will be trailing /this/that
        // First check: The easy one is anything that contains dots
        var hostChunks = baseHost.split(".");
        if ( hostChunks.length > 1 ) {
            // If the baseHost contains dots, than this MUST be a valid way to parse
            var hostFirstChunk = hostChunks[0];
            var hostRemainderChunks = hostChunks.slice(1).join(".");
            // Snip off any alias that appears within the first chunk
            hostFirstChunk = hostFirstChunk.replace(/-[0-9]+$/, "");
            // The first host should always be the base host, sans hyphen number
            // scheme.
            this.imageHosts[0] = hostFirstChunk + "." + hostRemainderChunks + this.staticProps;
            // Build the host aliases
            for ( i = 1; i < this.numImageHosts; i++ ) {
                if ( i < 10 ) {
                    // Need to append a 0 before the host
                    this.imageHosts[i] = hostFirstChunk + "-0" + i + "." + hostRemainderChunks + this.staticProps;
                    continue;
                }
                else {
                    // 10 and greater
                    this.imageHosts[i] = hostFirstChunk + "-" + i + "." + hostRemainderChunks + this.staticProps;
                }
            }
        }
        else {
            // If the base host contains no dots, than we must piece things together
            // the difficult way
            // We MUST have some protocol
            var protocol = this.getProtocol();
            // We MUST have at least a hostname
            var hostName = this.getFullHostName();
            var port = "";
            // We might have a port
            if ( hostName.split(":").length > 1 ) {
                port = ":" + hostName.split(":")[1];
                // Assignments with side effects go second.
                hostName = hostName.split(":")[0];
            }
            // Now we can clean up the host aliasing, if an alias came out first
            hostName = hostName.replace(/-[0-9]+$/, "");
            // Find the first "directory" location
            var hostRemainderIndex = this.baseUrl.indexOf("/", protocol.length);
            // Snip off from the first directory to the previously found hostendindex
            // Remember substr works by length
            var hostRemainder = this.baseUrl.substr(hostRemainderIndex, hostEndIndex+1-hostRemainderIndex);
            // Write out the hosts, the first is not aliased, even if it was previously
            this.imageHosts[0] = protocol + hostName + port + hostRemainder + this.staticProps;
            // Build the host aliases
            for ( i = 1; i < this.numImageHosts; i++ ) {
                if ( i < 10 ) {
                    // Need to append a 0 before the host
                    this.imageHosts[i] = protocol + hostName + "-0" + i + port + hostRemainder + this.staticProps;
                    continue;
                }
                else {
                    // 10 and greater
                    this.imageHosts[i] = protocol + hostName + "-" + i + port + hostRemainder + this.staticProps;
                }
            }
        }
        
    }
};
/**
 * Turns this into a GlobeXplorer ready url.
 */
deCarta.MapLayerReferenceUrl.prototype.createGlobeXplorerUrl = function() {
    

    // loop counter and references
    var i, el, dgkey;
    // Used to finalize static props
    var staticPropArray = [];

    // Grab all of the parameters we need
    var hostNameEnd = this.baseUrl.indexOf("?") + 1;
    var propArray = this.baseUrl.slice(hostNameEnd).split("&");
    var numProps = propArray.length;
    // Grab the dynamic properties, which for globeXplorer are:
    // Northing (&N=)
    // Easting  (&E=)
    for ( i = 0; i < numProps; i++ ) {
        el = propArray[i];
        if ( el.indexOf("N=") == 0 ) {
            // Store northing value of northing param as an integer
            this.dynamicProps.northing = parseInt(el.split("=")[1], 10);
            // Mark this element for removal
            el = null;
        }
        else if ( el.indexOf("E=") == 0 ) {
            // Store easting value of easting param as an integer
            this.dynamicProps.easting = parseInt(el.split("=")[1], 10);
            // Mark this element for removal
            el = null;
        }
        else if ( el.indexOf("LLMIN=") == 0 || el.indexOf("LL=")==0) {
            // Store the LLMIN as a string
            this.dynamicProps.llMin = el.split("=")[1];
            // @TODO Need to make a readonly props. For now, we don't want to remove it from the static props.
            //el = null;
        }
        else if ( el.indexOf("key=") == 0 ) {
            // This is a necessary Kluge to support how the Dev Zone works.
            // Primary directive: If the DDS WS returns a value with the Key, use that value
            if ( el.length > 4 && !Credentials.dgkey ) {
                // Do nothing, we have a key provided by the server
            } else {
                // Make a key with whatever is included in the Credentials
                // GX can handle empty values for the key, and will return the
                // proper 403 error, which can be handled by the MapTile onerror
                dgkey = Credentials.dgkey || "";
                // We want this to become part of the static URL
                el = "key=" + dgkey;
            }
        }

        //for digitalglobe v2 url
        else if(Credentials.projection=='EPSG:3857'){
            if(el=='TileMatrixSet=EPSG:3857'){
                this.isDGSpherical = true;
            }
            else if(el.indexOf("CONNECTID=")==0){
                if(el.length>"CONNECTID=".length && !Credentials.CONNECTID){

                }else{
                    CONNECTID=Credentials.CONNECTID || "";
                    el="CONNECTID="+CONNECTID;
                }
            }
            else if(el.indexOf("TileRow=")==0){
                this.dynamicProps.northing=parseInt(el.split("=")[1]);
                el=null;
            }
            else if(el.indexOf("TileCol=")==0){
                this.dynamicProps.easting=parseInt(el.split("=")[1]);
                el=null;
            }
            else if(el.toLowerCase().indexOf("format=")==0){
                this.dynamicProps.format=el.split("=")[1];
                el=null;
            }
        }
        
        // Push any property into the holder for the static array.
        // Prevents multiple for loops
        if ( el != null ) {
            staticPropArray.push(el);
        }
    }
    // Generate our string of static props
    // We rely on the question marker being part of the host strings
    this.staticProps = staticPropArray.join("&");

    // Right now, globeXplorer won't be generating any aliases.
    this.generateHostAliases();

//  Old GlobeXplorer URL code
//  // Set-up the Digital Globe URL
//	if (Credentials.dgkey != null){
//		this.baseUrl = globeExplorerURL.replace(/key.+?&/,"key="+Credentials.dgkey+"&");
//	}
//	if( URL.dgAliases.length > 0 ) {
//		var index = globeExplorerURL.indexOf("/",7);
//		globeExplorerURL = globeExplorerURL.replace(globeExplorerURL.substring(0,index), "http://"+URL.dgAliases[URL.dgAliasesCount]);
//		if ( URL.dgAliasesCount > URL.dgAliases.length-2 )
//			URL.dgAliasesCount=0;
//		else
//			URL.dgAliasesCount++;
//	}
};
/**
 * Turns this into a deCarta hybrid layer Url.
 */
deCarta.MapLayerReferenceUrl.prototype.createDeCartaTransparentUrl = function() {
    

    // loop counter and references
    var i, el;
    // Used to finalize static props
    var staticPropArray = [];

    // Clean up the baseUrl
    this.baseUrl = this.baseUrl.replace(this.urlregx,"");

    // Grab all of the parameters we need
    var hostNameEnd = this.baseUrl.indexOf("?") + 1;
    var propArray = this.baseUrl.slice(hostNameEnd).split("&");
    var numProps = propArray.length;
    // Grab the dynamic properties, which for the hybrid overlay are:
    // Format   (&FORMAT=)
    // Config   (&CONFIG=)
    // Northing (&N=)
    // Easting  (&E=)
    for ( i = 0; i < numProps; i++ ) {
        el = propArray[i];
        if ( el.indexOf("N=") == 0 ) {
            // Store northing value of northing param as an integer
            this.dynamicProps.northing = parseInt(el.split("=")[1], 10);
            // Mark this element for removal
            el = null;
        }
        else if ( el.indexOf("E=") == 0 ) {
            // Store easting value of easting param as an integer
            this.dynamicProps.easting = parseInt(el.split("=")[1], 10);
            // Mark this element for removal
            el = null;
        }
        else if ( el.indexOf("FORMAT=") == 0 ) {
            // Store the format as a string, hardcoded for now
            this.dynamicProps.format = "PNG";
            // Mark this element for removal
            el = null;
        }
        else if ( el.indexOf("CONFIG=") == 0 ) {
            // Store the config as a string, hardcoded for now
            this.dynamicProps.config = el.split("=")[1];
            // Mark this element for removal
            el = null;
        }
//        else if ( el.indexOf("LLMAX=") == 0 ) {
//            // Store the LLMAX as a string
//            this.dynamicProps.llMax = el.split("=")[1];
//            // @TODO Need to make a readonly props. For now, we don't want to remove it from the static props.
//            //el = null;
//        }
        else if ( el.indexOf("LLMIN=") == 0 || el.indexOf("LL=")==0) {
            // Store the LLMIN as a string
            this.dynamicProps.llMin = el.split("=")[1];
            // @TODO Need to make a readonly props. For now, we don't want to remove it from the static props.
            //el = null;
        }
        // Push any property into the holder for the static array.
        // Prevents multiple for loops
        if ( el != null ) {
            staticPropArray.push(el);
        }
    }
    // Generate our string of static props
    // We rely on the question marker being part of the host strings
    this.staticProps = staticPropArray.join("&");
    // We might have host aliases
    this.generateHostAliases();
};
/**
 * Turns this into a deCarta street map layer url.
 */
deCarta.MapLayerReferenceUrl.prototype.createDeCartaUrl = function() {
    

    // loop counter and references
    var i, el;
    // Used to finalize static props
    var staticPropArray = [];

    // Clean up the baseUrl
    this.baseUrl = this.baseUrl.replace(this.urlregx,"");

    // Grab all of the parameters we need
    var hostNameEnd = this.baseUrl.indexOf("?") + 1;
    var propArray = this.baseUrl.slice(hostNameEnd).split("&");
    var numProps = propArray.length;
    // Grab the dynamic properties, which for the hybrid overlay are:
    // Format   (&FORMAT=)
    // Config   (&CONFIG=)
    // Northing (&N=)
    // Easting  (&E=)
    for ( i = 0; i < numProps; i++ ) {
        el = propArray[i];
        if ( el.indexOf("N=") == 0 ) {
            // Store northing value of northing param as an integer
            this.dynamicProps.northing = parseInt(el.split("=")[1], 10);
            // Mark this element for removal
            el = null;
        }
        else if ( el.indexOf("E=") == 0 ) {
            // Store easting value of easting param as an integer
            this.dynamicProps.easting = parseInt(el.split("=")[1], 10);
            // Mark this element for removal
            el = null;
        }
        else if ( el.indexOf("FORMAT=") == 0 ) {
            // Store the format as a string
            this.dynamicProps.format = el.split("=")[1];
            // Mark this element for removal
            el = null;
        }
        else if ( el.indexOf("CONFIG=") == 0 ) {
            // Store the format as a string, hardcoded for now
            // It's possible the config isn't part of the URL. Rely on help
            // outside this function to set the config value.
            this.dynamicProps.config = el.split("=")[1];
            // Mark this element for removal
            el = null;
        }
//        else if ( el.indexOf("LLMAX=") == 0 ) {
//            // Store the LLMAX as a string
//            this.dynamicProps.llMax = el.split("=")[1];
//            // @TODO Need to make a readonly props. For now, we don't want to remove it from the static props.
//            //el = null;
//        }
        else if ( el.indexOf("LLMIN=") == 0 || el.indexOf("LL=")==0) {
            // Store the LLMIN as a string
            this.dynamicProps.llMin = el.split("=")[1];
            // @TODO Need to make a readonly props. For now, we don't want to remove it from the static props.
            //el = null;
        }
        // Push any property into the holder for the static array.
        // Prevents multiple for loops
        if ( el != null ) {
            staticPropArray.push(el);
        }
    }
    // Generate our string of static props
    // We rely on the question marker being part of the host strings
    this.staticProps = staticPropArray.join("&");
    // We might have host aliases
    this.generateHostAliases();
};
/**
 * Get the next available image host.
 * @returns {string} the next image host available.
 */
deCarta.MapLayerReferenceUrl.prototype.getNextImageHost = function() {
    
    if (this.numImageHosts == 1) {
        
        return this.imageHosts[0];
    } else {
        // We've got more than one
        var toReturn = this.imageHosts[this.nextImageHost++];
        if ( this.nextImageHost >= this.numImageHosts ) {
            // Flip back to the beginning
            this.nextImageHost = 0;
        }
        
        return toReturn;
    }
};
/**
 * Pans the location of the northing and easting of this reference URL.
 * @param {number} nChange required A positive number for a north pan, a negative
 * number for a south pan, zero when there is no vertical change.
 * @param {number} eChange required A positive value for an east pan, a negative
 * number for a west pan, zero for zero horizontal change.
 */
deCarta.MapLayerReferenceUrl.prototype.pan = function(nChange, eChange) {
    
    if(this.isDGSpherical && Credentials.projection=='EPSG:3857'){
        this.dynamicProps.northing -= nChange;
    }else{
        this.dynamicProps.northing += nChange;
    }
    this.dynamicProps.easting += eChange;
};
/**
 * Builds the URL to be used for the map tile. URLs are built in a relative
 * grid reference to the the base URL defined in this object.
 * @param {number} nRel required The positive, relative north location of the
 * new src. 0 means the tile uses the same northing value as this object.
 * @param {number} eRel required The positive, relative east location of the
 * new src. 0 means the tile uses the same easting value as this object.
 * @returns {string} maptile img src url.
 */
deCarta.MapLayerReferenceUrl.prototype.getRelSrc = function(nRel, eRel) {
    
    var host = this.getNextImageHost();
    var nVal, eVal, src;
    if(this.isDGSpherical && Credentials.projection=='EPSG:3857'){
        nVal = this.dynamicProps.northing - nRel;
        eVal = this.dynamicProps.easting + eRel; 
        src=host+'&TileRow='+nVal+"&TileCol="+eVal;
        src=src+'&Format='+this.dynamicProps.format;
        return src;
    }

    // We must have northing, easting
    nVal = this.dynamicProps.northing + nRel;
    eVal = this.dynamicProps.easting + eRel;
    // We might have these values, or we might not want them (like for GX images)
    var configParam = this.dynamicProps.config || "";
    if ( configParam ) {
        configParam = "&CONFIG=" + configParam;
    }
    var formatParam = this.dynamicProps.format || "";
    if ( formatParam ) {
        formatParam = "&FORMAT=" + formatParam;
    }
    
    // Build and return
    // Config should be in front of northing
    src = host + formatParam + configParam + "&N="+nVal + "&E="+eVal;
    
    return src;
};

/**
 * Sets a parameter within the URL. Once the property is set, it cannot be undone
 * through this function. Dynamic properties are checked for first, and if found,
 * the function returns and does not look through the staticprops. If a dynamic
 * property is not found, static properties are searched through and reset. If
 * a static property is not found, the new setting is appended to the staticProps.
 * @param {string} param required The URL safe name of the parameter.
 * @param {string} val require The URL safe value of the parameter.
 */
deCarta.MapLayerReferenceUrl.prototype.setParameter = function( param, val ) {
    
    var i;
    var dynamicProps = this.dynamicProps;
    for ( i in dynamicProps ) {
        if ( dynamicProps.hasOwnProperty(i) ) {
            if ( i == param ) {
                dynamicProps[param] = val;
                // we're done
                return;
            }
        }
    }
    // Not in the dynamicProps, check and modify or add to staticProps
    var staticProps = this.staticProps.split("&");
    var numStaticProps = staticProps.length;
    var eqParam = param+"="; // needed for a clean check of paramaters
    var staticPropFound = false;
    for ( i = 0; i < numStaticProps; i ++ ) {
        if ( staticProps[i].indexOf(eqParam) == 0 ) {
            // We have the param, change and break out
            staticProps[i] = eqParam + val;
            staticPropFound = true;
            break;
        }
    }
    if ( !staticPropFound ) {
        // Add the static prop to the end
        staticProps[numStaticProps] = eqParam + val;
    }
    this.staticProps = staticProps.join("&");
    // For now, we need to refresh the hosts, as static params are attached to the
    // host names to cut down on string concatenation at map drag time
    this.generateHostAliases();
};


/**
 * Gets the value of the requested parameter within the URL, if it exists.
 * @param {string} param required The URL safe name of the parameter.
 * @returns {string} The value for the requested parameter, which will be
 * an empty string if there is no value associated with the parameter, and the
 * null primitive if the parameter doesn't exist.
 */
deCarta.MapLayerReferenceUrl.prototype.getParameter = function( param ) {
    
    var i;
    var value = null;

    // Search the dynamic props first.
    var dynamicProps = this.dynamicProps;
    for ( i in dynamicProps ) {
        if ( dynamicProps.hasOwnProperty(i) ) {
            if ( i == param ) {
                // we're done
                value = dynamicProps[param];
                return value;
            }
        }
    }
    // Not in the dynamicProps, check and modify or add to staticProps
    var staticProps = this.staticProps.split("&");
    var numStaticProps = staticProps.length;
    var eqParam = param+"="; // needed for a clean check of paramaters
    for ( i = 0; i < numStaticProps; i ++ ) {
        if ( staticProps[i].indexOf(eqParam) == 0 ) {
            // We're done
            value = staticProps[i].split("=")[1];
            return value;
        }
    }
    // Value should still be null, we failed to find anything, return null
    return null;
};

/**
 * Deletes a paramater and value within the URL, if it exists.
 * @param {string} param required The URL safe name of the parameter to delete.
 * @returns {boolean} True if the parameter and value were found and deleted,
 * false if nothing was found. Dynamic parameters are not actually deleted,
 * they still exist as properties on this JavaScript object. They just won't
 * be written into the URL.
 */
deCarta.MapLayerReferenceUrl.prototype.deleteParameter = function( param ) {
    
    var i;

    // Search the dynamic props first.
    var dynamicProps = this.dynamicProps;
    for ( i in dynamicProps ) {
        if ( dynamicProps.hasOwnProperty(i) ) {
            if ( i == param ) {
                // we're done
                dynamicProps[param] = null;
                return true;
            }
        }
    }
    // Not in the dynamicProps, check and modify or add to staticProps
    var staticProps = this.staticProps.split("&");
    var resultingParams = [];
    var el;
    var deleted = false;
    var numStaticProps = staticProps.length;
    var eqParam = param+"="; // needed for a clean check of paramaters
    for ( i = 0; i < numStaticProps; i ++ ) {
        el = staticProps[i];
        if ( el.indexOf(eqParam) == 0 ) {
            // Prop found, make sure we delete
            el = null
            deleted = true;
        }
        if ( el ) {
            // we need to capture all paramters except the one we want to delete
            resultingParams.push(el);
        }
    }

    // We either deleted the parameter, or not
    if ( deleted ) {
        // If so, we need to regenerate the host names
        this.staticProps = resultingParams.join("&");
        this.generateHostAliases();
        return true;
    } else {
        // if not, nothing was deleted
        return false;
    }
};




function MapOverviewController (zoomDif,width,height){

    this.map=null;
    this.mapVisible= false;
    this.frame = null;
    this.type="MapOverviewController";
    this.mapDiv = null;
    this.zoomDif=zoomDif || 4;
    this.width=width || 120;
    this.height=height || 120;

	//if any operation is requested before the map is ready, it will be added to
	// the queue and executed as soon as the first jsrequest returns.
	this._queuedOperations = [];

    var self = this;
    var _isIE = Utilities.ie;
    var _zoomLock = false;
    var _events = new Array();
    var _mapLayers = {};
    var _mapArrayDiv = null;
    var _mapDivWin = null;
    var _mapArrayDivWin = null;
    var _draggingEnabled = true;
    var _mapToggle=null;
    var _mapToggleImg=null;
    var _centerPosition=null;
    var _callbackArray=[];
    var _xmlRecFac= null;
    var _tileSize = null;
    var _threshold =null;
    var _zoomLevel=8;
    var _verticalTiles;
    var _horizontalTiles;
    var _offsetX;
    var _offsetY;
    var _tileBuffer= 2;
    var _onlyLoadTilesInViewport = false;
    var _fixedGridPixelOffset = new PixelPoint(0,0);
    var _mapDivX            = 0;
    var _mapDivY            = 0;
    // The current origin location of the upper left corner of the tilegrid
    // parent DOM element relative to the viewable map.
    var _mapDivXorigin      = 0;
    var _mapDivYorigin      = 0;

    // Sub-tile delta pixel pan. When _deltaX or _deltaY passes the _threshold
    // pixel distance in the horizontal or vertical direction, a new tile is
    // requested.
    var _deltaX             = 0;
    var _deltaY             = 0;
    var _px = "px";
    var _presentRadiusX = 0;
    var _presentRadiusY = 0;
    var _sliding=false;


    this.initialize = function(){
        this.frame= document.createElement("div");
        this.frame.id = "MapOverviewFrame";
        //this.frame.style.cssText="position:absolute;right:0px;bottom:0px;width:17px;height:17px;z-index:10;background-color:gray";
        this.frame.className="decarta-mapOverviewController-frame";
        deCarta.IdManager.setTag( this.frame, "ignoreForMapEvents" );
        this.frame.onmousedown= function(e){
            if (!GLOBALS.ALLOWDOMEVENTS) {
                return true;
            }

            e = e ? e : window.event; /* get IE event ( not passed ) */
            e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
            return false;
        }

        initializeMapOverviewToggle();
        initializeMapOverview();

    };

    this.open = function(){
        self.mapVisible=true;
        _mapToggleImg.src="img/map_overview_hide.png";
        self.frame.style.height=self.width+5+"px";
        self.frame.style.width=self.height+5+"px";
    };

    this.close = function(){
        self.mapVisible=false;
        _mapToggleImg.src="img/map_overview_show.png";
        self.frame.style.height="17px";
        self.frame.style.width="17px";
    };

    function initializeMapOverviewToggle(){
        _mapToggle=document.createElement("div");
        _mapToggle.id="MapOverviewToggle";
        //_mapToggle.style.cssText="position: absolute; right: 0px; bottom: 0px; width: 17px; height: 17px;z-index:20;"
        _mapToggle.className="decarta-mapOverviewController-mapToggle";
        _mapToggle.onclick = function(e){
            if (!GLOBALS.ALLOWDOMEVENTS) {
                return true;
            }

            e = e ? e : window.event; /* get IE event ( not passed ) */
            e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
            // Eject on a right or middle button press.
            // !_isIE is good for Safari, Opera, FF and Chrome
            // Hate to admit it, but IE does the button ident better than
            // the others. Damn groupthink.

            if(self.mapVisible){
                self.close();
            }else{
                self.open();
            }
            return true;

        }
        deCarta.IdManager.setTag( _mapToggle, "ignoreForMapEvents" );
        self.frame.appendChild(_mapToggle);

        _mapToggleImg=document.createElement("img");
        _mapToggleImg.src="img/map_overview_show.png";
        //_mapToggleImg.style.cssText="position:absolute;left:0px;top:0px;width:17px;height:17px;"
        _mapToggleImg.className="decarta-mapOverviewController-mapToggleImg";
        _mapToggle.appendChild(_mapToggleImg);
        deCarta.IdManager.setTag( _mapToggleImg, "ignoreForMapEvents" );
    };

    function initializeMapOverview(){
        var mapDivWrapper=document.createElement("div");
        mapDivWrapper.id="MapOverviewWrapper";
        //mapDivWrapper.style.cssText="position:absolute;left:5px;top:5px;overflow:hidden;";
        mapDivWrapper.className="decarta-mapOverviewController-mapDivWrapper";

        mapDivWrapper.style.width=self.width+_px;
        mapDivWrapper.style.height=self.height+_px;
        self.frame.appendChild(mapDivWrapper);
        deCarta.IdManager.setTag( mapDivWrapper, "ignoreForMapEvents" );

        self.mapDiv=document.createElement("div");
        self.mapDiv.id="MapOverview";
        //self.mapDiv.style.cssText="position:absolute;left:0px;top:0px;overflow:hidden;";
        self.mapDiv.className="decarta-mapOverviewController-mapDiv";
        self.mapDiv.style.width=self.width+"px";
        self.mapDiv.style.height=self.height+"px";
        mapDivWrapper.appendChild(self.mapDiv);
        deCarta.IdManager.setTag( self.mapDiv, "ignoreForMapEvents" );

        _tileSize = self.map.getTileSize();
        _threshold  = _tileSize;
        _xmlRecFac=self.map.getXmlRecFac();

        self.mapDiv.onmousedown= function( e ) {
            if (!GLOBALS.ALLOWDOMEVENTS) {
                return true;
            }

            e = e ? e : window.event; /* get IE event ( not passed ) */

            // Eject on a right or middle button press.
            // !_isIE is good for Safari, Opera, FF and Chrome
            // Hate to admit it, but IE does the button ident better than
            // the others. Damn groupthink.
            if ((!_isIE && e.which == 3) || (_isIE && e.button == 2)) {

                return true;
            }
            if ((!_isIE && e.which == 2) || (_isIE && e.button == 4)) {
                // Middle click
                return true;
            }

            var eventSource;
            if (e.target) {
                eventSource = e.target; // W3C/Mozilla
            }
            else if (e.srcElement) {
                eventSource = e.srcElement; // IE
            }
            if (eventSource && eventSource.nodeType == 3) {
                eventSource = eventSource.parentNode; // defeat Safari bug
            }

            var _mouseDownClock = new Date();
            var _drag=true;
            self.mapDiv.style.cursor="move";
            var _dragStartX = e.clientX;
            var _dragStartY = e.clientY;

            document.body.onmousemove = function( e ) {
                // Logging here causes too much noise. Manually turn on if needed.
                //
                // potentially used to calculate click positions
                var clickScreenPix;
                var p;
                // Grab the correct event object
                e = e ? e : window.event;

                // movestart must only happen once, and happen only when onmousemove
                // actually fires, not before
                if(!_drag)
                    return false;
                var draggingX = e.clientX - _dragStartX;
                var draggingY = e.clientY - _dragStartY;

                _deltaX += draggingX;
                _deltaY += draggingY;
                
                if ( Math.abs(_deltaX) > _threshold || Math.abs(_deltaY) > _threshold )
                    rotateTiles();

                // if easing is enabled and if we have not yet registered that the map is being dragged
                // set the dragEasing flag.
                _mapDivX += draggingX;
                _mapDivY += draggingY;

                move( _mapDivX, _mapDivY );



                _dragStartX = e.clientX;
                _dragStartY = e.clientY;
                return false;
            }; //end of mousemove

            document.body.onmouseup = function(e){
                // Logging here causes too much noise. Manually turn on if needed.
                //
                _drag=false;
                self.mapDiv.style.cursor="default";
                document.body.onmousemove = null;
                //window.onmouseup = null;
                document.body.onmouseup = null;

                // Update the map tiles in view
                for ( var z in _mapLayers ) {
                    if ( _mapLayers.hasOwnProperty(z) ) {
                        _mapLayers[z].showTilesInViewport();
                    }
                }

                self.map.panToPosition(self.getCenterPosition());

                return false;
            }//end of mouseup



            return false;
        }//end of mousedown

    }

    function createOrPositionMapArrayDivWin(){
        if(_mapArrayDivWin){
            positionMapArrayDivWin();
        }else{
            _mapArrayDivWin=document.createElement("div");
            //_mapArrayDivWin.style.cssText="position:absolute;border: 1px solid blue;background-color: rgb(102, 102, 204); opacity: 0.4;z-index:20;"
            _mapArrayDivWin.className="decarta-mapOverviewController-mapArrayDivWin";
            positionMapArrayDivWin();
            deCarta.IdManager.setTag( _mapArrayDivWin, "ignoreForMapEvents" );
            _mapArrayDiv.appendChild(_mapArrayDivWin);
        }
    }

    function positionMapArrayDivWin(){
        var width=Math.floor(self.map.mapDiv.offsetWidth/Math.pow(2,self.getZoomDifNow()));
        var height=Math.floor(self.map.mapDiv.offsetHeight/Math.pow(2,self.getZoomDifNow()));
        if(width>=self.width || height>=self.height){
            _mapArrayDivWin.style.display="none";
        }else{
            _mapArrayDivWin.style.display="block";
        }
        _mapArrayDivWin.style.width=width+"px"
        _mapArrayDivWin.style.height=height+"px";
        _mapArrayDivWin.style.left=(self.width-width)/2-_mapDivX+"px";
        _mapArrayDivWin.style.top=(self.height-height)/2-_mapDivY+"px";

    }

    function positionMapDivWin(){
        var width=Math.floor(self.map.mapDiv.offsetWidth/Math.pow(2,self.getZoomDifNow()));
        var height=Math.floor(self.map.mapDiv.offsetHeight/Math.pow(2,self.getZoomDifNow()));
        if(width>=self.width || height>=self.height){
            _mapDivWin.style.display="none";
        }else{
            _mapDivWin.style.display="";
        }
        _mapDivWin.style.width=width+"px"
        _mapDivWin.style.height=height+"px";
        _mapDivWin.style.left=(self.width-width)/2+"px";
        _mapDivWin.style.top=(self.height-height)/2+"px";

    }
    function createOrPositionMapDivWin(){
        if(_mapDivWin) {
            positionMapDivWin();
        }else{
            _mapDivWin=document.createElement("div");
            //_mapDivWin.style.cssText="position:absolute;border: 1px solid blue;background-color: rgb(102, 102, 204); opacity: 0.4;z-index:21;"
            _mapDivWin.className="decarta-mapOverviewController-mapDivWin";
            positionMapDivWin();
            deCarta.IdManager.setTag( _mapDivWin, "ignoreForMapEvents" );
            self.mapDiv.appendChild(_mapDivWin);
            _mapDivWin.onmousedown= function(e){
                if (!GLOBALS.ALLOWDOMEVENTS) {
                    return true;
                }

                e = e ? e : window.event; /* get IE event ( not passed ) */
                e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
                // Eject on a right or middle button press.
                // !_isIE is good for Safari, Opera, FF and Chrome
                // Hate to admit it, but IE does the button ident better than
                // the others. Damn groupthink.
                if ((!_isIE && e.which == 3) || (_isIE && e.button == 2)) {

                    return true;
                }
                if ((!_isIE && e.which == 2) || (_isIE && e.button == 4)) {
                    // Middle click
                    return true;
                }

                var _drag=true;
                var _dragX=true;
                var _dragY=true;
                if(_mapDivWin.offsetWidth>=self*width) _dragX=false;
                if(_mapDivWin.offsetHeight>=self*height) _dragY=false;
                _mapDivWin.style.cursor="move";

                var _dragStartX = e.clientX;
                var _dragStartY = e.clientY;

                var _panIntervalId=null;

                document.body.onmousemove = function(e){
                    // Grab the correct event object
                    e = e ? e : window.event;

                    if(!_drag)
                        return false;
                    if(!_dragX || !_dragY)
                        return false;



                    var draggingX = e.clientX - _dragStartX;
                    var lowerBoundingX=0;
                    var upperBoundingX=self.width-_mapDivWin.offsetWidth;

                    var moveToX=_mapDivWin.offsetLeft+draggingX;
                    if(moveToX>upperBoundingX) moveToX=upperBoundingX;
                    if(moveToX<lowerBoundingX) moveToX=lowerBoundingX;
                    _mapDivWin.style.left=moveToX+_px;



                    var draggingY = e.clientY - _dragStartY;
                    var lowerBoundingY=0;
                    var upperBoundingY=self.height-_mapDivWin.offsetHeight;

                    var moveToY=_mapDivWin.offsetTop+draggingY;
                    if(moveToY>upperBoundingY) moveToY=upperBoundingY;
                    if(moveToY<lowerBoundingY) moveToY=lowerBoundingY;
                    _mapDivWin.style.top=moveToY+_px;




                    _dragStartX = e.clientX;
                    _dragStartY = e.clientY;

                    var panDirectionX=0;
                    var panDirectionY=0;
                    if(moveToX>=upperBoundingX) panDirectionX=1;
                    if(moveToX<=lowerBoundingX) panDirectionX=-1;
                    if(moveToY>=upperBoundingY) panDirectionY=1;
                    if(moveToY<=lowerBoundingY) panDirectionY=-1;


                    if(panDirectionX || panDirectionY){
                        slider(panDirectionX*(-5),panDirectionY*(-5));
                        if(_panIntervalId) clearInterval(_panIntervalId);

                        _panIntervalId=setInterval(function(){
                            if(panDirectionX || panDirectionY){
                                slider(panDirectionX*(-5),panDirectionY*(-5));

                            }else{
                                if(_panIntervalId) clearInterval(_panIntervalId);
                                _panIntervalId=0;
                            }
                        },300);

                    }else{
                        if(_panIntervalId) clearInterval(_panIntervalId);
                        _panIntervalId=0;
                    }


                    return false;
                }; // end of onmousemove
                document.body.onmouseup = function(e){
                    document.body.onmousemove = null;
                    document.body.onmouseup = null;
                    _drag=false;
                    _mapDivWin.style.cursor="default";
                    e = e ? e : window.event;
                    e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;

                    if(_panIntervalId) clearInterval(_panIntervalId);
                    _panIntervalId=0;

                    var oldCenter=self.getCenterPosition();
                    var oldCenterPixel=self.posToMercPix(oldCenter);
                    var oldLeft=(self.mapDiv.offsetWidth-_mapDivWin.offsetWidth)/2;
                    var posDifX=_mapDivWin.offsetLeft-oldLeft;
                    var oldTop=(self.mapDiv.offsetHeight-_mapDivWin.offsetHeight)/2;
                    var posDifY=_mapDivWin.offsetTop-oldTop;
                    var newCenterPixel=new PixelPoint(Math.round(oldCenterPixel.x+posDifX),Math.round(oldCenterPixel.y-posDifY));
                    var newCenter=self.mercPixToPos(newCenterPixel);

                    self.map.panToPosition(newCenter);


                    return false;
                };//end of onmouseup



                return false;

            };//end of onmousedown


        }


    }

    this.sliderMapDivWin= function(x,y){
        _mapDivWin.style.left=_mapDivWin.offsetLeft+x+_px;
        _mapDivWin.style.top=_mapDivWin.offsetTop+y+_px;
    }

    this.panMapDivWinToPos = function(pos){
        var c=self.getCenterPosition();
        var cPixcel=this.posToMercPix(c);
        var newPixcel=this.posToMercPix(pos);
        _mapDivWin.style.left=(self.width-_mapDivWin.offsetWidth)/2+(newPixcel.x-cPixcel.x)+_px;
        _mapDivWin.style.top=(self.height-_mapDivWin.offsetHeight)/2-(newPixcel.y-cPixcel.y)+_px;

    }

    this.centerOnPosition = function(position, callBack, trafficTime) {
        var requestId = Utilities.getRequestId();
        if( typeof callBack == 'function'){
            _callbackArray[requestId] = callBack;
        } else {
            // Callback is optional
            _callbackArray[requestId] = null;
        }
        var mapReqId = Utilities.getRequestId();
        //var xml = _xmlRecFac.createMapRequest(position, _tileSize, requestId, _zoom.getZoomLevel(), null, trafficTime, mapReqId);
        var zoomLevel=getZoomLevelFromZC();
        var xml = _xmlRecFac.createMapRequest(position, _tileSize, requestId, zoomLevel, null, trafficTime, mapReqId);
        //JSRequest.send(xml, centerOnPositionCallback);
        JSRequest.send(xml, function(data){
            _centerPosition = position.clone();
            _zoomLevel=zoomLevel;
            populateTiles();

            centerOnPositionCallback(data);


        },null,function(id){
            _callbackArray[id]=undefined;
        });
    }

    this.zoomMap = function(callBack){
        
        if( !_mapLayers[GLOBALS.STREET] && !_mapLayers[GLOBALS.SATELLITE] && !_mapLayers[GLOBALS.HYBRID] ) {
            return false;
        }
        // Ignore any requests if a zoom is currently in progress
        if( _zoomLock ) {
            return false;
        }
        // Here we will definitely use the callBack if it exists
        if( typeof callBack == 'function'){
            _callbackArray["zoomMap"] = callBack;
        }
        else {
            // Callback is optional
            _callbackArray["zoomMap"] = null;
        }

        // Should we actually zoom
        var oldZoomLevel = _zoomLevel;
        var newZoomLevel = getZoomLevelFromZC();
        if ( oldZoomLevel == newZoomLevel ) {
            // no zoom level change, quit out but call callback first
            if ( _callbackArray["zoomMap"] ) {
                _callbackArray["zoomMap"]();
                _callbackArray["zoomMap"] = undefined;

            }
            createOrPositionMapArrayDivWin();
            createOrPositionMapDivWin();
            return false;
        }
        // Zoom is now in progress
        var currentCenterPosition = self.getCenterPosition();
        var requestId = Utilities.getRequestId();
        _zoomLock = true;

        /* Eliminated JSRequest. */
        for (var layerId in _mapLayers){
            if ( _mapLayers.hasOwnProperty(layerId) ) {
                if (_mapLayers[layerId].refUrl && _mapLayers[layerId].layerName == 'decarta-street'){
                    var seedUrl = _mapLayers[layerId].refUrl;
                }
                if (_mapLayers[layerId].refUrl && _mapLayers[layerId].layerName == 'decarta-satellite'){
                    var gxSeedUrl = _mapLayers[layerId].refUrl;
                }
            }
        }
		_zoomLevel = newZoomLevel;
        JSRequest.emulatedZoomRequest(currentCenterPosition, newZoomLevel, seedUrl, gxSeedUrl, zoomMapCallback);

        return true;
    }


    function zoomMapCallback(data) {
        
        centerOnPositionCallback(data);
        // We're done with the zoom
        _zoomLock = false;
        // callbacks
        if(_events["zoomend"]){
            _events["zoomend"]();
        }
        // from the this.zoomMap function
        if ( _callbackArray["zoomMap"] ) {
            _callbackArray["zoomMap"]();
            _callbackArray["zoomMap"] = undefined;
        }
    }



    function populateTiles(){
        if ( !_mapArrayDiv ) {
            // First time, initialize all default map DOM elements
            initializeMap();
            return;
        }


    } /* end populateTiles */

    /**
     * Performs first time initializations on a map. This function is designed
     * to be called once without exception, and will throw
     * @inner
     */
    function initializeMap() {
        //        var mapDivClassName = "decarta-mapviewport";
        //        // .id has already been set by app, don't reset
        //        // Take into account someone might have set a class on the viewport
        //        if( !self.mapDiv.className ) {
        //            self.mapDiv.className = mapDivClassName;
        //        }
        //        else {
        //            self.mapDiv.className += " "+mapDivClassName;
        //        }
        Utilities.setUnselectable( self.mapDiv );

        //---------------------------------------------- event registration
        //        self.mapDiv.oncontextmenu = devnull;
        //        self.mapDiv.onmousedown = startDrag;
        //        self.mapDiv.onmouseout = mouseout;
        //        self.mapDiv.onmouseup = capture;
        //        self.mapDiv.ondblclick = capture;
        //        self.mapDiv.onclick = capture;

        //--------------------------------------- Set up the maptile foundation
        _mapArrayDiv = document.createElement("div");
        //var mapArrayDivClassName = "decarta-tiles";
        //_mapArrayDiv.style.cssText="position:absolute; left:0px; top:0px;";
        _mapArrayDiv.className="decarta-mapOverviewController-mapArrayDiv";
        _mapArrayDiv.id = "mapOverviewTilesDiv";
        //_mapArrayDiv.className = mapArrayDivClassName;
        // Explicitly position so values are referenceable
        _mapArrayDiv.style.top  = 0+"px";
        _mapArrayDiv.style.left = 0+"px";
        Utilities.setUnselectable( _mapArrayDiv );
        // Add to view behind the viewable mapPaneDiv
        self.mapDiv.appendChild( _mapArrayDiv );

        buildDefaultTileGrid();
    }

    /**
     * Initialize the default set of map tiles. Function created to prevent
     * code propagation.
     * As of 4.4.2 we lazy init the _zoomLayer to lighten up the load.
     * @throws {Exception} Will not build on top of tileGrids that already exist.
     * @inner
     */
    function buildDefaultTileGrid() {
        
        if ( _mapLayers[GLOBALS.SATELLITE] || _mapLayers[GLOBALS.HYBRID] || _mapLayers[GLOBALS.STREET] ) {
            throw new Exception( "buildDefaultTileGrid called on existing tile grid" );
        }
        // Associative array of map layers: _mapLayers[Zreference].tileArray[x][y]
        // Lazy load only the layers that we need displayed
        if ( _xmlRecFac.mapType == GLOBALS.STREET ) {
            initDefaultMapLayer(GLOBALS.STREET);
        }
        else if ( _xmlRecFac.mapType == GLOBALS.HYBRID ) {
            initDefaultMapLayer(GLOBALS.HYBRID);
        }
        else if ( _xmlRecFac.mapType == GLOBALS.SATELLITE ) {
            initDefaultMapLayer(GLOBALS.SATELLITE);
        }
    // Init the _zoomLayer on the first zoom.
    }

    function initDefaultMapLayer( layerName ) {
        if ( layerName != GLOBALS.SATELLITE && layerName != GLOBALS.HYBRID && layerName != GLOBALS.STREET ) {
            throw new Exception( "initDefaultMapLayer called with bad value: "+layerName );
        }
        // Local vars
        var mapDivHeight = parseInt(self.mapDiv.style.height);
        var mapDivWidth  = parseInt(self.mapDiv.style.width);

        // Calculate the number of tiles and enforce odd tile grid.
        _verticalTiles = Math.ceil(mapDivHeight / _tileSize) + _tileBuffer;
        if(_verticalTiles % 2 == 0) {
            _verticalTiles++;
        }
        _horizontalTiles = Math.ceil(mapDivWidth / _tileSize) + _tileBuffer;
        if( _horizontalTiles % 2 == 0) {
            _horizontalTiles++;
        }
        // Figure out the offset of the upper left corner of the map tiles
        // relative to the upper left corner of the _mapArrayDiv
        _offsetX = -Math.floor(((_horizontalTiles*_tileSize) - mapDivWidth)/2);
        _offsetY = -Math.floor(((_verticalTiles*_tileSize) - mapDivHeight)/2);
        
        if ( layerName == GLOBALS.SATELLITE ) {
            _mapLayers[GLOBALS.SATELLITE] = new deCarta.MapLayer( _horizontalTiles, _verticalTiles, _offsetX, _offsetY, _tileSize, "decarta-satellite", 11, self, false);
            _mapLayers[GLOBALS.SATELLITE].show();
            _mapLayers[GLOBALS.SATELLITE].appendTiles( _mapArrayDiv );
            return;
        }
        else if ( layerName == GLOBALS.HYBRID ) {
            // Need to make sure Satellite isn't already init'd
            if ( !_mapLayers[GLOBALS.SATELLITE] ) {
                _mapLayers[GLOBALS.SATELLITE] = new deCarta.MapLayer( _horizontalTiles, _verticalTiles, _offsetX, _offsetY, _tileSize, "decarta-satellite", 11, self, false);
                _mapLayers[GLOBALS.SATELLITE].show();
                _mapLayers[GLOBALS.SATELLITE].appendTiles( _mapArrayDiv );
            }
            _mapLayers[GLOBALS.HYBRID] = new deCarta.MapLayer( _horizontalTiles, _verticalTiles, _offsetX, _offsetY, _tileSize, "decarta-transparent", 12, self, false);
            _mapLayers[GLOBALS.HYBRID].show();
            _mapLayers[GLOBALS.HYBRID].appendTiles( _mapArrayDiv );
            return;
        }
        else if ( layerName == GLOBALS.STREET ) {
            _mapLayers[GLOBALS.STREET] = new deCarta.MapLayer( _horizontalTiles, _verticalTiles, _offsetX, _offsetY, _tileSize, "decarta-street", 13, self, false);
            _mapLayers[GLOBALS.STREET].show();
            _mapLayers[GLOBALS.STREET].appendTiles( _mapArrayDiv );
            return;
        }
    }

    function centerOnPositionCallback(data) {
        var reqId = data.XLS.Response.requestID;
        var lat,lon;
        var pans=data.XLS.Response.PortrayMapResponse.TileGrid[0].Pan;
        var results;
        if ( deCarta.JSONParser.parseErrors(data) ) {
            // Return expected error indicator
            results = null;
        }
        else {
            for(var i=0;i<pans.length;i++){
                if(pans[i].direction=="E"){
                    _fixedGridPixelOffset.x = parseFloat(pans[i].numTiles) * _tileSize;
                    lon=pans[i].toLon;
                } else {
                    _fixedGridPixelOffset.y = -parseFloat(pans[i].numTiles) * _tileSize;
                    lat=pans[i].toLat;
                }
            }
            var deCartaPos = data.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.CenterPoint.pos.content;
            //var gxPos = data.XLS.Response.PortrayMapResponse.TileGrid[1].CenterContext.CenterPoint.pos.content;
            // prior to 4.4.1
            if(isNaN(lat) || isNaN(lon) ){
                _centerPosition=new Position(deCartaPos);
            }else{
                _centerPosition=new Position(lat,lon);
            }
            var tmpRadius  = data.XLS.Response.PortrayMapResponse.TileGrid[0].CenterContext.Radius.content;
            setRadius(  (parseFloat((tmpRadius))/1000) * _horizontalTiles );

            // 4.4.1sp01 Capture the imageHostAliasing if available. Right now we
            // only care about the deCarta Map layer
            var maxImageHostAliases=0;
            try {
                maxImageHostAliases = parseInt(data.XLS.Response.PortrayMapResponse.TileGrid[0].GridLayer.maxImageHostAliases, 10);
            } catch(e) {}
            // Handle image layer URLs
            var urls = [
            data.XLS.Response.PortrayMapResponse.TileGrid[0].Tile.Map.Content.URL,
            data.XLS.Response.PortrayMapResponse.TileGrid[1].Tile.Map.Content.URL
            ];
            updateUrlList(urls, maxImageHostAliases);
            // before callback in case of adding pins in callback
            results = self.getCenterPosition();
        }
        if ( (reqId >= 0) && _callbackArray[reqId] ) {
            _callbackArray[reqId]( results );
            _callbackArray[reqId] = undefined;
        }

        createOrPositionMapArrayDivWin();
        createOrPositionMapDivWin();

		for (var i = 0 ; i <self._queuedOperations.length; i++){
			self._queuedOperations[i]();
			delete self._queuedOperations[i];
		}
		self._queuedOperations = [];
    }

    this.dg3SatelliteImgFormat="image/jpeg";
    
    function updateUrlList(urlList, maxImageHostAliases) {
        

        reset();

        // A bit of protection, because we need an integer.
        maxImageHostAliases = maxImageHostAliases || 0;

        // 4.4.1.sp01 perform aliasing within the jsapi
        // GlobeXplorer does not have image host aliasing
        //

        // mobile-dev
        //        var gxSeedUrl = new deCarta.MapLayerReferenceUrl(Sarissa.getText(urlList[1]));
        var gxSeedUrl = new deCarta.MapLayerReferenceUrl((urlList[1]));
        gxSeedUrl.createGlobeXplorerUrl();
        if (Credentials.projection=="EPSG:3857" && gxSeedUrl.isDGSpherical){
            gxSeedUrl.setParameter("format",self.dg3SatelliteImgFormat);
        }

        // mobile-dev
        //        var hybridSeedUrl = new deCarta.MapLayerReferenceUrl(Sarissa.getText(urlList[0]), maxImageHostAliases);
        var hybridSeedUrl = new deCarta.MapLayerReferenceUrl((urlList[0]), maxImageHostAliases);
        hybridSeedUrl.createDeCartaTransparentUrl();
        // 4.4.1 We cannot rely on the configuration being returned within the URL
        // and must manually add it.
        hybridSeedUrl.setParameter("config", _xmlRecFac.transparentConfiguration);

        //mobile-dev
        //        var streetSeedUrl = new deCarta.MapLayerReferenceUrl(Sarissa.getText(urlList[0]), maxImageHostAliases);
        var streetSeedUrl = new deCarta.MapLayerReferenceUrl((urlList[0]), maxImageHostAliases);
        streetSeedUrl.createDeCartaUrl();
        // 4.4.1 We cannot rely on the configuration being returned within the URL
        // and must manually add it.
        streetSeedUrl.setParameter("config", _xmlRecFac.configuration);

        // Populate only the initialized and the visible layers
        if ( _mapLayers[GLOBALS.SATELLITE] ) {
            _mapLayers[GLOBALS.SATELLITE].populate( gxSeedUrl );
        }
        if ( _mapLayers[GLOBALS.HYBRID] ) {
            _mapLayers[GLOBALS.HYBRID].populate( hybridSeedUrl );
        }
        if ( _mapLayers[GLOBALS.STREET] ) {
            _mapLayers[GLOBALS.STREET].populate( streetSeedUrl );
        }

        // Pan the fixed map to display the center
        // We assume the relativity of the pan directions-to-the map (+ or -)
        // have been set prior to here.
        _deltaX -= _fixedGridPixelOffset.x;
        _deltaY -= _fixedGridPixelOffset.y;

    }

    function reset() {
        

        // 4.4.1 reset the map layers/tiles
        _mapDivXorigin = _mapDivX;
        _mapDivYorigin = _mapDivY;

        //when resize the map, the _offsetX and _offsetY is not changed according the the map size,
        //we should recalculate it when reset the map tiles when render map again.
        var mapDivHeight = parseInt(self.mapDiv.style.height);
        var mapDivWidth  = parseInt(self.mapDiv.style.width);

        // Calculate the number of tiles and enforce odd tile grid.
        _verticalTiles = Math.ceil(mapDivHeight / _tileSize) + _tileBuffer;
        if(_verticalTiles % 2 == 0) {
            _verticalTiles++;
        }
        _horizontalTiles = Math.ceil(mapDivWidth / _tileSize) + _tileBuffer;
        if( _horizontalTiles % 2 == 0) {
            _horizontalTiles++;
        }
        // Figure out the offset of the upper left corner of the map tiles
        // relative to the upper left corner of the _mapArrayDiv
       _offsetX = -Math.floor(((_horizontalTiles*_tileSize) - mapDivWidth)/2);
        _offsetY = -Math.floor(((_verticalTiles*_tileSize) - mapDivHeight)/2);



        for ( var z in _mapLayers ) {
            if ( _mapLayers.hasOwnProperty(z) ) {
                _mapLayers[z].reset( -_mapDivX-_fixedGridPixelOffset.x, -_mapDivY-_fixedGridPixelOffset.y, _offsetX,_offsetY );
            }
        }
        // 4.4.1 Must turn the correct layers back on as reset hides the layers
        // except that we control what gets turned back on differently for
        // a digital zoom vs. anything else
        var layersToShow = [];
        if ( _xmlRecFac.mapType == GLOBALS.STREET ) {
            layersToShow.push( _mapLayers[GLOBALS.STREET] );
        }
        else if ( _xmlRecFac.mapType == GLOBALS.HYBRID ) {
            layersToShow.push(_mapLayers[GLOBALS.SATELLITE]);
            layersToShow.push(_mapLayers[GLOBALS.HYBRID]);
        }
        else if ( _xmlRecFac.mapType == GLOBALS.SATELLITE ) {
            layersToShow.push(_mapLayers[GLOBALS.SATELLITE]);
        }
        else {
            throw new Exception( "Map.reset: encountered unexpected _xmlRecFac.mapType of " + _xmlRecFac.mapType );
        }
        // Allows digital zoom to 'splash' the loaded images onto the page,
        // all other resets are just normal
        resetLayers( layersToShow );
        // Reset map properties
        _deltaX             =0;
        _deltaY             =0;
    }

    /**
     * Allows control over when MapLayers are shown during after a digital zoom,
     * and benignly turns the correct layers back on for all other resets.
     * @param {Array} layersToShow required An array of MapLayer objects.
     * @inner
     */
    function resetLayers( layersToShow ) {
        

        // For Closure (during digital zoom reset)
        var layers = layersToShow;
        var numLayers = layers.length;
        // Counter
        var i;
        for ( i = 0; i < numLayers; i++ ) {
            layers[i].show();
        }

    }

    this.setMapType = function(mapType){
        
        if(!(mapType==GLOBALS.STREET || mapType==GLOBALS.HYBRID || mapType==GLOBALS.SATELLITE)){
            throw new Exception("unsupported mapType. Use '"+GLOBALS.STREET+"' || '"+GLOBALS.HYBRID+"' || '"+GLOBALS.SATELLITE+"'");
        }

        // 4.4.1 Removed automatic reset of Credentials.mapType
        _xmlRecFac.mapType = mapType;
        // 4.4.2 Determine if we need a map refresh.
        // Why? Any new layer that is inited will need to be seeded with the
        // correct map tile url. Determine if we need to perform a map refresh.
        var needRefresh = false;

        // This is the only function that can initiate anything other than a default
        // so this acts as a choke point for the lazy loading of the map layers.
        if(!_mapLayers || Utilities.isObjectEmpty(_mapLayers)) {
            return;
        }
        if ( mapType == GLOBALS.STREET ) {
            // Layers to hide
            if ( _mapLayers[GLOBALS.HYBRID] ) {
                _mapLayers[GLOBALS.HYBRID].hide();
            }
            if ( _mapLayers[GLOBALS.SATELLITE] ) {
                _mapLayers[GLOBALS.SATELLITE].hide();
            }
            // Layers to show
            if ( !_mapLayers[GLOBALS.STREET] ) {
                // This automatically shows the layer
                initDefaultMapLayer(GLOBALS.STREET);
                needRefresh = true;
            } else {
                _mapLayers[GLOBALS.STREET].show();
            }
        } else if(mapType==GLOBALS.HYBRID){
            // Layers to hide
            if ( _mapLayers[GLOBALS.STREET] ) {
                _mapLayers[GLOBALS.STREET].hide();
            }
            // Layers to show
            if ( !_mapLayers[GLOBALS.SATELLITE] ) {
                initDefaultMapLayer(GLOBALS.SATELLITE);
                needRefresh = true;
            } else {
                _mapLayers[GLOBALS.SATELLITE].show();
            }
            if ( !_mapLayers[GLOBALS.HYBRID] ) {
                // This automatically shows the layer
                initDefaultMapLayer(GLOBALS.HYBRID);
                needRefresh = true;
            } else {
                _mapLayers[GLOBALS.HYBRID].show();
            }
        } else if(mapType==GLOBALS.SATELLITE){
            // Layers to hide
            if ( _mapLayers[GLOBALS.HYBRID] ) {
                _mapLayers[GLOBALS.HYBRID].hide();
            }
            if ( _mapLayers[GLOBALS.STREET] ) {
                _mapLayers[GLOBALS.STREET].hide();
            }
            // Layers to show
            if ( !_mapLayers[GLOBALS.SATELLITE] ) {
                // This automatically shows the layer
                initDefaultMapLayer(GLOBALS.SATELLITE);
                needRefresh = true;
            } else {
                _mapLayers[GLOBALS.SATELLITE].show();
            }
        }
        if ( needRefresh ) {
    // Refresh the map to initialize lazy loaded map layers
    //this.centerOnPosition(self.getCenterPosition());
    }
    } /* end setMapType */


    this.panToPosition = function( pos, callBack ) {

        var position = pos.clone();

        // get current center in GX pix
		try {
			var cPos = self.getCenterPosition();
		} catch (e){
			// Exception thrown here means that center position is not (yet) set.
			this._queuedOperations.push(Utilities.scope(function(){
				this.panToPosition(position, callBack);
			}, this));
			return;
		}
        var c = this.posToMercPix( cPos );
        // get the new position in GX pix
        var c2 = this.posToMercPix( position );
        // this is the pixel difference
        var pix = new PixelPoint( Math.round(c.x-c2.x), Math.round(c.y-c2.y) );
        

        // Determine whether to slide or teleport
        if(_centerPosition && getRadius()){
            var bbox = Utilities.centerContextToBoundingBox(cPos, getRadius());
            if( bbox.extendedContains(position) ){
                // (4.4.1 Notes)
                // Allow registration of a pan to position callback
                // We cheat and use the _callBackArray as an object, no error checking
                // callBack will execute within the slide function
                if( typeof callBack == 'function'){
                    _callbackArray["panToPosition"] = callBack;
                }
                else {
                    // Callback is optional
                    _callbackArray["panToPosition"] = null;
                }

                if( pix.x == 0 && pix.y == 0 ) {
                    // no movement, quit out but call callback first
                    if ( _callbackArray["panToPosition"] ) {
                        _callbackArray["panToPosition"]( self.getCenterPosition() );
                        _callbackArray["panToPosition"] = undefined;
                    }
                    positionMapArrayDivWin();
                    positionMapDivWin();
                    return;
                }
                else {
                    slider( pix.x, -1*pix.y );

                    positionMapArrayDivWin();
                    positionMapDivWin();
                }
            }
            else {
                // (4.4.1 notes continued)
                // Otherwise we just pass callBack to centerOnPosition
                // callBack should be falsey (probably undefined) or a function.
                // no error checking
                this.centerOnPosition(position, callBack);
            }
        }
        else{
            this.centerOnPosition(position, callBack);
        }



    }

    function slider( x , y ) {
        
        if ( _sliding ) {
            return;
        }
        // __This fix must be modified if slide is ever modified__
        // The slide function doesn't actually move the map in the direction
        // unless the pixel distance is greater than 1, so don't correct
        // unless the slide distance is more than 1
        if( x > 1 )
            _mapArrayDiv.style.left = parseInt(_mapArrayDiv.style.left) + 1+_px;
        else if ( x < -1 )
            _mapArrayDiv.style.left = parseInt(_mapArrayDiv.style.left) - 1+_px;
        // Vertical pan
        if( y > 1 )
            _mapArrayDiv.style.top = parseInt(_mapArrayDiv.style.top) + 1+_px;
        else if ( y < -1 )
            _mapArrayDiv.style.top = parseInt(_mapArrayDiv.style.top) - 1+_px;

        _sliding=true;
        slide( x, y, true);
    }


    /**
     * Slide the map in half-life increments from the current location to new
     * pixel coordinates. Once called, this function will be called repeatedly
     * until the destination is arrived at.
     * @param {integer} x required Number of horizontal pixels to pan. Negative
     * values pan east, positive values pan west.
     * @param {integer} y required Number of vertical pixels to pan. Negative
     * values pan south, positive values pan north.
     * @param {boolean} first optional Determines if this is the initial call
     * to begin sliding the map. In the case of the first call, this should
     * be set to true. In all other calls, this argument can be ignored.
     * @inner
     */
    function slide( x, y ,first) {
        
        // Note on oddity: looks like setTimeout passes a rogue argument in as
        // argument[0] on Mozilla FF 3.0. Yikes, watch out.
        // On the first call, set-up our final destination
        var pixelsToSlideX = x;
        var pixelsToSlideY = y;


        // Set-up to move 30% of the distance
        var percentX = Math.round( Math.abs(pixelsToSlideX)*0.3 );
        var percentY = Math.round( Math.abs(pixelsToSlideY)*0.3 );
        while(percentX>0 || percentY>0){
            if (pixelsToSlideX < 0) {
                pixelsToSlideX += percentX;
                _deltaX -= percentX;
                _mapDivX -= percentX;
            } else if( pixelsToSlideX > 0 ){
                pixelsToSlideX -= percentX;
                _deltaX += percentX;
                _mapDivX += percentX;
            }
            if( pixelsToSlideY < 0 ) {
                pixelsToSlideY += percentY;
                _deltaY -= percentY;
                _mapDivY -= percentY;
            }else if( pixelsToSlideY > 0 ) {
                pixelsToSlideY -= percentY;
                _deltaY += percentY;
                _mapDivY += percentY;
            }
            // Actually "slide" the map
            move( _mapDivX, _mapDivY );
            if ( Math.abs(_deltaX) > _threshold || Math.abs(_deltaY) > _threshold )
                rotateTiles();

            percentX = Math.round( Math.abs(pixelsToSlideX)*0.3 );
            percentY = Math.round( Math.abs(pixelsToSlideY)*0.3 );

        }


        // last call! aka. the end of the slide
        // Perform event handling and map object updates
        if(_events["moveend"]){
            _events["moveend"]();
        }
        // 4.4.1
        // Added the potential for a callBack function to handle activities
        // post animation.
        if ( _callbackArray["panToPosition"] ) {
            _callbackArray["panToPosition"]( self.getCenterPosition() );
            _callbackArray["panToPosition"] = undefined;
        }

        _sliding=false;
        // Trigger the new tiles to be shown
        for ( var z in _mapLayers ) {
            if ( _mapLayers.hasOwnProperty(z) ) {
                _mapLayers[z].showTilesInViewport();
            }
        }

    } // end function slide

    function rotateTiles(){
        
        var z; // counters

        if( _deltaX <= -_threshold ) {
            _deltaX = _deltaX + _threshold;
            for ( z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].rotateTiles( 0, 1 );
                }
            }
            draw();
        } else if( _deltaX >= _threshold ) {
            _deltaX = _deltaX - _threshold;
            for ( z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].rotateTiles( 0, -1 );
                }
            }
            draw();
        }
        if( _deltaY <= -_threshold ) {
            _deltaY = _deltaY + _threshold;
            // Initiate a rotate event on all layers
            for ( z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].rotateTiles( -1, 0 );
                }
            }
            // Redraw the canvas
            draw();
        } else if( _deltaY >= _threshold ) {
            _deltaY = _deltaY - _threshold;
            // Initiate a rotate event on all layers
            for ( z in _mapLayers ) {
                if ( _mapLayers.hasOwnProperty(z) ) {
                    _mapLayers[z].rotateTiles( 1, 0 );
                }
            }
            // Redraw the canvas
            draw();
        }
    }

    function setRadius(r){
        _presentRadiusX = r;
        _presentRadiusY = _presentRadiusX/_horizontalTiles*_verticalTiles;

    }

    function getRadius(){
        return _presentRadiusY;
    }

    function move( x, y ) {
        // Function generates too much noise, turn on manually
        //
        _mapArrayDiv.style.left = x + _px;
        _mapArrayDiv.style.top = y + _px;
    //
    }

    this.getOnlyLoadTilesInViewport = function(){
        return _onlyLoadTilesInViewport;
    }

    this.getCenterPosition = function() {
        
        if(!_centerPosition){
            throw new Exception("Center Position not set");
        }
        

        // 4.3.4 We now rely that _centerPosition to be the true center point of
        // the map, not the fixed grid center of the map.
        // The logic of the calculations for future reference and debugging:
        // if diff of _mapDivX and _mapDivY and _fixedGridPixelOffset are equal,
        // the map hasn't moved, return _centerPosition.
        // If there is a difference, the map has moved, return the recalculated
        // offset.
        //var pixelDiffX = _mapDivX - _mapDivXorigin + _fixedGridPixelOffset.x;
        //var pixelDiffY = _mapDivY - _mapDivYorigin + _fixedGridPixelOffset.y;
        var pixelDiffX = _mapDivX - _mapDivXorigin;
        var pixelDiffY = _mapDivY - _mapDivYorigin;
        if(pixelDiffX == 0 && pixelDiffY == 0) {
            // no movement, return the true _centerPosition
            return _centerPosition;
        }
        // Else we've moved, find the original center position
        var cpix = self.posToMercPix( _centerPosition );
        // add together and send to pix2pos
        cpix.x -= pixelDiffX;
        cpix.y += pixelDiffY;

        var currentCenter = self.mercPixToPos( cpix );
        return currentCenter;
    }


    this.getZoomLevel = function(){
        return _zoomLevel;
    }

    this.posToMercPix = function( pos ) {
        
        var scale =  Utilities.radsPerPixelAtZoom(_tileSize, 21-_zoomLevel);
        var y = Utilities.lat2pix(pos.lat, scale);
        var x = Utilities.lon2pix(pos.lon, scale);
        return new PixelPoint( x, y );
    };

    /**
     * Convert a Mercator Pixel object to a Position relative to the
     * current settings of the instance of this Map.
     * @private
     * @param {PixelPoint} pix required A PixelPoint representing a Mercator
     * Pixel at the current zoom level of the map.
     * @returns {Position} The Position representative of the passed in
     * Mercator Pixel.
     */
    this.mercPixToPos = function( pix ) {
        
        var scale =  Utilities.radsPerPixelAtZoom( _tileSize, 21-_zoomLevel );
        var lat = Utilities.pix2lat( pix.y, scale );
        var lon = Utilities.pix2lon( pix.x, scale );
        return new Position( lat, lon );
    };


    function draw(){}


    this.getZoomDifNow = function(){
        return _zoomLevel-self.map.getZoomController().getZoomLevel();
    }

    function getZoomLevelFromZC(){
        var zoom=self.map.getZoomController();
        if(!zoom) return 5+self.zoomDif;
        var zoomLevel=zoom.getZoomLevel()+self.zoomDif;
        if(zoomLevel>zoom.upperBound) zoomLevel=zoom.upperBound;
        if(zoomLevel<zoom.lowerBound) zoomLevel=zoom.lowerBound;

        return zoomLevel;

    }

    this.appendThis = function(){
        // Lazy create the frame
        if (!this.frame) {
            this.initialize();
        }
        // If we still don't have something
        var element = this.frame || null;
        return element;
    };

    this.position = function( ddim ) {
        if ( !this.map ) {
            return;
        }
        // Attach to the upper left. We don't actually use the dimensions
        // object
        if (this.frame) {

		 }

    };

	//map overview controller does not fade tiles.
	this.getTileFading = function(){
		return false;
	}



}

/**
 * @fileoverview MapTypeController
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class The MapTypeController is only useful with {@link Map} instances. If a
 * Map has access to DDS Web Services configured with access to aerial map
 * imagery, the MapTypeController allows additional functionality. When a
 * MapTypeController instance is added to a map, it presents the user with
 * three, clickable viewing choices. STREET view presents standard map images
 * created by the DDS Web Services. HYBRID view presents aerial imagery overlaid
 * by transparent, and labeled, streets, area and place labels. SATELLITE view
 * presents just the aerial imagery of the area.
 * @description Construct a new MapTypeController object.
 * @example
 * // To change the labeling of the MapTypeController to German:
 * var mtc = new MapTypeController();
 * mtc.streetLabel = "Strasse"
 * mtc.hybridLabel = "Hybride"
 * mtc.satelliteLabel = "Satellit"
 * // Assuming our map object is named "map"
 * map.addMapTypeController( mtc );
 * @constructor
 * @see Map#addMapTypeController
 * @see Credentials
 */
function MapTypeController(){ this.init(); }

// ------------------------------------------------------------- Fields
/**
 * The map this particular MapTypeController is associated with.
 * @type Map
 * @default null
 * @private
 */
MapTypeController.prototype.map = null;
/**
 * General identifcation for this map control. Part of the general map control
 * interface. Treat as a read-only property.
 * @type string
 * @default "MapTypeController"
 * @private
 */
MapTypeController.prototype.type = "MapTypeController";
/**
 * The on page div containing this mapTypeController.
 * @type DOM Element (div)
 * @default null
 * @private
 */
MapTypeController.prototype.frame = null;
/**
 * The CSS class that applies to this MapTypeController. Also functions as the
 * id of the on screen frame.
 * @type string
 * @default "decarta-mapTypeController"
 * @private
 */
MapTypeController.prototype.cssClass = "decarta-mapTypeController";
/**
 * The CSS class that applies to the links of the MapTypeController. 
 * @type string
 * @default "decarta-mapTypeControllerLink"
 * @private
 */
MapTypeController.prototype.linkCssClass = "decarta-mapTypeControllerLink";
/**
 * Name to display for STREET view.
 * @type string
 * @default GLOBALS.STREET
 */
MapTypeController.prototype.streetLabel = GLOBALS.STREET;
/**
 * Name to display for HYBRID view.
 * @type string
 * @default GLOBALS.HYBRID
 */
MapTypeController.prototype.hybridLabel = GLOBALS.HYBRID;
/**
 * Name to display for SATELLITE view.
 * @type string
 * @default GLOBALS.SATELLITE
 */
MapTypeController.prototype.satelliteLabel = GLOBALS.SATELLITE;

// ------------------------------------------------------------- Methods
/**
 * Initialize settings needed for the MapTypeController object. All building
 * of the MapTypeController happens after it is associated with a map.
 * @private
 */
MapTypeController.prototype.init = function() {
    
};
/**
 * Build the on page DOM elements, and associated event handling, that form
 * the UI of the MapTypeController. Does not place the MapTypeController onto
 * the map.
 * @private
 */
MapTypeController.prototype.build = function() {
    
    
    this.frame = document.createElement("DIV");
    this.frame.id = this.cssClass;
    this.frame.className = this.cssClass;
    deCarta.IdManager.setTag( this.frame, "ignoreForMapEvents" );

    // Build the controls
    var divider1 = document.createElement("span");
    divider1.innerHTML = " | ";
    deCarta.IdManager.setTag( divider1, "ignoreForMapEvents" );
    var divider2 = document.createElement("span");
    divider2.innerHTML = " | ";
    deCarta.IdManager.setTag( divider2, "ignoreForMapEvents" );
    var streetLink = document.createElement("a");
    streetLink.className = this.linkCssClass;
    streetLink.innerHTML = this.streetLabel;
    streetLink.href = "#";
    streetLink.mapType = GLOBALS.STREET;
    streetLink.owner = this;
    streetLink.onclick = this.handleClick;
    deCarta.IdManager.setTag( streetLink, "ignoreForMapEvents" );
    var hybridLink = document.createElement("a");
    hybridLink.className = this.linkCssClass;
    hybridLink.innerHTML = this.hybridLabel;
    hybridLink.href = "#";
    hybridLink.mapType = GLOBALS.HYBRID;
    hybridLink.owner = this;
    hybridLink.onclick = this.handleClick;
    deCarta.IdManager.setTag( hybridLink, "ignoreForMapEvents" );
    var satelliteLink = document.createElement("a");
    satelliteLink.className = this.linkCssClass;
    satelliteLink.innerHTML = this.satelliteLabel;
    satelliteLink.href = "#";
    satelliteLink.owner = this;
    satelliteLink.mapType = GLOBALS.SATELLITE;
    satelliteLink.onclick = this.handleClick;
    deCarta.IdManager.setTag( satelliteLink, "ignoreForMapEvents" );
    // Add everything to the map
    this.frame.appendChild( streetLink );
    this.frame.appendChild( divider1 );
    this.frame.appendChild( hybridLink );
    this.frame.appendChild( divider2 );
    this.frame.appendChild( satelliteLink );
};



/**
 * Interface used by the Map to grab the correct DOM object to append to the
 * page.
 * @returns {DOM Element} The DOM element representation of the MapTypeController
 * that should be appended to the map object.
 * @private
 */
MapTypeController.prototype.appendThis = function() {
    
    
    // Lazy create the frame
    if (!this.frame) {
        this.build();
    }

    return this.frame;
};

/**
 * Interface for the Map object to remove the MapTypeController from the
 * DOM.
 * @returns {DOM Element} The DOM element representation of the MapTypeController
 * that should be removed from the map object.
 * @private
 */
MapTypeController.prototype.removeThis = function() {
    
    
    this.map = null;

    //@todo add any cleanup to this function, should we wish to.
    
    return this.frame;
};

/**
 * Repositions the MapTypeController relative to the associated Map instance.
 * To be called after the MapTypeController has been associated with a Map
 * and usually only needed when the Map has been resized. Part of the general
 * map control interface.
 * @param {DOMDimensions} ddim required Dimenions of map against which to
 * position this control.
 * @private
 */
MapTypeController.prototype.position = function( ddim ) {
    
    
    // @todo throw an exception if there is no this.map
    // Place the map controller in the default location
    this.frame.style.top = "5px";
    this.frame.style.left = ddim.width - 207 + "px";
};

/**
 * Handles clicks on the MapTypeController links.
 * @private
 */
MapTypeController.prototype.handleClick = function() {
    
    // Quick exit if events should be ignored
    if (!GLOBALS.ALLOWDOMEVENTS) {
        return true;
    }
    this.owner.map.setMapType( this.mapType );
    // Do not initiate standard link procedure
    return false;
};

/**
 * @fileoverview deCarta specific math functions.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @namespace Within you'll find some of the gnarlier geographic and projection
 * functions that have been ported to JavaScript.
 * @description deCarta specific Math functions.
 * @private
 */
deCarta.Math = {};

// Begin class not used in mobile

/**
 * @class The MercatorSpherical class helps to perform client side raw
 * Mercator calculations. There are other functions available within this 
 * library that can help with Mercator calculations, although all are tied
 * directly to the inner workings of our code. Another caveat is that the maps
 * produced by this API are in the Mercator Ellipsoidal projection, and as such
 * attempting to use this class to perform any on screen calculations will lead
 * to a relatively high error rate in placement. Even so, there might be a need 
 * to perform Mercator Spherical math.
 * @description  Construct a new Mercator spherical projection value converter.
 * A simple usage example:
 * @example
 * // Construct
 * var mercatorS = new deCarta.Math.MercatorSpherical();
 * // minPosition and maxPosition are Position objects
 * mercatorS.setBoundingBox( new BoundingBox(minPosition, maxPosition) );
 * // The integer, pixel dimensions of our map
 * mercatorS.setPixelHeight( pixHigh );
 * mercatorS.setPixelWidth( pixWidth );
 * // To calculate and return the PixelPoint location of a Position named myPos
 * var calcPx = mercatorS.positionToPixels( myPos );
 * // To calculate and return the Position location of a PixelPoint named myPx
 * var calcPos = mercatorS.pixelsToPosition( myPx );
 * @constructor
 * @private
 */
deCarta.Math.MercatorSpherical = function() {
    
    
    // Begin Constructor
    // Protected fields
    var _boundingBox = null;
    var _pixelHeight = null;
    var _pixelWidth = null;
    // Private fields
    var _pixelsPerLon = null;
    // End Constructor
    
    // Begin Private methods
    /**
     * Convert degrees to radians.
     * @param {float} deg required Spherical coordinates to convert.
     * @returns {float} radial coordinates.
     * @private
     */
    function _degToRad( deg ) {
        return (deg * Math.PI / 180 );
    }
    
    /**
     * Convert radians to degrees.
     * @param {float} rad required Radial coordinates to convert.
     * @returns {float} spherical coordinates.
     * @private
     */
    function _radToDeg( rad ) {
        return (rad * 180 / Math.PI )
    }
    
    // MERCATOR SPHERICAL TEST DATA
    // Forward Mercator should translate to right side of ->
    // Inverse Mercator should translate back to left side of -> with little 
    // error
    // Unprojected Degrees -> Mercator Spherical Degrees
    // 10  -> 10.05115966
    // 20  -> 20.41898423
    // 30  -> 31.47292373
    // 40  -> 43.71150321
    // 50  -> 57.90788114
    // 60  -> 75.45612929
    // 70  -> 99.43196452
    // 80  -> 139.5866167
    // 89  -> 271.6592732
    
    /**
     * Forward Mercator (spherical) Transformation / Projection for latitude.
     * @param {float} sphericalDeg required Spherical degrees latitude to 
     * convert to Mercator (spherical) degrees.
     * @returns {float} degrees converted from spherical coordinates to
     * Mercator (spherical) degrees.
     * @private
     */ 
    function _M( sphericalDeg ) {
        var sphericalRad = _degToRad( sphericalDeg );
        var sinLat = Math.sin( sphericalRad );
        var mercatorRad = Math.log( (1.0 + sinLat) / (1.0 - sinLat) ) / 2.0;
        var mercatorDeg = _radToDeg(mercatorRad);
        return mercatorDeg;
    }

    /**
     * Reverse Mercator (spherical) Transformation / Projection for latitude.
     * @param {float} mercatorDeg required Mercator (spherical) degree latitude
     * to be converted back to spherical degrees latitude.
     * @returns {float} degrees converted from Mercator (spherical) degrees to
     * spherical coordinates.
     * @private
     */ 
    function _MInverse( mercatorDeg ) {
        var mercatorRad = _degToRad( mercatorDeg );
        var e2y = Math.exp( 2.0 * mercatorRad );
        var sphericalRad = Math.asin( (e2y - 1.0) / (e2y + 1.0) );
        var sphericalDeg = _radToDeg( sphericalRad );
        return sphericalDeg;
    }
    
    /**
     * Set-up the variables we need for projection calculations.
     * @returns {boolean} true if we are good to proceed, false if we are
     * missing something.
     * @private
     */
    function _MPrepareVariables() {
        if ( !_boundingBox ||
             ( !_pixelHeight && _pixelHeight !== 0 ) ||
             ( !_pixelWidth  && _pixelWidth  !== 0 ) ) {
             // Return silently, we aren't ready to prepare the variables
             return false;
        }
        
        // Pixels per degree longitude is one of the few constants we have
        // available with any Mercator math. Calculate this once here and
        // use it later.
        _pixelsPerLon = _pixelWidth / 
            Math.abs( _boundingBox.maxPosition.lon - _boundingBox.minPosition.lon );
        
        // Just in case something is checking for a successful set
        return true;  
    }
    // End Private Methods
    
    // Begin privileged methods
    /**
     * Return the associated BoundingBox.
     * @returns {BoundingBox} The current boundaries associated with this
     * projection. If the bounding box has not been set yet, this will be null.
     */
    this.getBoundingBox = function() {
        
        return _boundingBox;
    }
    /**
     * Set the associated BoundingBox. All calculations rely on a rectangular
     * boundary.
     * @param {BoundingBox} boundingBox required Instance representing the
     * degree boundaries of our map.
     * @throws {Exception} If boundingBox is not correctly set.
     */
    this.setBoundingBox = function(boundingBox) {
        
        if( boundingBox.minPosition == undefined || boundingBox.maxPosition == undefined ) {
            throw new Exception( "deCarta.Math.MercatorSpherical.setPixelHeight passed invalid boundingBox of: " +  boundingBox);
        }
        else {
            _boundingBox = boundingBox;
        }
    }
    /**
     * Return the pixel height of the mercator "map" we are dealing with.
     * @returns {int} the number of pixels tall the map is, or
     * null of the height of the map has not been set.
     */
    this.getPixelHeight = function() {
        
        return _pixelHeight;
    }
    /**
     * Set the pixel height of the mercator "map" we are dealing with.
     * @param {int} pixelHeight required The number of pixels tall the map is.
     * @throws {Exception} for attempting to pass in an invalid height.
     */
    this.setPixelHeight = function(pixelHeight) {
        
        var pxH = parseInt( pixelHeight, 10 );
        if( isNaN(pxH) || (pxH < 0) ) {
            throw new Exception( "deCarta.Math.MercatorSpherical.setPixelHeight passed invalid height of: " + pixelHeight );
        }
        else {
            _pixelHeight = pxH;
        }
    }
    /**
     * Return the pixel width of the mercator "map" we are dealing with.
     * @returns {int} the number of pixels wide the map is, or
     * null of the width of the map has not been set.
     */
    this.getPixelWidth = function() {
        
        return _pixelWidth;
    }
    /**
     * Set the pixel width of the mercator "map" we are dealing with.
     * @param {int} pixelWidth required The number of pixels wide the map is.
     * @throws {Exception} for attempting to pass in an invalid width.
     */
    this.setPixelWidth = function(pixelWidth) {
        
        var pxW = parseInt( pixelWidth, 10 );
        if( isNaN(pxW) || (pxW < 0) ) {
            throw new Exception( "deCarta.Math.MercatorSpherical.setPixelWidth passed invalid width of: " + pixelWidth );
        }
        else {
            _pixelWidth = pxW;
        }
    }
    
    /**
     * Convert from spherical degrees (latitude, longitude) to 
     * pixel coordinates (x, y). We assume that the position being passed in
     * exists within the bounding box recognized by this map. The pixel location
     * returned is relative to the area we are dealing with, and uses standard
     * web browser pixel notation -- the upper left corner is the origin at
     * 0, 0. Positive x extends to the right, and positive y extends down,
     * relative to the viewer of the map.
     * @param {Position} pos required Spherical coordinates we wish to convert
     * to a pixel location relative the boundaries of our map.
     * @throws {Exception} If the projector has not been initialized correctly.
     * @returns {PixelPoint} The relative pixel location on the map, equivalent
     * to the spherical coordinate position. Note: the pixels are not rounded
     * off.
     */
    this.positionToPixels = function( pos ) {
        
        // We need a raft of variables. This also checks to see if we are 
        // ready to calculate the mercator values.
        if (!_MPrepareVariables() || !pos || 
           (!pos.lat && pos.lat != 0) || 
           (!pos.lon && pos.lon != 0) ) {
            throw new Exception( "deCarta.Math.MercatorSpherical.positionToPixels: " +
            "need to setBoundingBox, setPixelHeight and setPixelWidth prior to " +
            "calculating positionToPixels" );
        }
        
        // Figure out location from the upper left corner
        var pix = new PixelPoint( 0, 0 );
        // The x is a straight forward calculation.
        pix.x = _pixelsPerLon * ( _boundingBox.minPosition.lon - pos.lon ) * -1;
        // We approximate the y location as a ratio location of the mercator
        // degrees.
        var mercatorOffset = _M(_boundingBox.maxPosition.lat) - _M(pos.lat);
        var mercatorRange = _M(_boundingBox.maxPosition.lat) - _M(_boundingBox.minPosition.lat);
        pix.y = _pixelHeight * mercatorOffset / mercatorRange;
        
        return pix;
    }


    /**
     * Convert from pixel coordinates (x, y) to spherical degrees (latitude, 
     * longitude). We assume that the pixel point passed in
     * exists within the bounding box recognized by this map. The pixel location
     * should be in standard web browser pixel notation: the upper left 
     * corner is the origin at 0, 0; positive x extends to the right; positive y 
     * extends down, all relative to the viewer of the map.
     * @param {PixelPoint} pix required The relative pixel location on the map, 
     * equivalent to the spherical coordinate position. Note: the pixels do
     * not have to be rounded off.
     * @throws {Exception} If the projector has not been initialized correctly.
     * @returns {Position} Spherical coordinate location within the boundaries 
     * of our map.
     */
    this.pixelsToPosition = function( pix ) {
        
        // We reuse a raft of variables. This also checks to see if we are 
        // ready to calculate the mercator values.
        if (!_MPrepareVariables() || !pix ||
           (!pix.x && pix.x != 0) || 
           (!pix.y && pix.y != 0) ) {
            throw new Exception( "deCarta.Math.MercatorSpherical.positionToPixels: " +
            "need to setBoundingBox, setPixelHeight and setPixelWidth prior to " +
            "calculating pixelsToPositiion" );
        }
        
        var pos = new Position(0, 0);
        // Calculating longitude degrees is a straight forward conversion.
        pos.lon = _boundingBox.minPosition.lon + (pix.x / _pixelsPerLon);
        // We approximate the latitude degree as a ratio of the mercator
        // degrees and pixel.
        var mercatorRange = _M(_boundingBox.maxPosition.lat) - _M(_boundingBox.minPosition.lat);
        var mercatorOffset = (pix.y / _pixelHeight) * mercatorRange;
        pos.lat = _MInverse( _M(_boundingBox.maxPosition.lat) - mercatorOffset );
        
        return pos;
    }
    // End privileged methods
};


/**
 * Construct a new Mercator ellipsoidal projection value converter.
 * @class The MercatorEllipsoidal class performs client side raw
 * Mercator calculations. There are other functions available within this 
 * library that can help with Mercator calculations, although all are tied
 * directly to the inner workings of our code.<br>
 * If there is a need to perform Mercator Ellipsoidal math, this
 * class should be used like so:<br>
 * <br>
 * var mercatorE = new deCarta.Math.MercatorEllipsoidal();<br>
 * // minPosition and maxPosition are Position objects
 * mercatorE.setBoundingBox( new BoundingBox(minPosition, maxPosition) );<br>
 * // The integer, pixel dimensions of our map
 * mercatorE.setPixelHeight( pixHigh );<br>
 * mercatorE.setPixelWidth( pixWidth );<br>
 * // To calculate and return the PixelPoint location of a Position named myPos<br>
 * var calcPx = mercatorE.positionToPixels( myPos );<br>
 * // To calculate and return the Position location of a PixelPoint named myPx<br>
 * var calcPos = mercatorE.pixelsToPosition( myPx );<br>
 * @constructor
 * @private
 */
deCarta.Math.MercatorEllipsoidal = function() {
    
    // Begin Constructor
    // Protected fields
    var _boundingBox = null;
    var _pixelHeight = null;
    var _pixelWidth = null;
    // Private fields
    var _pixelsPerLon = null;
    // End Constructor
    
    // Begin Private methods
    /**
     * Convert degrees to radians.
     * @param {float} deg required Spherical coordinates to convert.
     * @returns {float} radial coordinates.
     * @private
     */
    function _degToRad( deg ) {
        return (deg * Math.PI / 180 );
    }
    
    /**
     * Convert radians to degrees.
     * @param {float} rad required Radial coordinates to convert.
     * @returns {float} spherical coordinates.
     * @private
     */
    function _radToDeg( rad ) {
        return (rad * 180 / Math.PI )
    }
    
    // MERCATOR ELLIPSOIDAL TEST DATA
    // Forward Mercator should translate to right side of ->
    // Inverse Mercator should translate back to left side of -> with little 
    // error
    // Unprojected Degrees -> Mercator Ellipsoidal Degrees
    // 0  -> 0
    // 10 -> 9.984550728
    // 20 -> 20.28776482
    // 30 -> 31.28103678
    // 40 -> 43.46472809
    // 50 -> 57.61367168
    // 60 -> 75.12339923
    // 70 -> 99.07082356
    // 80 -> 139.2080635
    // 89 -> 271.2749129

    
    /**
     * Forward Mercator (ellipsoidal) Transformation / Projection for latitude.
     * @param {float} sphericalDeg required Spherical degrees latitude to 
     * convert to Mercator (ellipsoidal) degrees.
     * @returns {float} degrees converted from spherical coordinates to
     * Mercator (ellipsoidal) degrees.
     * @private
     */ 
    function _M( sphericalDeg ) {
        // The eccentricity constant of our model earth ellipsoid
        var ecc = 0.081819190842;
        var sphericalRad = _degToRad( sphericalDeg );
        var eccSinLat = ecc * Math.sin( sphericalRad );
        
        var mercatorRad = Math.log( Math.pow( ((1 - eccSinLat) / (1 + eccSinLat)), ecc/2 ) * 
            Math.tan((Math.PI/4) + (sphericalRad/2)) );
        var mercatorDeg = _radToDeg(mercatorRad);
        return mercatorDeg;
    }

    /**
     * Reverse Mercator (ellipsoidal) Transformation / Projection for latitude.
     * @param {float} mercatorDeg required Mercator (ellipsoidal) degree latitude
     * to be converted back to spherical degrees latitude.
     * @returns {float} degrees converted from Mercator (ellipsoidal) degrees to
     * spherical coordinates.
     * @private
     */ 
    function _MInverse( mercatorDeg ) {
        var mercatorRad = _degToRad( mercatorDeg );
        // Re-used throughout our functions
        var eToMinusMercRad = Math.pow( Math.E, -mercatorRad );
        // To convert back from Mercator Degrees to Spherical Degrees, we must
        // iterate through a succession of functions
        // First, the simple function, on our way back to spherical radians
        var sphericalRadIter = conversionFirst();

        // Now run iterations of the next function to cut down on the
        // possible error in computation, and narrow in on our real value
        for( var i = 0; i < 6; i++ ) {
            sphericalRadIter = conversionIter( sphericalRadIter );
        }
        
        var sphericalDeg = _radToDeg( sphericalRadIter );
        return sphericalDeg;
        
        // Internal functions below
        // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        function conversionFirst() {
            return Math.PI/2 - 2 * Math.atan( eToMinusMercRad );
        }
        
        // This function is our way to Spherical radians.
        function conversionIter( y ) {
            // The eccentricity constant of our model earth ellipsoid
            var ecc = 0.0818191908426216;
            var eccSinY = ecc * Math.sin( y );
            // markj would appreciate this variable name
            var atanThis = eToMinusMercRad * Math.pow((1 - eccSinY) / (1 + eccSinY), ecc/2 );
            var sRadNextIter = (Math.PI/2) - (2 * Math.atan( atanThis ));
            return sRadNextIter;
        }
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Internal functions above
    }
    
    /**
     * Set-up the variables we need for projection calculations.
     * @returns {boolean} true if we are good to proceed, false if we are
     * missing something.
     * @private
     */
    function _MPrepareVariables() {
        if ( !_boundingBox ||
             ( !_pixelHeight && _pixelHeight !== 0 ) ||
             ( !_pixelWidth  && _pixelWidth  !== 0 ) ) {
             // Return, we aren't ready
             return false;
        }
        
        // Pixels per degree longitude is one of the few constants we have
        // available with any Mercator math. Calculate this once here and
        // use it later.
        _pixelsPerLon = _pixelWidth / 
            Math.abs( _boundingBox.maxPosition.lon - _boundingBox.minPosition.lon );
        
        // Just in case something is checking for a successful set
        return true;  
    }
    // End Private Methods
    
    // Begin privileged methods
    /**
     * Return the associated BoundingBox.
     * @returns {BoundingBox} The current boundaries associated with this
     * projection. If the bounding box has not been set yet, this will be null.
     */
    this.getBoundingBox = function() {
        
        return _boundingBox;
    }
    /**
     * Set the associated BoundingBox. All calculations rely on a rectangular
     * boundary.
     * @param {BoundingBox} boundingBox required Instance representing the
     * degree boundaries of our map.
     * @throws {Exception} If boundingBox is not correctly set.
     */
    this.setBoundingBox = function(boundingBox) {
        
        if( boundingBox.minPosition == undefined || boundingBox.maxPosition == undefined ) {
            throw new Exception( "deCarta.Math.MercatorEllipsoidal.setPixelHeight passed invalid boundingBox of: " +  boundingBox);
        }
        else {
            _boundingBox = boundingBox;
        }
    }
    /**
     * Return the pixel height of the mercator "map" we are dealing with.
     * @returns {int} the number of pixels tall the map is, or
     * null of the height of the map has not been set.
     */
    this.getPixelHeight = function() {
        
        return _pixelHeight;
    }
    /**
     * Set the pixel height of the mercator "map" we are dealing with.
     * @param {int} pixelHeight required The number of pixels tall the map is.
     * @throws {Exception} for attempting to pass in an invalid height.
     */
    this.setPixelHeight = function(pixelHeight) {
        
        var pxH = parseInt( pixelHeight, 10 );
        if( isNaN(pxH) || (pxH < 0) ) {
            throw new Exception( "deCarta.Math.MercatorEllipsoidal.setPixelHeight passed invalid height of: " + pixelHeight );
        }
        else {
            _pixelHeight = pxH;
        }
    }
    /**
     * Return the pixel width of the mercator "map" we are dealing with.
     * @returns {int} the number of pixels wide the map is, or
     * null of the width of the map has not been set.
     */
    this.getPixelWidth = function() {
        
        return _pixelWidth;
    }
    /**
     * Set the pixel width of the mercator "map" we are dealing with.
     * @param {int} pixelWidth required The number of pixels wide the map is.
     * @throws {Exception} for attempting to pass in an invalid width.
     */
    this.setPixelWidth = function(pixelWidth) {
        
        var pxW = parseInt( pixelWidth, 10 );
        if( isNaN(pxW) || (pxW < 0) ) {
            throw new Exception( "deCarta.Math.MercatorEllipsoidal.setPixelWidth passed invalid width of: " + pixelWidth );
        }
        else {
            _pixelWidth = pxW;
        }
    }
    
    /**
     * Convert from spherical degrees (latitude, longitude) to 
     * pixel coordinates (x, y). We assume that the position being passed in
     * exists within the bounding box recognized by this map. The pixel location
     * returned is relative to the area we are dealing with, and uses standard
     * web browser pixel notation -- the upper left corner is the origin at
     * 0, 0. Positive x extends to the right, and positive y extends down,
     * relative to the viewer of the map.
     * @param {Position} pos required Spherical coordinates we wish to convert
     * to a pixel location relative the boundaries of our map.
     * @throws {Exception} If the projector has not been initialized correctly.
     * @returns {PixelPoint} The relative pixel location on the map, equivalent
     * to the spherical coordinate position. Note: the pixels are not rounded
     * off.
     */
    this.positionToPixels = function( pos ) {
        
        
        // We need a raft of variables. This also checks to see if we are 
        // ready to calculate the mercator values.
        if (!_MPrepareVariables() || !pos || 
            (!pos.lat && pos.lat != 0) || 
            (!pos.lon && pos.lon != 0) ) {
            throw new Exception( "deCarta.Math.MercatorEllipsoidal.positionToPixels: " +
            "need to setBoundingBox, setPixelHeight and setPixelWidth prior to " +
            "calculating positionToPixels" );
        }
        
        // Figure out location from the upper left corner
        var pix = new PixelPoint( 0, 0 );
        // The x is a straight forward calculation.
        pix.x = _pixelsPerLon * ( _boundingBox.minPosition.lon - pos.lon ) * -1;
        // We approximate the y location as a ratio location of the mercator
        // degrees.
        var mercatorOffset = _M(_boundingBox.maxPosition.lat) - _M(pos.lat);
        var mercatorRange = _M(_boundingBox.maxPosition.lat) - _M(_boundingBox.minPosition.lat);
        pix.y = _pixelHeight * mercatorOffset / mercatorRange;
        
        return pix;
    }


    /**
     * Convert from pixel coordinates (x, y) to spherical degrees (latitude, 
     * longitude). We assume that the pixel point passed in
     * exists within the bounding box recognized by this map. The pixel location
     * should be in standard web browser pixel notation: the upper left 
     * corner is the origin at 0, 0; positive x extends to the right; positive y 
     * extends down, all relative to the viewer of the map.
     * @param {PixelPoint} pix required The relative pixel location on the map, 
     * equivalent to the spherical coordinate position. Note: the pixels do
     * not have to be rounded off.
     * @throws {Exception} If the projector has not been initialized correctly.
     * @returns {Position} Spherical coordinate location within the boundaries 
     * of our map.
     */
    this.pixelsToPosition = function( pix ) {
        

        // We reuse a raft of variables. This also checks to see if we are 
        // ready to calculate the mercator values.
        if (!_MPrepareVariables() || !pix || 
           (!pix.x && pix.x != 0) || 
           (!pix.y && pix.y != 0) ) {
            throw new Exception( "deCarta.Math.MercatorEllipsoidal.positionToPixels: " +
            "need to setBoundingBox, setPixelHeight and setPixelWidth prior to " +
            "calculating pixelsToPositiion" );
        }
        
        var pos = new Position(0, 0);
        // Calculating longitude degrees is a straight forward conversion.
        pos.lon = _boundingBox.minPosition.lon + (pix.x / _pixelsPerLon);
        // We approximate the latitude degree as a ratio of the mercator
        // degrees and pixel.
        var mercatorRange = _M(_boundingBox.maxPosition.lat) - _M(_boundingBox.minPosition.lat);
        var mercatorOffset = (pix.y / _pixelHeight) * mercatorRange;
        pos.lat = _MInverse( _M(_boundingBox.maxPosition.lat) - mercatorOffset );
        
        return pos;
    }
    // End privileged methods
};

// End classes not used in mobile

/**
 * Resolve the distance between two points on the earth.
 * Implementation of the Haversine formula for resolution of the great circle
 * distance. This formula can have up to a +/- 0.3% error.
 * @param {Position} pos1 required Coordinate to measure distance from.
 * @param {Position} pos2 required Coordinate to measure distance to.
 * @param {UOM} uom optional Units in which to return the result. If not passed,
 * results will be returned in meters.
 * @throws {Exception} If pos1, pos2 are not defined, to prevent
 * accidental passing of null values, or if uom is not recognized.
 * @returns {float} distance between coordinates in meters (default) or
 * requested unit conversion (uom argument). 
 * @private
 * @static
 */
deCarta.Math.greatCircleDist = function(pos1, pos2, uom) {
    
    
    if (!pos1 || !pos2) {
        throw new Exception("Utilities.greatCircleDist: must have valid coords");
    }
    // set-up for the haversine formula
    var lat1 = Math.PI * pos1.lat / 180;
    var cosLat1 = Math.cos(lat1);
    var lon1 = Math.PI * pos1.lon / 180;
    var lat2 = Math.PI * pos2.lat / 180;
    var cosLat2 = Math.cos(lat2);
    var lon2 = Math.PI * pos2.lon / 180;
    var deltaLon = Math.abs(Math.abs(lon1) - Math.abs(lon2));
    // approximated earth radius in meters
    var earthRadius = 6372795;
    var resultDist;
    
    // The haversine formula that solves for degrees difference
    var deltaRads = 2 * Math.asin( Math.sqrt( Math.pow( Math.sin(((lat2 - lat1) / 2)), 2) + 
        (cosLat1 * cosLat2 * Math.pow(Math.sin(deltaLon/2),2) ) ) );
    // Result before conversion;
    resultDist = earthRadius * deltaRads;
    
    // No conversion needed
    if(!uom || uom.value == "M" ) {
        return resultDist;
    }

    // Else convert
    switch(uom.value) {
        case "KM":
            resultDist /= 1000;
            break;
        case "MI":
            resultDist /= 1609;
            break;
        case "FT":
            resultDist *= 3.28084;
            break;
        default:
            throw new Exception("Utilities.greatCircleDist: unexpected uom value of: " +
              uom.value );
            break;
    }
    return resultDist;
};

/**
 * The base point in polygon geofence equation used for client side geofence
 * checks.
 * @param {Array} polygonVertices required Array of Positions describing the
 * vertices of the polygon arranged in drawing order from beginning to end.
 * @param {Position} testPos required Coordinate to check against the polygon
 * for insideness or outsideness.
 * @returns {boolean} true if the point is within the bounds of the vertices,
 * false if the point is outside of the vertices.
 * @private
 * @static
 */
deCarta.Math.pointInPolygon = function( polygonVertices, testPos ) {
    
    
    //private internal functions
    function hasChangedAbove(above, pos, polyPos)
    {
        if(pos.lat < polyPos.lat) //test pos is ABOVE
        {
            if(above) //so if it's above to begin with
            { return false; } //hasn't changed
            else
            { return true; } //test pos is now above, when it was below, so say it has changed
        }
        else //test pos is BELOW
        {
            if(!above) //was below to begin with
            { return false; } //hasn't changed
            else
            { return true; } //was above, now is below, so it has changed
        }
    }
    function hasChangedLeft(left, pos, polyPos)
    {
        if(pos.lon < polyPos.lon) //test pos is to the RIGHT
        {
            if(!left) //it was right to begin with
            { return false; } //hasn't changed
            else
            { return true; } //test pos is now right, when it was left, so say it has changed
        }
        else //test pos is LEFT
        {
            if(left) //was left to begin with
            { return false; } //hasn't changed
            else
            { return true; } //was right, now is left, so it has changed
        }
    } 
    
    //create all of our variables for the in or out test
    var left;    //boolean for if the point is to the left of our pos
    var above;   //boolean for if the point is above our pos
    var leftIntersections = 0; //int for how many left intersections
    var rightIntersections = 0; //int for how many right intersections
    
    //initialize the variables correctly
    //remember, latitude is the Y and longitude is the X
    if(testPos.lat < polygonVertices[0].lat) //if it's above
    { above = true; }
    else
    { above = false; }
    if(testPos.lon < polygonVertices[0].lon) //if it's to the right
    { left = false; }
    else
    { left = true; }
    
    // We're going to step through each position. If above changes, there's an intersection.
    // If left changes, we increment different variables. If both change, we have some math on our hands!
    for (var x in polygonVertices)
    {
        
        var leftChanged = hasChangedLeft(left, testPos, polygonVertices[x]);
        var aboveChanged = hasChangedAbove(above, testPos, polygonVertices[x]);
        
        if(leftChanged && aboveChanged) //we deal with the bad case first
        { 
            //we're going to get the slope between the two points on the polygon
            var deltaY = polygonVertices[x].lat - polygonVertices[x-1].lat;
            var deltaX = polygonVertices[x].lon - polygonVertices[x-1].lon;
            var polySlope = deltaY / deltaX;
            
            //now for the slope between the test point and the last point
            deltaY = testPos.lat - polygonVertices[x-1].lat;
            deltaX = testPos.lon - polygonVertices[x-1].lon;
            var posSlope = deltaY / deltaX;
            
            //now for a big switch statement!!!
            if((left && !above) || (!left && !above)) //if left and below or right and below
            {
                if(posSlope > polySlope) //if pos slope is more (more positive)
                { rightIntersections++; } //it's a right intersection
                else
                { leftIntersections++;}
            }
            if((!left && above) || (left && above)) //if right and above or left and above
            {
                if(posSlope < polySlope)
                { rightIntersections++; }
                else
                { leftIntersections++; }
            }
            
            //maintain the variables...
            left = !left;
            above = !above;
        }
        else //it's not a bad case, just a normal case
        {     
            if(leftChanged) //switch left
            { left = !left; }
            
            if(aboveChanged) //intersection time baby!!!
            {
                above = !above;
                if(left) //if it's to the left, increment leftIntersections
                { leftIntersections++;}
                else
                { rightIntersections++;}
            }
        }
    } //END LOOP
    
    //now check if the position is inside or outside the polygon
    if(leftIntersections % 2 == 0)
    { 
        //pin is OUT
        return false;
    }   
    else
    { 
        //pin is IN
        return true;
    }
};


/**
 * Calculate the heading, or bearing, of a line segment made up of two 
 * Positions. Positions are assumed to be in spherical degrees. Sticking to
 * a heading between 0 through 180 and 0 through -180 chosen to make determination
 * of parallel but opposite headings very easy.
 * @param {Position} pos1 required The "from" point of the line segment.
 * @param {Position} pos2 required The "to" point of the line segment.
 * @throws {Exception} If the objects are not position objects, throw an
 * exception.
 * @returns {float} The heading expressed as a float between 0 (north) through
 * less than 180, where the degrees count in a clockwise direction and 0 (north)
 * through -180, where the degrees count in a counter-clockwise direction.
 * @static
 * @private
 */
deCarta.Math.headingFromPositions = function( pos1, pos2 ) {
    
    
    if ( !pos1 || (!pos1.lat && pos1.lat != 0) || (!pos1.lon && pos1.lon != 0) || !pos2 || (!pos2.lat && pos2.lat != 0) || (!pos2.lon && pos2.lon != 0) ) {
        throw new Exception( "deCarta.Math.headingFromPosition: bad arguments." );
    }
    
    // Used to convert to radians
    var radConvert = Math.PI / 180;
    // Point 1 parts in radians
    var rLat1 = pos1.lat * radConvert;
    var rLon1 = pos1.lon * radConvert;
    // Point 2 parts in radians
    var rLat2 = pos2.lat * radConvert;
    var rLon2 = pos2.lon * radConvert;

    // This is our bearing
    var headingInRads = Math.atan2( Math.sin(rLon2-rLon1) * Math.cos(rLat2), 
        Math.cos(rLat1) * Math.sin(rLat2) - Math.sin(rLat1) * Math.cos(rLat2) * Math.cos(rLon2-rLon1) );
    
    // Convert back to degrees before returning
    return headingInRads / radConvert;
};
/**
 * @fileoverview deCarta JSON utility function: serialize a regular JS object to
 * a JSON string.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * Serialize a JavaScript object into a JSON string.
 * From Douglas Crockford's json.js library at:
 * http://www.json.org/json.js
 * @static
 * @example
 * // Simple to use...
 * var s = deCarta.ObjectToJSON(myObject);
 * @private
 * @param {object} value required Any JavaScript value, usually an
 * object or array.
 * @param {object} replacer optional An optional parameter that determines how
 * object values are stringified for objects. It can be a function or an
 * array of strings.
 * @param {object} space optional A parameter that specifies the indentation
 * of nested structures. If it is omitted, the text will be packed without extra
 * whitespace. If it is a number, it will specify the number of spaces to indent
 * at each level. If it is a string (such as '\t' or '&nbsp;'), it contains the
 * characters used to indent at each level.
 * @returns {string} The object as a serialized JSON string.
 * @throws {Exception} Only if you do something exceptionally bad and pass in
 * an incorrect replacer.
 */
deCarta.ObjectToJSON = function(value, replacer, space) {
    
    var i;
    var gap = '';
    var indent = '';
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    } else if (typeof space === 'string') {
        indent = space;
    }
    var rep = replacer;
    if (replacer && typeof replacer !== 'function' &&
            (typeof replacer !== 'object' ||
             typeof replacer.length !== 'number')) {
        throw new Exception('Bad replacer in deCarta.ObjectToJSON');
    }
    return str('', {'': value});

    /**
     * Deal with bad characters in a string, blah blah.
     * @inner
     */
    function quote(string) {
        var meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        };
        var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }

    /**
     * Perform the actual conversion on the object.
     * @inner
     */
    function str(key, holder) {
        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];
        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }
        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':
            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':
            return String(value);
        case 'object':
            if (!value) {
                return 'null';
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {
                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }
};

/**
  * @fileoverview OpenSearchQuery class
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
 
 /**
  * @class OpenSearchQuery allows you to programmatically access OpenSearch 
  * Compliant web services on your own system. See 
  * http://www.opensearch.org/Specifications/OpenSearch/Extensions/Geo/1.0/Draft_1 
  * for more details. Since the list of URL parameters is flexible you can use 
  * this object to call into an arbitrary URL based service that returns a 
  * string of results. The returned string should be handled in the callback 
  * method.  If you run your service on a different site from the webpage that 
  * calls the query you will need to run a proxy service to handle the server 
  * of origin restriction present in current browsers.
  * @description Construct an instance of class.
  * @see Utilities#parseKML
  */
function OpenSearchQuery(){
    
	/** @private */
	this.url = null;
	/** @private */
	this.callback = null;
	/** @private */
	this.params = null;
}
/**
 * This sets the callback that will receive the response text from the server,
 * whether it be GeoJSON KML or whatever.
 * @param {Object} callback
 * @see Utilities#parseKML
 */
OpenSearchQuery.prototype.setCallback = function(callback){
    
	this.callback=callback;
};
/**
 * this is the full url to the OpenSearch service.
 * @param {Object} url
 */
OpenSearchQuery.prototype.setURL = function(url){
    
	this.url=url;
};
/**
 * this function takes an object (name : value) for the params to be sent to the
 * server, for example
 * {"q":"pizza","lat":"37.5","lon":"-122.5","radius":"1000","format":"kml"}
 * @param {Object} params
 */
OpenSearchQuery.prototype.setParams = function(params){
    
	this.params="?";
	for(var x in params){
		if(params.hasOwnProperty(x)){
			this.params+=x+"="+params[x]+"&";
		}
	}
};
/**
 * sends request, using the XMLHTTPRequest object, remember that the server must
 * obey the 'server of origin policy' by being the same server from which the
 * site loaded.
 */
OpenSearchQuery.prototype.send = function(){
    
	var that=this;
   	if (!Utilities.ie){
		try { 
			netscape.security.PrivilegeManager.enablePrivilege("UniversalPreferencesWrite UniversalBrowserWrite UniversalPreferencesRead UniversalBrowserRead");
	    } catch (e) {}
	}
	var xmlhttp=new XMLHttpRequest();
	//Utilities.p(this.url+this.params)
	xmlhttp.open("POST",this.url+this.params,true);
    xmlhttp.onreadystatechange = function(){
		if (xmlhttp.readyState == 4){
			that.callback(xmlhttp.responseText);
		}
	}
	xmlhttp.send(null);	
};



/** 
 * @fileoverview POI
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class Points of Interest, or POIs, are locations on a map that have some 
 * meaning to the user. They could be restaurants, sales prospects, parking 
 * meters, really anything that is of interest. POIs are always located at a 
 * specific latitude and longitude coordinate, or {@link Position}, and will 
 * have specific information associated with them. Instances of the POI class 
 * within the deCarta JavaScript API will be created, and returned, with a 
 * successful {@link POIQuery} from the underlying map data used with the DDS 
 * Web Services. Should an application have access to proprietary data that is 
 * to be displayed on a {@link Map}, the POI object is not necessarily needed; 
 * one can simply display the proprietary data within a {@link Pin} overlaid on 
 * the Map.
 * @description Construct a new POI object.
 * @param {String} name required The name of this POI, also the most likely way
 * this POI would be labeled on a Map.
 * @param {Position} position required The latitude and longitude coordinate 
 * that this POI is located at.
 * @param {Address} address required The structured Address representing the 
 * POI Address.
 * @param {String} phoneNumber required The phone number for this POI, null 
 * if the POI has no phone contact information.
 * @param {Object} properties optional Dynamic object of all the other 
 * properties associated with this POI.
 * @constructor
 * @see POIQuery
 * @see Pin
 * @see Address
 * @see CorridorSearchQuery
 */
function POI(name, position, address, phoneNumber, properties) {
    
    /**
     * The name of this POI, also the most likely way this POI would be labeled 
     * on a Map.
     * @type String
     */
    this.name = name;

    /** 
     * The latitude and longitude coordinate that this POI is located at.
     * @type Position 
     */
    this.position = position;

    /** 
     * The Structured {@link Address} representing the POI Address.
     * @type Address
     */
    this.address = address;

    /**
     * The phone number for this POI, null if the POI has no phone contact 
     * information.
     * @type String 
     */
    this.phoneNumber = phoneNumber;

    /**
     * If this exists, describes the distance this POI exists from the location
     * the query was made to find it. If this property has no contextual meaning
     * this property will be null.
     * Standard sub properties attached to the distance object are:
     * <ul>
     * <li>.value (number type, number of distance units)</li>
     * <li>.uom   (UOM type, unit of measure for the value)</li>
     * </ul>
     * @type object
     * @default null
     */
    this.distance = null;

    /**
     * Dynamic object of all the other properties associated with this POI.
     * @type String 
     */
    this.properties = properties || {};

    /**
     * Concatenates the POI information into a single, space delimited string.
     * @return {String} The name, position, address, and phoneNumber fields, 
     * in that order.
     */
    this.toString = function(){
        return this.name + " " + this.position + " " + this.address + " " + this.phoneNumber;
    }
    /**
     * Returns an object conforming to the format returned by WebServices
     */
    this.toWSFormat = function(){
        
        var poi = {};

        poi.POIName = this.name;
        poi.phoneNumber = this.phoneNumber;
        poi.ID = this.properties.ID;

        poi.POIAttributeList = {};
        poi.POIAttributeList.POIInfoList = [];

        for (var prop in this.properties){
            if (prop != 'ID') poi.POIAttributeList.POIInfoList.push({name: prop, value: this.properties[prop]});
        }

        poi.Address = {};
        poi.Address.PostalCode = this.address.postalCode;
        poi.Address.CountryCode = this.address.countryCode;
        poi.Address.freeFormAddress = this.properties['freeform-address'];
        poi.Address.StreetAddress = {
            Street: this.address.street,
            Building: {
                number: this.address.buildingNumber
            }
        }
        poi.Address.Place = [];

        function ucfirst(str){
            str += '';
            var f = str.charAt(0).toUpperCase();
            return f + str.substr(1);
        }

        for (var prop in this.address){
            if (typeof this.address[prop] !== 'function')
                poi.Address.Place.push({content: this.address[prop], type: ucfirst(prop)});
        }

        poi.Point = {
            "ns5": "http://www.opengis.net/gml",
            "pos": this.position.lat + ' ' + this.position.lon
        }

        return poi;
    }
}

/** 
 * @fileoverview POIQuery
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class The underlying mapping data often contains Point of Interest, or POI, 
 * information that can be mined, formatted, and displayed. The available POI 
 * data is varied and different among the data providers, and even among the 
 * different releases of data. However, what is available is often useful if a 
 * developer wishes to display common types of POIs on a map. To search for 
 * POIs within the data underlying the DDS Web Services, create and use a 
 * POIQuery. A POIQuery can be used independently from a {@link Map} object, should
 * the need arise to do so.
 * @description Construct a new POIQuery object.
 * @constructor
 * @see POI
 * @see SearchCriteria
 */
function POIQuery() {
    
    
    /**
     * Used to generate the XML request docs.
     * @private
     */
    this.xmlRecFac = new deCarta.XMLStringBuilder();
    /**
     * "Dictionary" storage for callback functions.
     * @private
     */
    var _callBackArray = [];
    /**
     * JavaScript closure reference.
     * @private
     */
    var self = this;
    
    /**
     * Authenticate the POIQuery. If you have already authenticated another 
     * object, or have manually set the authentication fields of the Credentials 
     * object, you do not have to use this function.
     * @param {String} clientName required Set with the clientName 
     * authentication token.
     * @param {String} clientPassword required Set with the clientPassword 
     * authentication token.
     * @throws {Exception} "Error authenticating POIQuery, invalid parameters."
     * @see Credentials
     */
    this.authenticate = function(clientName, clientPassword) {
        
        if(!clientName || !clientPassword || clientName=="" || clientPassword==""){
            throw new Exception("Error authenticating POIQuery, invalid parameters.");
            return false;
        }
        Credentials.clientName = clientName;
        Credentials.clientPassword = clientPassword;
        // 4.4.1
        this.xmlRecFac.clientName = clientName;
        this.xmlRecFac.clientPassword = clientPassword;
    }

    /** 
     * Search the underlying map data for POIs. POIs returned must match the 
     * specifications defined by the provided {@link SearchCriteria}.
     * <p>Calling this function makes an asynchronous request to the DDS Web 
     * Services. To handle the POIs found by a successful search, the 
     * application should provide a callBack function that has the following 
     * prototype:</p>
     * <p><code>function callBack(arrayPOIs)</code></p>
     * <p>where</p>
     * <ul>
     * <li>callBack = Arbitrary function name</li>
     * <li>arrayPOIs = On a successful search, the found POIs returned within 
     * an Array. If an Array of SearchCriteria objects are passed in, then
     * an Array of Arrays of POI objects will be returned</li>
     * </ul>
     * <p>If no POIs are found that match the SearchCriteria, the callBack 
     * function will be passed an empty array.</p>
     * @param {AbstractSearchCriteria} searchCriteria POIs returned must match
     * these constraints. Multiple SearchCriterias can be passed in within an
     * array to perform a multi-query search in one request.
     * {@link SearchCriteria}, {@link CorridorSearchCriteria} 
     * @param {function} callBack A function to catch, and handle, the 
     * POIs found.
     * @param {function} [timeoutCallback] Function to be called in case this
     * particular query times out.
     * @throws {Exception} If a function is not passed in as a callBack.
     * @see AbstractSearchCriteria
     * @see POI
     */
    this.query = function( searchCriteria, callBack, timeoutCallback ) {
        
        var reqId = Utilities.getRequestId();
        if ( typeof callBack == 'function' ) {
            _callBackArray[reqId] = callBack;
        } else {
            throw new Exception("POIQuery.query: callBack must be a function, arg was: " + callBack );
        }
        var xml = this.xmlRecFac.createPOIRequest(searchCriteria, reqId);
        JSRequest.send(xml, self.queryCallback, null, timeoutCallback);
    }
    /**
     * Request the full details of a POI from a previous Navsearch database
     * query.
     * @private
     * @param {string} poiId POIs Unique ID of a POI.
     * @param {function} callBack A function to catch, and handle, the details.
     * @param {function} [timeoutCallback] Function to be called in case this
     * particular query times out.
     */
    this.fullDetailsQuery = function( poiId, callBack, timeoutCallback) {
        
        var reqId = Utilities.getRequestId();
        if ( typeof callBack == 'function' ) {
            _callBackArray[reqId] = callBack;
        } else {
            throw new Exception("POIQuery.fullDetailsQuery: callBack must be a function, arg was: " + callBack );
        }
        var xml = this.xmlRecFac.createFullDetailsPOIRequest(poiId, reqId);
        JSRequest.send(xml, self.fullDetailsQueryCallback, null, timeoutCallback);
    }

    /**
     * Handle all responses from the Web Services.
     * @param {Object} data required The jsonified XLS response from web services.
     * @private
     */
    this.queryCallback = function(data) {
        
        
        var multipleResponses = false;
        // Counter, and also multi-array indexer
        var i;
        // Array filled via inner function
        var poiList = [];
        var reqId;
        if ( deCarta.JSONParser.parseErrors(data) ) {
            // Skips the next step, forcing an empty array to be returned
            reqId = data.XLS.Response.requestID;
        }
        else if( deCarta.Array.isArray(data.XLS.Response) ){
            // Get only the first response
            reqId = data.XLS.Response[0].requestID;
            multipleResponses = true;
            // Handle multiple responses
            for ( i = 0; i < data.XLS.Response.length; i++ ) {
                // Array of arrays
                poiList.push([]);
                parsePOIContext(data.XLS.Response[i].DirectoryResponse.POIContext);
            }
        }
        else {
            // only one response
            reqId = data.XLS.Response.requestID;
            parsePOIContext(data.XLS.Response.DirectoryResponse.POIContext);
        }

        if ( (reqId >= 0) && _callBackArray[reqId] ) {
            _callBackArray[reqId](poiList);
            _callBackArray[reqId] = undefined;
        }

        /**
         * Parse a POI context and add it to the outer poiList array.
         * @param {Object} poiContext required The POIContext object to parse
         * out.
         */
        function parsePOIContext(poiContext) {
            var pois;
            if ( !poiContext ) {
                // Ignore DirectoryResponse object on non-error queries
                return;
            }
            else if(poiContext.length == undefined) {
                // Single responses do not come back in an array, they come back
                // as objects
                pois = [];
                pois.push(poiContext);
            }
            else {
                // Multiple responses
                pois = poiContext;
            }
            // Parse out the found pois and add them to the outer poiList array
            for(var j=0; j < pois.length;j++){
                var poi = deCarta.JSONParser.parsePOI(pois[j]);
                if (multipleResponses) {
                    // Deal with location of multiple requests using our outer i counter
                    poiList[i].push(poi);
                }
                else {
                    // regular single request
                    poiList.push(poi);
                }
            }
        } // end parsePOIContext (inner function)
    };

    /**
     * Handle all full details data (reviews etc..)
     * @param {Object} data required The jsonified XLS response from web services.
     * @private
     */
    this.fullDetailsQueryCallback = function(data) {
        var reqId = data.XLS.Response.requestID;
        if ( (reqId >= 0) && _callBackArray[reqId] ) {
            _callBackArray[reqId]((data.XLS.Response.DirectoryResponse.POIContext.POI));
            _callBackArray[reqId] = undefined;
        }
    };
}
/*
			<xls:POIContext>
				<xls:POI POIName="MOSCONE PIZZADELLI" phoneNumber="+(1)-(415)-5419238" ID="0">
					<xls:POIAttributeList>
						<xls:POIInfoList>
							<xls:POIInfo name="ADDRESS INFO" value="257"/>
							<xls:POIInfo name="ID" value="100009962"/>
						</xls:POIInfoList>
					</xls:POIAttributeList>
					<gml:Point>
						<gml:pos>37.78461 -122.399995</gml:pos>
					</gml:Point>
					<xls:Address language="EN" countryCode="USA">
						<xls:StreetAddress>
							<xls:Building number="231"/>
							<xls:Street>3RD ST</xls:Street>
						</xls:StreetAddress>
						<xls:Place type="CountrySubdivision">CA</xls:Place>
						<xls:Place type="CountrySecondarySubdivision">SAN FRANCISCO</xls:Place>
						<xls:Place type="Municipality">SAN FRANCISCO</xls:Place>
						<xls:PostalCode>94103</xls:PostalCode>
					</xls:Address>
				</xls:POI>
				<xls:Distance uom="KM" value="0.243000"/>
			</xls:POIContext>
			<xls:POIContext>
				<xls:POI POIName="PIZZA PRADA" phoneNumber="+(1)-(415)-9820166" ID="0">
					<xls:POIAttributeList>
						<xls:POIInfoList>
							<xls:POIInfo name="ADDRESS INFO" value="239"/>
							<xls:POIInfo name="ID" value="100020917"/>
						</xls:POIInfoList>
					</xls:POIAttributeList>
					<gml:Point>
						<gml:pos>37.7869 -122.40812</gml:pos>
					</gml:Point>
					<xls:Address language="EN" countryCode="US">
						<xls:freeFormAddress>250 POWELL ST, SAN FRANCISCO, CA, 94102</xls:freeFormAddress>
					</xls:Address>
				</xls:POI>
				<xls:Distance uom="KM" value="0.835000"/>
			</xls:POIContext>
 */

/**
 * @fileoverview PanController
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class The PanController is only useful with {@link Map} instances. If a
 * @constructor
 * @param {object} opts 
 * @see Map#addPanController
 */
function PanController(opts){ this.init(opts); }



// ------------------------------------------------------------- Fields
/**
 * The map this particular PanController is associated with.
 * @type Map
 * @default null
 * @private
 */
PanController.prototype.map = null;
/**
 * General identifcation for this map control. Part of the general map control
 * interface. Treat as a read-only property.
 * @type string
 * @default "PanController"
 * @private
 */
PanController.prototype.type = "PanController";
/**
 * The on page div containing this PanController.
 * @type DOM Element (div)
 * @default null
 * @private
 */
PanController.prototype.frame = null;

/**
 * The CSS class that applies to this PanController. Also functions as the
 * id of the on screen frame.
 * @type string
 * @default "decarta-panController"
 * @private
 */
PanController.prototype.cssClass = "decarta-panController";

/**
 * Options object
 * @type Object
 * @default {
 *     xMargin: 0,
 *     yMargin: 0
 * }
 * @private
 */
PanController.prototype.opts = {
    screenPosition: 'topLeft',
    xMargin: 0,
    yMargin: 0
}


// ------------------------------------------------------------- Methods
/**
 * Initialize settings needed for the PanController object. All building
 * of the PanController happens after it is associated with a map.
 * @param {object} opts optional
 * @private
 */
PanController.prototype.init = function(opts) {

    if (!opts) opts = {};
    this.setOpts(opts);


    
};

/**
 * Sets op options
 * @param {object} opts Object containing options
 * (@link opts} See opts for valid options
 */
PanController.prototype.setOpts = function(opts){
    if (typeof opts.screenPosition  !== 'undefined') this.opts.screenPosition = opts.screenPosition;
    if (typeof opts.xMargin !== 'undefined') this.opts.xMargin = opts.xMargin;
    if (typeof opts.yMargin !== 'undefined') this.opts.yMargin = opts.yMargin;    
}

/**
 * Build the on page DOM elements, and associated event handling, that form
 * the UI of the PanController. Does not place the PanController onto
 * the map.
 * @private
 */
PanController.prototype.build = function() {
    

    this.frame = document.createElement("DIV");
    this.frame.id = this.cssClass;
    this.frame.className = this.cssClass;
    //deCarta.IdManager.setTag( this.frame, "ignoreForMapEvents" );

//    var innerFrame = document.createElement("DIV");
//    innerFrame.style.position="relative";

    var n = document.createElement("img");
    n.className = "decarta-panController-north";
    n.src=Credentials.imgPath+"z2t_pan_north.png";
    n.onclick=this.map.panNorth;
    var s = document.createElement("img");
    s.className = "decarta-panController-south";
    s.src=Credentials.imgPath+"z2t_pan_south.png";
    s.onclick=this.map.panSouth;
    var e = document.createElement("img");
    e.className = "decarta-panController-east";
    e.src=Credentials.imgPath+"z2t_pan_east.png";
    e.onclick=this.map.panEast;
    var w = document.createElement("img");
    w.className = "decarta-panController-west";
    w.src=Credentials.imgPath+"z2t_pan_west.png";
    w.onclick=this.map.panWest;
    var c = document.createElement("img");
    c.className = "decarta-panController-center";
    c.src=Credentials.imgPath+"z2t_pan_center_gray.png";

    var outerThis = this;
    c.onclick= function(){
        if(c.src.indexOf("loading-ball.gif")>-1){
            return;
        }
        c.src=Credentials.imgPath+"loading-ball.gif";
        var convertToPosition = Utilities.geolocateConvertPosition;
		
        var handleSuccess = function(pos){
            c.src=Credentials.imgPath+"z2t_pan_center_gray.png";
            outerThis.map.panToPosition(convertToPosition(pos));
        }
        var handleFailure = function(){
            c.src=Credentials.imgPath+"z2t_pan_center_gray.png";
            alert("unable to position");
        }

		try {
			Utilities.geolocate(handleSuccess, handleFailure);
		} catch (e){	
            c.src=Credentials.imgPath+"z2t_pan_center_gray.png";
            //alert("tell user to upgrade browser...");			
		}
    };

    this.frame.appendChild(n);
    this.frame.appendChild(s);
    this.frame.appendChild(e);
    this.frame.appendChild(w);
    this.frame.appendChild(c);

    this.position();
    //this.frame.appendChild( innerFrame );
};



/**
 * Interface used by the Map to grab the correct DOM object to append to the
 * page.
 * @returns {DOM Element} The DOM element representation of the PanController
 * that should be appended to the map object.
 * @private
 */
PanController.prototype.appendThis = function() {
    

    // Lazy create the frame
    if (!this.frame) {
        this.build();
    }

    return this.frame;
};

/**
 * Interface for the Map object to remove the PanController from the
 * DOM.
 * @returns {DOM Element} The DOM element representation of the PanController
 * that should be removed from the map object.
 * @private
 */
PanController.prototype.removeThis = function() {
    

    this.map = null;

    //@todo add any cleanup to this function, should we wish to.

    return this.frame;
};

/**
 * Repositions the PanController relative to the associated Map instance.
 * To be called after the PanController has been associated with a Map
 * and usually only needed when the Map has been resized. Part of the general
 * map control interface.
 * @param {DOMDimensions} ddim required Dimenions of map against which to
 * position this control.
 * @private
 */
PanController.prototype.position = function( ddim ) {
    
//    this.frame.style.top = "15px";
//    this.frame.style.left = "15px";

    switch (this.opts.screenPosition){
        default:
        case 'topLeft':
            //Using margins as the position is defined in css and
            //must keep bk compat.            
            this.frame.style.marginLeft = this.opts.xMargin + "px";
            this.frame.style.marginTop = this.opts.yMargin + "px";
        break;
        case 'topRight':
            throw('Not Implemented');
        break;
    }
};

/**
 * Handles clicks on the PanController links.
 * @private
 */
//PanController.prototype.handleClick = function() {
//    
//    // Quick exit if events should be ignored
//    if (!GLOBALS.ALLOWDOMEVENTS) {
//        return true;
//    }
//    this.owner.map.setMapType( this.mapType );
//    // Do not initiate standard link procedure
//    return false;
//};

/**
 * @fileoverview Pin class
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class A Pin is an abstract term for a dynamically created point, handled by
 * the client, and placed on a {@link Map}. Pins must be located at a specific
 * {@link Position} (latitude and longitude), are represented by an {@link Icon},
 * and can by default display information in a the {@link InfoWindow} associated
 * with a Map anytime the Pin is clicked. Pins can also be the focal point for
 * user created events, defined and assigned to a Pin object with the
 * {@link EventRegistry}.
 * @description Construct a new Pin object.
 * @param {Position} pos required The latitude and longitude coordinate where
 * this Pin will be located on a map.
 * @param {String} message optional A text or html message to display in the
 * pop-up InfoWindow.
 * @param {String} bubbleEventType optional Register a simple event used to
 * display the associated Pin message. The values "click" or "mouseover" can be
 * used. By default, interaction with the Pin is disabled. Some event will be
 * required to enable display of the associated message. Additional events
 * available through EventRegistry.
 * @param {Icon} icon optional If no Icon is passed in, the default used is a
 * green dot.
 * @throws {Exception} If the passed in pos argument is not a valid Position,
 * throw the exception, "Error instantiating Pin, must at least provide a
 * Position."
 * @constructor
 * @see Icon
 * @see Position
 * @see InfoWindow
 * @see EventRegistry
 * @see Map#addPin
 */  
function Pin(pos, message, bubbleEventType, icon){ 
    
    
    if(!pos){
        throw new Exception("Error instantiating Pin, must at least provide a Position.");
        return false;
    }

//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BEGIN CONSTRUCTOR
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv


    // Private/public safe back reference to this
    var self = this;
    // Current array of event listeners
    var _events = new Array();
    // Browser independent assistance for determining mouse clicks
    var _mouseClickThreshold = 170; // This is milliseconds
    var _mouseUpClock   = null;
    var _mouseClickEventId   = null; // Timeout id for click type checking
    var _doRightClick   = false;
    // Called when we actually begin dragging the pin
    var _isDragging     = false;
    // Helps handle the beginning of the drag event
    // These are the screen pixels equivalent to the clientX and clientY...
    var _dragBeginningScreenPix = null;
    // ...This is the absolute positining of the pin IMG on the map...
    var _dragBeginningImgPix = null;
    // ... and the location of the pinTxt...
    var _dragBeginningTxtPix = null;

    /**
     * deCarta type attribute to help in distinguishing objects.
     * @private
     */
    this.type = "pin";
    /**
     * Coordinate location of this pin.
     * @private
     */
    this.position = null;
    if( pos && pos.clone ) {
        this.position = pos.clone();
    }
    /**
     * Icon representation of this pin.
     * @private
     */
    this.icon = icon || new Icon(Credentials.pinIconPath,12,12,24,24);
    /**
     * Pointer to associated map object.
     * @private
     */
    this.map = null;
    /**
     * Pins can be in a visible or not visible (hidden) state. Change the
     * Pin state via the (show) and (hide) methods.
     * @see Pin#show
     * @see Pin#hide
     * @private
     * @type boolean
     * @default true
     */
    this.isVisible = true;

    /**
     * The id variable is an empty string reserved for custom pin 
     * identification, like numbering or naming each pin for ease of 
     * identity. The id does not have to be unique among Pins, thus the id can 
     * also be used to group like pins together to ease display or removal 
     * by group.
     * @type String
     * @default ""
     */
    this.id = "";

    /**
     * Pin div + img when placed on the map.
     * @private
     */
    this.pinImg = null;
    //TODO ALL THIS NEEDS TO GO IN TO SOME SET ICON FUNCTION
    // NOTE this document objects are not added to the DOM
    // until the map.addPin() function is called
    this.pinImg = document.createElement("img");
    var pinImgClassName = "decarta-pin";
    this.pinImg.className = pinImgClassName;
    this.pinImg.style.position = "absolute";
    this.pinImg.id = pos.toString();
    this.pinImg.src = this.icon.src;
    this.pinImg.style.width = parseInt(this.icon.width) + "px";	
    this.pinImg.style.height = parseInt(this.icon.height) + "px";		
    Pin.zIndexCounter++;
    this.pinImg.style.zIndex = Pin.zIndexCounter;
    this.pinImg.style.cursor = "pointer";
    this.pinImg.style.display = "block";
    this.pinImg.msg = message || "";
    // fix IE png issue
    // sizingMethod = 'scale' is necessary
    if ( Utilities.ie6 && this.pinImg.src.match(new RegExp("\\bpng\\b", "g")) ) {
        Utilities.fixPng(this.pinImg);
    }
    deCarta.IdManager.setTag( this.pinImg, "ignoreForMapEvents" );

    /**
     * Convenience reference to POI assocated with this Pin instance.
     * @private
     * @type POI
     * @default null
     */
    this.poi = null;
    /**
     * Convenience reference to hover Icon ON associated with this Pin instance.
     * @private
     * @type Icon
     * @default null
     */
    this.hoverIconOn = null;
    /**
     * Convenience reference to hover Icon OFF associated with this Pin instance.
     * @type Icon
     * @default null
     */
    this.hoverIconOff = null;
    
    /**
     * Overlay text div when placed on the map.
     * @private
     */
    this.pinTxt = null;
    // set the pinTxt to the DIV 
    // TODO: (this should be refactored to not add unnecessary DIV's)
    this.pinTxt = document.createElement("DIV");
    this.pinTxt.id = "decarta-textoverlay";
    this.pinTxt.innerHTML = this.icon.overlay.text;
    this.pinTxt.className = this.icon.overlay.className;
    this.pinTxt.style.position = "absolute";
    this.pinTxt.style.color = this.icon.overlay.color;
    this.pinTxt.style.fontSize = this.icon.overlay.size;
    this.pinTxt.style.fontFamily = this.icon.overlay.fontFamily;
    if (this.icon.overlay.text == "") {
        this.pinTxt.style.display = "none";
    }
    else {
        this.pinTxt.style.display = "block";
    }
    // Increase the zIndex at which the next pin will appear
    Pin.zIndexCounter++;
    this.pinTxt.style.zIndex = Pin.zIndexCounter;
    this.pinTxt.style.cursor = "pointer";
    deCarta.IdManager.setTag( this.pinTxt, "ignoreForMapEvents" );

    //TODO ###################################################################
    // TODO refactor with prototype to reduce closure
    // TODO Encase the constructor. Right now, a tiny piece of the constructor
    //   exists farther down in the function (search for PART OF CONSTRUCTOR)
    //   in order to deal with event handling during pin creation.




//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ END CONSTRUCTOR (except for the bit below)
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    /** @ignore */
    this.animateDrop=false;
    /** @ignore */
    this.dropSpeed=30;
    /**
     * Animation on the presentation of the pin on the map.
     * @param {string} type "DROP"
     * @param {string} speed "FAST" || "SLOW"
     */
    this.animate= function(type, speed, easing){
        if(type=="DROP"){
            this.animateDrop = true;            
            this.dropFunc = new deCarta.Easing(easing);
            if (typeof speed == 'number'){
                this.dropSpeed=20;
                this.dropDuration = speed;
            } else {
                if(speed == "FAST"){
                   this.dropSpeed=20;
                   this.dropDuration = 200;
                } else {
                   this.dropSpeed=35; 
                   this.dropDuration = 400;
                }
            }
        }
    }
    /** @ignore */
    this.animateDropPosition = 300;
    this.animateDropStartTime = null;
    /** @ignore */
    function animateDrop(){
       
       if (!self.animateDropStartTime) {                      
           self.animateDropStartTime = new Date().getTime();           
           self.dropStartY = parseFloat(self.pinImg.style.top);
       
       }
       var time = new Date().getTime() - self.animateDropStartTime;
       var pos = self.dropFunc(time, self.dropStartY , self.animateDropPosition, self.dropDuration);
       
       
       
       self.pinImg.style.top=(pos)+"px";
       self.pinTxt.style.top=(pos)+"px";

       if (time < self.dropDuration) {
           setTimeout(animateDrop, 0);
       } else {
           self.animateDrop = false;
           self.pinImg.style.top=(self.dropStartY + self.animateDropPosition)+"px";
           self.pinTxt.style.top=(self.dropStartY + self.animateDropPosition)+"px";
       }
    }

    /**
     * Retrieve the current CSS zIndex value for the Pin. Reset the zIndex
     * through the setZIndex method.
     * @returns {integer} The zIndex value of the pin instance.
     */
    this.getZIndex = function() {
        
        return (this.pinImg.style.zIndex);
    };
    
    /**
     * Set the CSS zIndex value for this Pin instance. Useful for effecting
     * the "move forward" or "move behind" view of a particular Pin.
     * @param {integer} zIndex required The new zIndex of the pin. Falsey or
     * NaN input will cause a zIndex reset to 0.
     */
    this.setZIndex = function( zIndex ) {
        
        var newZIndex = parseInt( zIndex, 10 );
        if ( !isNaN(newZIndex) ) {
            this.pinImg.style.zIndex = newZIndex;
            if ( this.pinTxt ) {
                this.pinTxt.style.zIndex = newZIndex + 1;
            }
        }
        else {
            this.pinImg.style.zIndex = 0;
            if ( this.pinTxt ) {
                this.pinTxt.style.zIndex = 1;
            }
        }
    };

    /**
     * Set a new identification for this Pin. Identifications do not have to
     * be unique among the currently defined set of Pins.
     * @param {String} id The new new id string.
     * @see Map#removePinsById
     */
    this.setId = function(id){
        
        this.id=id;
    };
    
    /**
     * Retrieve the identification string for this Pin, if there is one.
     * Identifications do not have to be unique among the currently defined
     * set of Pins.
     * @return {String} The associated string used to identify this pin, if
     * there is one.
     * @see Map#removePinsById
     */
    this.getId = function(){
        
        return this.id;
    };


    /**
     * A CSS cursor property setting to be used when mousing over this Pin. While
     * it is always best to consult current CSS documentation for valid values in
     * use with your targeted browsers, the following is a sample list of valid
     * values at the time of this writing:
     * <p></p>
     * <ul>
     * <li>"auto"</li>
     * <li>"crosshair"</li>
     * <li>"help"</li>
     * <li>"move"</li>
     * <li>"pointer"</li>
     * <li>"text"</li>
     * <li>"wait"</li>
     * </ul>
     * <p>The default value is "pointer".</p>
     * @param {String} cursor required Describes CSS cursor property value to
     * associate with this Pin.
     */
    this.setCursorStyle = function(cursor){
        
        this.pinImg.style.cursor=cursor;
        this.pinTxt.style.cursor=cursor;
    };
    /**
     * Retrieves the CSS cursor property value associated with this Pin.
     * @return {String} cursor The current CSS cursor property value associated
     * with this Pin.
     * @see Pin#setCursorStyle
     */
    this.getCursorStyle = function(){
        
        return this.pinImg.style.cursor;
    };

    /**
     * Change the Icon used to visualize the Pin on the Map.
     * @param {Icon} icon required The new Icon object to associate with this
     * Pin.
     * @see Icon
     */
    this.setIcon = function(icon){
        
        self.pinImg.src=icon.src;
		
        //move to new anchor
        if (self.icon.anchorY==icon.anchorY && self.icon.anchorX==icon.anchorX && icon._previousY && icon._previousX){
            self.pinImg.style.top=(parseInt(self.pinImg.style.top) + icon._previousY - icon.anchorY)+"px";
            self.pinImg.style.left=(parseInt(self.pinImg.style.left) + icon._previousX - icon.anchorX)+"px";
        }else{           
            self.pinImg.style.top=(parseInt(self.pinImg.style.top)+self.icon.anchorY-icon.anchorY)+"px";     
            self.pinImg.style.left=(parseInt(self.pinImg.style.left)+self.icon.anchorX-icon.anchorX)+"px";			
        }

        self.pinImg.style.width=icon.width+"px";
        self.pinImg.style.height=icon.height+"px";
			
        self.icon=icon;				
		
        if(icon.overlay.text!=""){
            self.pinTxt.style.display = "block";
            self.pinTxt.innerHTML=this.icon.overlay.text;
            self.pinTxt.style.position="absolute";
            if(icon.overlay.className)
                self.pinTxt.style.className = icon.overlay.className;
            if(icon.overlay.color)
                self.pinTxt.style.color=icon.overlay.color;
            if(icon.overlay.size)
                self.pinTxt.style.fontSize=icon.overlay.size;
            if(icon.overlay.fontFamily)
                self.pinTxt.style.fontFamily=icon.overlay.fontFamily;	
            self.pinTxt.style.left=(parseInt(self.pinImg.style.left)+parseInt(self.icon.overlay.anchorX))+"px";
            self.pinTxt.style.top=(parseInt(self.pinImg.style.top)+parseInt(self.icon.overlay.anchorY))+"px";
            //Pin.zIndexCounter++;
            //self.pinTxt.style.zIndex=Pin.zIndexCounter;
        } else {
            // remove old overlay
            self.pinTxt.innerHTML="";
            self.pinTxt.style.display = "none";
        }
        // sizingMethod='scale' is necessary
        if(Utilities.ie6 && this.pinImg.src.match(new RegExp("\\bpng\\b", "g"))){
            var src = this.pinImg.src;
            this.pinImg.src = Credentials.transparentGIF;
            this.pinImg.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + src + "',sizingMethod='scale')";
        } 
    }
	
    /**
     * returns instance of current icon associated with this Pin. NOTE: If you
     * change the Icon, you must re-set it by calling {@link Pin#setIcon} which
     * will commit the change to the DOM.
     * @return {Icon} The Icon object currently associated with this Pin.
     * @see Pin#setIcon
     */
    this.getIcon = function(){
        
        return self.icon;//(new Icon(self.pinImg.src,self.icon.anchorX,self.icon.anchorY));
    }
	
    /**
     * Resets the x anchor of the underlying Icon for this Pin.
     * @param {int} x required The new x pixel offset, from left edge, for the
     * underlying Icon.
     * @return {boolean} true if the x position was reset, false if not.
     * @see Icon
     */
    this.setX = function(x){
        
        var imgOffset = x-self.icon.anchorX;
        if ( self.pinImg.offsetLeft == imgOffset ) {
            // don't cause unnecessary redraws
            return false;
        }
        self.pinImg.style.left=imgOffset+"px";
        
        if(self.pinTxt)
            self.pinTxt.style.left=(imgOffset+self.icon.overlay.anchorX)+"px";

        return true;
    }
    /**
     * Resets the y anchor of the underlying Icon for this Pin.
     * @param {int} y required The new y pixel offset, from top edge, for the
     * underlying Icon.
     * @return {boolean} true if the y position was reset, false if not.
     * @see Icon
     */
    this.setY = function(y){
        
        
        if(self.animateDrop){
           self.pinImg.style.top=(y-self.icon.anchorY-self.animateDropPosition)+"px";
            if(self.pinTxt)
                self.pinTxt.style.top=(y-self.icon.anchorY+self.icon.overlay.anchorY-self.animateDropPosition)+"px";
        }else{
            // Note: we don't fix for animating pins
            var imgOffset = y-self.icon.anchorY;
            if ( self.pinImg.offsetTop == imgOffset ) {
                // don't cause unnecessary redraws
                return false;
            }
            self.pinImg.style.top=(imgOffset)+"px";
            if(self.pinTxt)
                self.pinTxt.style.top=(imgOffset+self.icon.overlay.anchorY)+"px";
        }    
        
        
         
        if(self.animateDrop){
            animateDrop();
        }

        // We moved
        return true;
    }

    /**
     * Retrieve the Position associated with this Pin.
     * @return {Position} position The latitude and longitude associated with
     * this Pin.
     * @see Position
     */
    this.getPosition = function(){
        
        return self.position;
    }
    /**
     * Dynamically move this Pin and reset its associated coordinate location. 
     * Movement of Pins does not require a Map refresh.
     * @param {Position} pos required The new location for the Pin.
     * @return {boolean} true if the pin position was changed, false if not.
     * @see Position
     */
    this.setPosition = function(pos){
        
        // Set the DOM location
        if ( self.map != null ) {
            var newPositionAsMapLayerPix = self.map.positionToMapLayerPixel(pos);
            var xmoved = self.setX( newPositionAsMapLayerPix.x );
            var ymoved = self.setY( newPositionAsMapLayerPix.y );
        }
        // Store the new location with the pin
        self.position = pos;
        return ((xmoved || ymoved) ? true : false);
    }

    /**
     * Change the message to be displayed by this Pin within an InfoWindow.
     * @param {String} message required The new text or html message to display.
     * @see InfoWindow
     * @see EventRegistry
     */
    this.setMessage = function(message){
        
        self.pinImg.msg = message;
        if ( self.map && self.pinImg && self.map.getInfoWindow() &&
             (self == self.map.getInfoWindow().associatedPin) ) {
            self.map.getInfoWindow().setContent( message );
        }
    };


    /**
     * Retrieve the message to display that is associated with this Pin. The
     * message is usually displayed within an InfoWindow object when the Pin is
     * interacted with on the Map. Note: To change the message, use the
     * {@link Pin#setMessage}.
     * @return {String} The currently message to display.
     * @see EventRegistry
     * @see Pin#setMessage
     */
    this.getMessage = function(){
        
        return self.pinImg.msg;
    }

    /**
     * Hide this Pin from view. This does not destroy a Pin or remove it from a
     * map, it merely renders the Pin itself invisible, and makes user
     * interaction with the Pin impossible.
     * @see Map#hidePins
     * @see Pin#show
     */
    this.hide = function() {
        
        // Change visibility state
        self.isVisible = false;
        self.pinImg.style.display = "none";
        self.pinTxt.style.display = "none";
    };
    /**
     * Makes a previously hidden Pin visible.
     * @see Pin#hide
     */
    this.show = function() {
        
        // Change visibility state
        self.isVisible = true;
        self.pinImg.style.display = "block";
        if (self.pinTxt.innerHTML != "") {
            self.pinTxt.style.display = "block";
        }
    };
    /**
     * Hides a pin temporarily during a zoom, but doesn't officially change
     * the Pin's visibility state.
     * @private
     */
    this.zoomHide = function() {
        
        // Keep the pin hidden if it was hidden by the developer...
        if ( self.isVisible ) {
            self.pinImg.style.display = "none";
            self.pinTxt.style.display = "none";
        }
    };
    /**
     * Shows a pin after a zoom, unless the pin was hidden by an official state
     * change via a call to hide.
     * @private
     */
    this.zoomShow = function() {
        
        // Keep the pin hidden if it was hidden by the developer...
        if ( self.isVisible ) {
            self.pinImg.style.display = "block";
            if (self.pinTxt.innerHTML != "") {
                self.pinTxt.style.display = "block";
            }
        }
    };
    /**
     * Forces the message associated with a Pin to be displayed within an
     * InfoWindow.
     * @see InfoWindow
     * @see Pin#getMessage
     * @see Pin#setMessage
     */
    this.showInfoWindow = function() {
        
        //var left=parseInt(self.pinImg.style.left);
        //var top=parseInt(self.pinImg.style.top);
        var topLeft=self.pinImg.offsetLeft+self.pinImg.offsetWidth/2;
        var topTop=self.pinImg.offsetTop;
        var bottomLeft=self.pinImg.offsetLeft+self.icon.anchorX;
        var bottomTop=topTop+self.pinImg.offsetHeight;
        self.map.getInfoWindow().setPosition( topLeft, topTop, bottomLeft, bottomTop);
        self.map.getInfoWindow().setContent( self.pinImg.msg );
        self.map.getInfoWindow().show(self);
    };
	
    /**
     * Hide any message currently displayed, and associated with this Pin, from
     * view. This does not destroy the Pin message or the InfoWindow object, it
     * merely renders the InfoWindow and message invisible.
     * @see InfoWindow
     * @see Pin#getMessage
     * @see Pin#setMessage
     */
    this.hideInfoWindow = function(){
        
        self.map.getInfoWindow().hide();
    }

	
    /**
     * @private
     */
    this.addEventListener = function(event, callBack){
        
        var already=false;	
        for(var i=0;i<_events.length;i++) {
            if(_events[i]==event){
                _events[event]=callBack;
                already=true;
                break;
            }
        }
        if(!already) {
            _events.push(event);
            _events[event]=callBack;
            // Set up the appropriate event
            if(event=="mousedown") {
                deCarta.Events.addEvent( self.pinImg, "mousedown", mousedown );
                deCarta.Events.addEvent( self.pinTxt, "mousedown", mousedown );
            }else if(event=="mouseup"){
                deCarta.Events.addEvent( self.pinImg, "mouseup", mouseup );
                deCarta.Events.addEvent( self.pinTxt, "mouseup", mouseup );
            }
            else if(event=="click" || event=="dblclick" || event=="rightclick") {
                deCarta.Events.addEvent( self.pinImg, "mousedown", mousedown );
                deCarta.Events.addEvent( self.pinImg, "mouseup", mouseup );
                deCarta.Events.addEvent( self.pinTxt, "mousedown", mousedown );
                deCarta.Events.addEvent( self.pinTxt, "mouseup", mouseup );
            } else if(event=="mouseover"){
                deCarta.Events.addEvent( self.pinImg, "mouseover", mouseover );
                deCarta.Events.addEvent( self.pinTxt, "mouseover", mouseover );
            } else if(event=="mouseout"){
                deCarta.Events.addEvent( self.pinImg, "mouseout", mouseout );
                deCarta.Events.addEvent( self.pinTxt, "mouseout", mouseout );
            }
        }
    } /* End addEventListener */

    /**
     * @private
     */
    this.clearInstanceListeners = function(){
        
        for(var i=0;i<_events.length;i++){
            _events[_events[i]]=null;
            _events[i]=null;
        }	
    }		
    /**
     * @private
     */
    this.clearListeners = function(event){
        
        for(var i=0;i<_events.length;i++)
             if(_events[i]==event){
                _events[_events[i]]=null;
                _events[i]=null;
            }
    }

//------------------------------------------------------------------------------
// Private Event Handlers
//------------------------------------------------------------------------------

    /**
     * Enable processing of clicks and double clicks with only the appropriate
     * click happening. This function begins the click process.
     * @inner
     */
    function mousedown(e){
        
        // Quick exit if events should be ignored
        
        e = e || window.event;
        
        if (!GLOBALS.ALLOWDOMEVENTS) {
            return true;
        }
        // Right clicks are handled separately and passed off, never being
        // handled here
        if(e.button == 2 || e.which == 3) {
            _doRightClick = true;
            return false;
        }
        // Fire registered events
        if( _events["mousedown"] ) {
            _events["mousedown"](self);
        }
        
        if(e.preventDefault){
            e.preventDefault();
        }else{
            e.returnValue=false;
        }
        return false;
    } 
    /**
     * Enable processing of clicks and double clicks with only the appropriate
     * click happening. This function passes the event to the correct handler.
     * @inner
     */
    function mouseup(e) {
        
        // Quick exit if events should be ignored
        if (!GLOBALS.ALLOWDOMEVENTS) {
            return true;
        }
        // Right click always takes priority
        if ( _doRightClick ) {
            // The event functions clean up any event state
            rightclick();
            return false;
        }
        // Fire registered events
        if( _events["mouseup"] ) {
            _events["mouseup"](self);
        }

        // We handle all clicks here because this seems to be the one
        // sure fire way across all browsers, using any sort of event attachment
        // to handle click events. For example, IE using attachEvent, when a
        // double click fires, a second mousedown event does not happen, but
        // a second mouseup event does. WTF?

        // If we don't have a mouse up clock, we assume a click event...
        if ( !_mouseUpClock ) {
            _mouseClickEventId = setTimeout( click, _mouseClickThreshold );
            // And we set-up a mouse clock which will be killed inside of the
            // the click event if it fires
            _mouseUpClock = new Date();
        }
        else {
            // Else, because the click event kills the mouseUpClock, we have
            // a double click
            clearTimeout( _mouseClickEventId );
            dblclick();
        }
        return false;
    }
    /**
     * The single click event handler.
     * @inner
     */
    function click() {
        
        
        // Clean off any old click events. This signals the event handlers
        // that the event has happened, and to not process a double click.
        resetClickProperties();
        // Handle event
        if( _events["click"] ) {
            _events["click"](self);
        }
    }
    /**
     * The single click event handler.
     * @inner
     */
    function dblclick() {
        
        
        // Clean off any old click events. This signals the event handlers
        // that the event has happened, and to not process a double click.
        resetClickProperties();
        if( _events["dblclick"] ) {
            _events["dblclick"](self);
        }
    }
    /**
     * The right click event handler.
     * @inner
     */
    function rightclick(){
        
        
        // Clean off any old click events. This signals the event handlers
        // that the event has happened, and to not process a double click.
        resetClickProperties();
        if(_events["rightclick"]) {
            _events["rightclick"](self);
        }
    }

    /**
     * Grab this pin and attach it to the mouse until further notice until
     * dropPin is called.
     * @see Pin#drop
     */
    this.pickup = function() {
        
        if( !_isDragging ) {
            // All we need to do is associate this pin with the mousemove event
            // on the window. When the mouse moves, the pin will stick to the mouse
            deCarta.Events.addEvent( window.document, "mousemove", pinDragging );
        }
    };

    /**
     * Drop this pin after the pin has been picked up.
     * @see Pin#pickup
     */
    this.drop = function() {
        
        //if( _isDragging ) {
            // Prevent multiple calls
            endPinDragging();
        //}
    };

    /**
     * Handles a draggable pin.
     * @param {Event object} e required The mousemove event object.
     * @inner
     */
    function pinDragging(e) {
        
        
        e=e || window.event;
        
        var mouseX = e.clientX;
        var mouseY = e.clientY;

        var img = self.pinImg;
        var imgTop = parseInt(img.style.top,10);
        var imgLeft = parseInt(img.style.left,10);
        var txt = self.pinTxt;
        var txtTop = parseInt(txt.style.top,10);
        var txtLeft = parseInt(txt.style.left,10);
        var map = self.map;

        var adjustmentX = 0;
        var adjustmentY = 0;
        var adjustedTop = 0;
        var adjustedLeft = 0;

        // Begin dragging
        if ( !_isDragging ) {
            _isDragging = true;
            _dragBeginningScreenPix = new PixelPoint( mouseX, mouseY );
            // Record starting positions
            _dragBeginningImgPix = new PixelPoint( imgLeft, imgTop );
            _dragBeginningTxtPix = new PixelPoint( txtLeft, txtTop );
        }

        // mouseclick relative to map viewport
        var mouseRelTop = mouseY - Utilities.getAbsoluteTop(map.mapDiv) + Utilities.getScrollTop();
        var mouseRelLeft = mouseX - Utilities.getAbsoluteLeft(map.mapDiv) + Utilities.getScrollLeft();

        // pin image center point relative to the map viewport
        //var imgRelTop = imgTop + parseInt(map.getTileDiv().style.top,10) + Utilities.getScrollTop();
        var imgRelTop = imgTop + parseInt(map.getTileDiv().style.top,10);
        var imgCenterY = imgRelTop + img.clientHeight/2;
        //var imgRelLeft = imgLeft + parseInt(map.getTileDiv().style.left,10) + Utilities.getScrollTop();
        var imgRelLeft = imgLeft + parseInt(map.getTileDiv().style.left,10);
        var imgCenterX = imgRelLeft + img.clientWidth/2;

        // Adjust the pin to make sure that it will lie underneath the mouse
        // during dragging... this will help in capturing the click event for dropping
        if ( imgCenterY != mouseRelTop ) {
            adjustmentY = mouseRelTop - imgCenterY;
        }
        adjustedTop = imgTop + adjustmentY;
        img.style.top = adjustedTop + "px";
        txt.style.top = (txtTop + adjustmentY) + "px";
        if ( imgCenterX != mouseRelLeft ) {
            adjustmentX = mouseRelLeft - imgCenterX;
        }
        adjustedLeft = imgLeft + adjustmentX;
        img.style.left = adjustedLeft  + "px";
        txt.style.left = (txtLeft + adjustmentX) + "px";
        
        if(e.preventDefault){
            e.preventDefault();
        }else{
            e.returnValue=false;
        }
        return false;
    }

    /**
     * Places a dragged pin back into the map and makes sure the position is
     * right.
     * @inner
     */
    function endPinDragging(e) {
        
        
        // Kill the pin drag event
        deCarta.Events.removeEvent( window.document, "mousemove", pinDragging );

        if( !_isDragging ) {
            return false;
        }
        
        // We could use the event, but we'll assume that whenever this is called,
        // we know how far the pin has been dragged.
        var changeX = parseInt(self.pinImg.style.left,10) - _dragBeginningImgPix.x;
        // We have to flip the sign of the Y values to equate to the change in lat
        var changeY = -(parseInt(self.pinImg.style.top,10)  - _dragBeginningImgPix.y);
        // We know the pixel change, now how many degrees per pixel here

        var scaleLevel =  self.map.getZoomController().getGXConvertedZoomLevel();
        var radsPerPixel =  Utilities.radsPerPixelAtZoom(self.map.getTileSize(), scaleLevel);

        // We can do this because the pin hasn't changed it's stored position during
        // our dragging
        var originalX = Utilities.lon2pix(self.position.lon, radsPerPixel);
        var originalY = Utilities.lat2pix(self.position.lat, radsPerPixel);
        // Offset the latitude and longitude
        var newLon = Utilities.pix2lon( (originalX+changeX), radsPerPixel );
        var newLat = Utilities.pix2lat( (originalY+changeY), radsPerPixel );

        var newPosition = new Position(newLat, newLon);

        // and reset the position
        self.setPosition(newPosition);

        // Resets all drag event properties and readies for the next drag.
        _isDragging     = false;
        _dragBeginningScreenPix = null;
        _dragBeginningImgPix = null;
        _dragBeginningTxtPix = null;

        // Kill other events
        return false;
    }

    /**
     * Perform registered mouseover events.
     * @inner
     */
    function mouseover(){
        
        // Quick exit if events should be ignored
        if (!GLOBALS.ALLOWDOMEVENTS) {
            return;
        }
        if(_events["mouseover"]) {
            _events["mouseover"](self);
        }
    }
    /**
     * Perform registered mouseout events.
     * @inner
     */
    function mouseout(){
        
        // Quick exit if events should be ignored
        if (!GLOBALS.ALLOWDOMEVENTS) {
            return;
        }
        if(_events["mouseout"]) {
            _events["mouseout"](self);
        }
    }

    /**
     * Resets all click event properties and readies for the next click event.
     * @inner
     */
    function resetClickProperties() {
        
        _mouseUpClock   = null;
        _mouseClickEventId   = null;
        _doRightClick   = false;
    }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
    // PART OF CONSTRUCTOR
    if(bubbleEventType && (bubbleEventType == "onmouseover" || bubbleEventType == "mouseover")){
        self.addEventListener("mouseover", self.showInfoWindow);
        self.addEventListener("mouseout", self.hideInfoWindow);
    } else if(bubbleEventType && (bubbleEventType == "onclick" || bubbleEventType == "click")){
        self.addEventListener("click", self.showInfoWindow);	
    }
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

    /**
     * Clean up and destroy this pin.
     * We only do the heavier cleanup on IE, the rest of the browsers seem
     * to work just fine.
     */
    this.destroy = function() {
        
        // Remove all items from DOM
        if (self && self.map) {
            // But only if they are attached to the map
            if ( self.pinImg ) {
                deCarta.Events.removeEvent( self.pinImg, "mousedown", mousedown );
                deCarta.Events.removeEvent( self.pinImg, "mouseup", mouseup );
                deCarta.Events.removeEvent( self.pinImg, "mouseover", mouseover );
                deCarta.Events.removeEvent( self.pinImg, "mouseout", mouseout );
                if ( Utilities.ie ) {
                    Utilities.purge(self.pinImg);
                }
                self.map.getTileDiv().removeChild( self.pinImg );
                self.pinImg = null;
            }
            // But only if they are attached to the map
            if ( self.pinTxt ) {
                deCarta.Events.removeEvent( self.pinTxt, "mousedown", mousedown );
                deCarta.Events.removeEvent( self.pinTxt, "mouseup", mouseup );
                deCarta.Events.removeEvent( self.pinTxt, "mouseover", mouseover );
                deCarta.Events.removeEvent( self.pinTxt, "mouseout", mouseout );
                
                if ( Utilities.ie ) {
                    Utilities.purge(self.pinTxt);
                }
                self.map.getTileDiv().removeChild( self.pinTxt );
                self.pinTxt = null;
            }
        }
        self.clearInstanceListeners();
        self=null;
        // Purge our items
        // @todo This should be done after a reliable IE check
    };

    /**
     * Retrieve the Position associated with the Pin.
     * @return {String} The Position of Pin as a string.
     * @see Position#toString
     */
    this.toString = function(){

        if (!self) self = this;
        var r = self.position.toString();

        return r;
    }
	
    /** 
     * Tests whether this Pin is equal to the Pin passed in as an argument.
     * Checks if the Position and associated Icon are the same.
     * @param {Pin} pin The Pin to test for equality.
     * @return {Boolean} 'true' if equal, 'false' if not equal.
     * @see Position
     * @see Icon
     */
    this.equals = function(pin){
        
        if (pin && pin.toString()==this.toString() && pin.pinImg==this.pinImg)
            return true;
        else
            return false;
    }

    /**
     * Return the minimum BoundingBox required to see the Icon associated
     * with this Pin. Offsets associated with the Icon are taken into account.
     * @param {int} scale required Scale at which to approximate the the icon pixel
     * x/y dimensions to lat/lon offsets.
     * @return {BoundingBox} The BoundingBox required to view the pin at this
     * particular zoom level.
     * @see Icon
     */
    this.getViewableBoundingBox = function( scale ) {
        
        
        var posPixLat = Utilities.lat2pix( self.position.lat, scale );
        var posPixLon = Utilities.lon2pix( self.position.lon, scale );
        
        // Idea behind math:
        // The Pin position acts as the anchor to the upper left pixel of the
        // associated icon.
        // Associated Icon has a fixed height and width that represents the bounding
        // box, we just need to position this bounding box on the map.
        var maxPixLat = posPixLat + self.icon.anchorY;
        var maxPixLon = posPixLon + parseInt(self.pinImg.style.width) - self.icon.anchorX;
        var minPixLat = posPixLat - parseInt(self.pinImg.style.height) + self.icon.anchorY;
        var minPixLon = posPixLon - self.icon.anchorX;
        
        // unconvert to degrees...
        var maxDegLat = Utilities.pix2lat( maxPixLat, scale );
        var maxDegLon = Utilities.pix2lon( maxPixLon, scale );
        var minDegLat = Utilities.pix2lat( minPixLat, scale );
        var minDegLon = Utilities.pix2lon( minPixLon, scale );
        
        // ...to positions...
        var maxPosition = new Position( maxDegLat, maxDegLon );
        var minPosition = new Position( minDegLat, minDegLon );
        
        // ... to bounding box...
        var bbox = new BoundingBox( minPosition, maxPosition );
        return bbox;
    }

} /* end of Pin class */

/** 
 * Counter to help control placement of pins on the map.
 * @private 
 */
Pin.zIndexCounter=100;


 /** 
  * @fileoverview PixelPoint representing pixel x/y point
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */

/**
 * @class PixelPoint exists to conventiently pass a pair of screen coordinates
 * between methods and classes. While screen coordinates usually count from
 * the upper left corner, this class poses no restrictions on your choice
 * of origin. Coordinates are stored in floating point with methods used to
 * round the output.
 * @description Construct a new PixelPoint object.
 * @param {number} x required The horizontal pixel coordinate.
 * @param {number} y required The vertical pixel coordinate.
 * @throws {Exception} If x and y are not numbers, or cannot be
 * converted to valid floats.
 * @constructor
 * @private
 */
function PixelPoint( x, y ) {
    
    try {
        /**
         * The x pixel coordinate.
         * @type int
         */
        this.x = parseFloat( x );
        /**
         * The y pixel coordinate.
         * @type int
         */
        this.y = parseFloat( y );
        if ( isNaN(this.x) || isNaN(this.y) ) {
            // This will get caught below
            throw new Exception("");
        }
    } catch (e) {
        throw new Exception("PixelPoint: bad constructor values for x: " + x + " and y: " + y );
    }
}

/**
 * Return the current value for x.
 * @returns {number} Current value for x.
 */
PixelPoint.prototype.getX = function() {
    
    return this.x;
};

/**
 * Return the current value for x as an integer.
 * @returns {number} Current value of x rounded.
 */
PixelPoint.prototype.roundX = function() {
    
    return Math.round(this.x);
};

/**
 * Set a new value for x. Provides a bit of protection compared to directly
 * setting the x property.
 * @param {number} x required New value to set for the x pixel coordinate.
 * @throws {Exception} If x is not a number, or cannot be
 * converted to a float.
 */
PixelPoint.prototype.setX = function( x ) {
    
    this.x = parseFloat( x );
    if ( isNaN(this.x) ) {
        throw new Exception("PixelPoint: setX bad argument x: " + x );
    }
};

/**
 * Return the current value for y.
 * @returns {number} Current value for y.
 */
PixelPoint.prototype.getY = function() {
    
    return this.y;
};

/**
 * Return the current value for y as an integer.
 * @returns {number} Current value of y rounded.
 */
PixelPoint.prototype.roundY = function() {
    
    return Math.round(this.y);
};

/**
 * Set a new value for y. Provides a bit of protection compared to directly
 * setting the y property.
 * @param {int} y required New value to set for the y pixel coordinate.
 * @throws {Exception} If y is not a number, or cannot be
 * converted to a number.
 */
PixelPoint.prototype.setY = function( y ) {
    
    this.y = parseFloat( y );
    if ( isNaN(this.y) ) {
        throw new Exception("PixelPoint: setY bad argument y: " + y );
    }
};

/**
 * Return the pixel coordinate as space delimited string.
 * @returns {string} x followed by y.
 */
PixelPoint.prototype.toString = function() {
    return this.x + " " + this.y;
};

/**
 * Check for equality between two pixel points. Comparison performed against
 * toString() results.
 * @returns {boolean} true if equal, false if not.
 */
PixelPoint.prototype.equals = function(pd) {
    
    if ( pd && pd.toString() == this.toString() )
        return true;
    else
        return false;
};

 /** 
  * @fileoverview Position representing latitude longitude point
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
  

/**
 * @class When working with any map, all data is associated by some sort of
 * coordinate system. Human beings might understand where "123 Main St.,
 * Somewhere, In the World" is located, but software systems need to think about
 * this as a specific point location. All deCata software deals with specific
 * point locations as a set of decimal latitude and longitude coordinates. The
 * deCarta JavaScript API stores these coordinates within instances of the
 * Position class. The Position class is used throughout the JavaScript API and
 * therefore is kept simple.
 * @description Construct a new Position object.
 * @param {String} latitude required Represents the decimal value of the
 * latitude. Negative values for the southern hemisphere, positive values for the
 * northern hemisphere.
 * Convenience constructor allows you to
 * use one string param (as one string '37.794341 -122.391816') instead of two.
 * @param {String} longitude required Represents the decimal value of the
 * longitude. Negative values for the western hemisphere, positive values for
 * the eastern hemisphere.
 * @throws {Exception} If the latitude or longitude values are incorrect, an
 * "error initializing..." exception will be thrown.
 * @constructor
 */
function Position(latitude, longitude){
    
    //this.altitude=altitude || 0;

    /**
       The decimal latitude value for this Position. Negative values for
       the southern hemisphere, positive values for the northern 
       hemisphere.
       @type Float
     */
    this.lat = 0;
    /**
       The decimal longitude value for this Position. Negative values 
       for the western hemisphere, positive values for the eastern 
       hemisphere.
       @type Float
     */
    this.lon = 0;

    // Convenience constructor validity checking
    if ( arguments.length == 1 ) {
        var stringSplit = latitude.split(" ");
        if(stringSplit.length!=2){
            throw new Exception("error initializing Position object");
        }
        try{
            this.lat=parseFloat(stringSplit[0]);  
            this.lon=parseFloat(stringSplit[1]);
            if( isNaN(this.lat) || isNaN(this.lon) ) {
                // This will get rethrown...
                throw new Exception();
            }
        }catch(e){
            throw new Exception("error initializing Position object");
        }
    } 
    else if ( arguments.length == 2 ) {
        try {
            this.lat=parseFloat(latitude);  
            this.lon=parseFloat(longitude);
            if( isNaN(this.lat) || isNaN(this.lon) ) {
                // This will get rethrown...
                throw new Exception();
            }
        } catch(e) {
            throw new Exception("error initializing Position object");
        }
    } 
    else {
        throw new Exception("error initializing Position object");
    }
    
    // check bounds
    // We disallow vertical rotation of the earth, so constrain lat to + or - 90.
    if ( this.lat > 90 ) {
        this.lat=89.5;
    }
    if ( this.lat < -90 ) {
        this.lat=-89.5;
    }
    // We allow continuous horizontal rotation of the earth.
    // only correct if lon is > 180 or < -180
    if ( this.lon > 180 || this.lon < -180 ){
        var newLon = this.lon % 360;
        if ( newLon <= -180 ) {
            newLon = (360+newLon);
        }
        else if ( newLon >= 180) {
            newLon = -(360-newLon);
        }
        this.lon = newLon;
    }

    /**
     *This field contains application specific property. In Geofencing project, violationCheckDateTime
     *property will be stored in this field. In Dispatching project, time property will be stored here.
     */
    this.customProperties={};
} /* End Position constructor */


/**
 * Return a new object clone of this position.
 * @return {Position} A new Position object.
 */
Position.prototype.clone = function(){
    
    return new Position(this.toString());
};



/**
 * Retrieve the latitude value. Note: To set a new value for this Position,
 * see {@link Position#setLat}.
 * @return {float} The decimal latitude value.
 */
Position.prototype.getLat = function(){
    
    return this.lat;
};


/**
 * Retrieve the longitude value. Note: To set a new value for this Position,
 * see {@link Position#setLon}.
 * @return {float} The decimal longitude value.
 */
Position.prototype.getLon = function(){
    
    return this.lon;
};



/**
 * Set a new, decimal latitude value.
 * @param {float} lt required A new decimal latitude value. Negative values
 * for the southern hemisphere, positive values for the northern hemisphere.
 */
Position.prototype.setLat = function(lt){
    
    // TODO: add error checking
    this.lat=lt;
};


/**
 * Set a new, decimal longitude value.
 * @param {float} ln required A new decimal longitude value. Negative values
 * for the western hemisphere, positive values for the eastern hemisphere.
 */
Position.prototype.setLon = function(ln){
    
    // TODO: add error checking
    this.lon=ln;
};



/**
 * Concatenate the latitude and longitude values, in that order, into a space
 * delimited string.
 * @returns {String} A space delimited string representing the Position.
 */
Position.prototype.getLatLon = function(){
    
    return this.lat+" "+this.lon;
};



/**
 * Concatenate the latitude and longitude values, in that order, into a comma
 * delimited string.
 * @returns {String} A comma delimited string representing the Position.
 */
Position.prototype.getLatCommaLon = function(){
    
    return this.lat+", "+this.lon;
};



/**
 * Compares this Position with the position passed in for equality. Tests to
 * see if the latitude and longitude fields of the two objects are equal.
 * @param {Position} position required The Position object to be compared
 * with this.
 * @return {Boolean} boolean 'true' if the two positions are equal, 'false' if
 * they are not.
 */
Position.prototype.equals = function(position){
    
   if (position && position.getLatLon()==this.getLatLon())
       return true;
   else
       return false;
};



/**
 * Concatenate the latitude and longitude values, in that order, into a space
 * delimited string.
 * @returns {String} A space delimited string representing the Position.
 */
Position.prototype.toString = function(){
    return this.lat.toFixed(14)+" "+this.lon.toFixed(14);
};


/**
 * @class
 * PositionAnimator allows you to create a position based animation.
 * Set the start and end positions, and set a callback function. The callback
 * will be invoked on every step of the animation and passed the interpolated
 * position.
 * @param {Map} map the map where the animation will take place
 * @param {Object} opts
 * Object containing the following named arguments:
 * <ul>
 * <li>start: starting position</li>
 * <li>end: ending position</li>
 * <li>duration: duration of the animation (in ms, default: 300)</li>
 * <li>onStep: callback invoked on every animation step</li>
 * <li>onEnd: callback invoked when the end position is reached. </li>
 * </ul>
 * @contructor
 *
 */
deCarta.PositionAnimator = function(map, opts){
    if (map && opts)
        this.animate(map, opts);

}

deCarta.PositionAnimator.prototype = {

    animate: function(map, opts){

        this.map = map;


        var defaults = {
            start: null,
            end: null,
            duration: 300,            
            onStep: null,
            onEnd: null
        }

        if (!opts.start || !opts.end || !opts.onStep || !map)
            throw('You need to specify a start point, and end point and a callback for a position animation');

        opts = Utilities.extend(defaults,opts);

        this.start = opts.start;
        this.end = opts.end;
        this.duration = opts.duration;
        this.onStep = opts.onStep;
        this.onEnd = opts.onEnd;

        this.endTime = new Date().getTime() + this.duration;
        this.step();

    },

    step: function(){
        var completion = 1 - ((this.endTime - new Date().getTime()) / this.duration);
        if (completion >= 0.99) {
            //position on end
            if (typeof this.onEnd === 'function') this.onEnd(this.end);
        } else {
            var pxStart = this.posToPix(this.start);

            var pxEnd = this.posToPix(this.end);
            var dX = pxEnd.x - pxStart.x;
            var dY = pxEnd.y - pxStart.y;

            var stepX = dX * completion;
            var stepY = dY * completion;


            var newPos = this.pixToPos({x: pxStart.x + stepX, y : pxStart.y + stepY});

            if (typeof this.onStep === 'function') this.onStep(newPos);

            setTimeout(this.step.scope(this), 20);
        }
    },

    posToPix: function(pos){
        var scaleLevel = this.map.getZoomController().getGXConvertedZoomLevel();
        var scale = Utilities.radsPerPixelAtZoom(this.map.getTileSize(), scaleLevel);

        return {x: Utilities.lon2pix(pos.lon, scale) , y: Utilities.lat2pix(pos.lat, scale)}
    },

    pixToPos: function(pixPos){
        var scaleLevel = this.map.getZoomController().getGXConvertedZoomLevel();
        var scale = Utilities.radsPerPixelAtZoom(this.map.getTileSize(), scaleLevel);

        return new Position(Utilities.pix2lat(pixPos.y,scale), Utilities.pix2lon(pixPos.x,scale));
    }


}
/** 
 * @fileoverview Radius representing distance and unit of measure {UOM}
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class A class, for convenience, to define and hold a Radius. An instance of 
 * a Radius is simply defined as a distance and a unit of measure, or 
 * {@link UOM}. Radius objects are always used with instances of other classes, 
 * an their purpose is defined by that class. As traditionally defined, a 
 * radius is 1/2 the distance of the diameter of a circle.
 * @description Construct a new Radius object.
 * @param {float} distance required The defined distance.
 * @param {UOM} uom optional Defines the units of measure for the distance of 
 * the Radius. The default unit is kilometers.
 * @see UOM
 * @constructor
 */
function Radius(distance, uom){
    
    /** 
     * The defined distance.
     * @type float 
     */
    this.distance = distance;
    /** 
     * Defines the units of measure for the distance field. Default unit is
     * kilometers.
     * @type UOM 
     */
    this.uom = uom || new UOM("KM");
    // below we define a uomdds which is a 
    // different uom that DDS uses in Shape drawing
    var tmp;
    if(uom=="KM")
        tmp="K";
    else if(uom=="M")
        tmp="M";
    else if(uom=="MI")
        tmp="R";
    else if(uom=="FT")
        tmp="F";
    /** @private */
    this.uomdds = tmp;
    /**
     * concatenates the distance and uom fields, in that order, and returns 
     * the string.
     * @returns {String} The Radius object as a single, space-delimited, 
     * unpunctuated, string.
     */
    this.toString = function(){
        return this.distance+" "+this.uom;
    };
    /**
     * Converts the value of the radius into approximate decimal degrees.
     * @return {float} number of degrees
     */
    this.getDegrees= function(){
        
        if(this.uom=="KM"){
            return this.distance/111.111;
        }else if(this.uom=="M"){
            return (this.distance/1000)/111.111;
        }else if(this.uom=="MI"){
            return (this.distance*1.609)/111.111;
        }else if(this.uom=="FT"){
            return ((this.distance/3.28)/1000)/111.111;
        }
    }
    
    this.getMiles = function(){
        switch (this.uom.value){
            case 'KM':
                return this.distance * 0.621371192;
            break;
            case 'M':
                return (this.distance / 1000) * 0.621371192;
            break;
            case 'MI':
                return this.distance;
            break;
            case 'FT':
                return this.distance * 0.000189393939;
            break;
            default:
                deCarta.Mobile.Exception.raise('Unknown UOM : ' + this.uom);
            break;
        }
    }
    
    this.getKm = function(){
        switch (this.uom.value){
            case 'KM':
                return this.distance;
            break;
            case 'M':
                return (this.distance / 1000);
            break;
            case 'MI':
                return this.distance * 1.609344;
            break;
            case 'FT':
                return this.distance * 0.0003048;
            break;
            default:
                deCarta.Mobile.Exception.raise('Unknown UOM : ' + this.uom);
            break;
        }
    }
}

/**
 * @fileoverview Route
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class The Route class is used to encapsulate all information needed to 
 * describe a route calculated by the DDS Web Services. The Route class is 
 * generated by the deCarta JavaScript API and returned to the application; 
 * it should not be generated by the application utilizing the deCarta 
 * JavaScript API.
 * @description Construct a new Route object.
 * @see RouteInstruction
 * @see RoutePreference
 * @see RouteQuery
 * @constructor
 */
function Route() {
    
    
    /**
     * An array that holds Route objects for any alternate routes returned.
     * @type Array
     * @default []
     */
    this.alternates=[]
    
    /** 
     * A summary of the estimated travel time of the entire route. Example, 
     * "Total Time: 2 minutes 31 seconds"
     * @type String
     * @default ""
     */
    this.TotalTime="";
    /** 
     * Total Time as an unformatted object for internationalization
     * {days:d,hours:h,minutes:m,seconds:s}
     * @type Object
     * @default ""
     */
    this.TotalTimeObject={};
    /**
     * The total surface distance traveled along the entire route. Units of 
     * measure are presumed understood.
     * @type String
     * @default ""
     */
    this.TotalDistance="";
    /** 
     * A comma delimited string used to identify the order in which the 
     * waypoints are visited in an optimized route. When a multipoint route is 
     * optimized the order of the waypoints can be different than the way you 
     * entered them. The waypoints are referred in zero-based array order 
     * (e.g. '0' is actually the first waypoint). Example, "1,0" means the 
     * second waypoint was visited first, than the first waypoint. Note: the 
     * origin and destination are not considered waypoints, and are not 
     * referred to by this field. Only the points between the origin and 
     * destination count as waypoints.
     * @type String
     * @default ""
     */
    this.viaPointSequence="";
    /** 
     * Array of RouteInstruction instances. Each RouteInstruction describes 
     * one specific maneuver along the route.
     * @type Array
     * @default [] 
     */
    this.RouteInstructions=[];
    /** 
     * Array of Positions that fully describe the geometry of the route. 
     * Note: geometry is only returned when the route request is made through 
     * a {@link RouteQuery} request. Long routes can produces tens of thousands
     * of {@link Position}.
     * @type Array
     * @default [] 
     */
    this.RouteGeometry=[];
    /**
     * The routeID for this route, if the routeID was requested.
     * If no routeID is available, or was not requested, this property will
     * be an empty string.
     * A routeID is the minimal amount of information needed to reconstruct an 
     * exact copy of a previously calculated route with a fraction of the 
     * required server resources.
     * @type String
     * @default ""
     */
    this.routeID = "";
    /**
     * A bounding box that contains this route. The bounding box can be used
     * in conjunction with the zoom controller of a map to determine the correct 
     * zoom level at which to display this route on a map.
     * @type BoundingBox
     * @default null
     */
    this.boundingBox = null;
    /**
     * The approximate center position of this route. This is calculated
     * from the containing bounding box, and as such the center point might
     * not actually exist on the route. Provided as a convenience to aid in
     * centering a map over a route.
     * @type Position
     * @default null
     */
    this.centerPosition = null;
    /**
     * The units of measure used for all distances (TotalDistance, route
     * instruction distance, alternate route distnaces) associated with this
     * Route object.
     * @type UOM
     * @default null
     */
    this.uom = null;


    this.id=Math.floor(Math.random()*10000000);
    this.title="";
    this.description="";

    /**
     *Store application specific properties. For RouteCompliance, this property will store buffer,
     *properties and metaInfo. For Dispatching project, this field will store eta.
     */
    this.customProperties={};
}


function ManeuverMap(){
    /**
     * description for the ManeuverMap
     * e.g. "route maneuver 1"
     * @type String
     */
    this.desc;
    /**
     * URL for the ManeuverMap
     * @type String
     */
    this.URL;
    /**
     * height of ManeuverMap
     * @type number
     */
    this.height;
    /**
     * width of ManeuverMap
     * @type number
     */
    this.width;
    /**
     * format of ManeuverMap
     * GIF, PNG
     * @type String
     */
    this.format;
    /**
     * BBox of ManeuverMap
     * @type BoundingBox
     */
    this.boundingBox;
}


/**
 * @class {@link Route} Descriptions are made up of discrete maneuvers. Each 
 * RouteInstruction contains instructions understandable by human beings, 
 * as well as information that is useful both to the human user and the mapping
 * application. The results of a {@link RouteQuery} will usually contain 1 to
 * many different RouteInstruction objects; the consumer of the JSAPI should
 * never need to construct their own RouteInstruction objects.
 * @description Construct a new RouteInstruction object.
 * @see Route
 * @see RoutePreference
 * @constructor
 */
function RouteInstruction(){
    

   /**
    * if the route preference was configured with maneuverMaps=true
    * then each instruction will have a oriented maneuver map url associated
    * with it.
     * @type ManeuverMap
     * @default undefined
    */
    this.maneuverMap=undefined;

    /** 
     * A human readable description of this route maneuver. Example, "Turn right
     * on Main Street." The instructions will almost always contain a relative 
     * directional action (like "Turn right...") followed by the information 
     * defining the destination (like "...on Main Street").
     * @type String 
     * @default ""
     */
    this.Instruction="";
    /** 
     * The surface distance covered in this route maneuver. The distance is a 
     * string representing a floating point number, the units of measure are 
     * assumed to be known. Example, "3.3"
     * @type String 
     * @default ""
     */
    this.distance="";
    /** 
     * The time estimated to cover this route maneuver, written as a fully 
     * described string. Example, "2 minutes 31 seconds"
     * @type String 
     * @default ""
     */
    this.duration="";
    /** 
     * The latitude and longitude coordinate at which the maneuver happens.
     * @type Position
     * @default null
     */
    this.position = null;
    /** 
     * Which waypoint this maneuver is associated with in an optimized route. 
     * When a multipoint route is optimized the order of the waypoints can be 
     * different than the way you entered them. The waypoints are referred in 
     * zero-based array order (e.g. '0' is actually the first waypoint). 
     * Example, "1" means that this maneuver is associated with the second 
     * waypoint. Note: the origin and destination are not considered waypoints,
     * and are not referred to by this field. Only the waypoints between the 
     * origin and destination count as waypoints.
     * @type String
     * @default null
     */
    this.tour="";
}

/**
 * @fileoverview RoutePreference
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class The RoutePreference holds a set of rules that define how a route
 * should be calculated. There are set type of routes, and each type of route
 * follows a specific set of rules. For example, a Pedestrian style route will
 * not traverse limited access roads (e.g. Freeways), but can go down the wrong
 * direction of a one-way street that is not prohibited to pedestrian traffic.
 * Providing users an opportunity to define their own routing style is important
 * for generating a route that is important to their needs.
 * <p>The various different routing styles are summarized below.</p>
 * <ul>
 * <li>"AvoidFreeways" = Return a vehicular route that avoids limited access
 * roads (e.g. freeways) as much as possible.</li>
 * <li>"Easy" = Return a vehicular route that attempts to make as few turns,
 * balancing this constraint with the shortest travel time.</li>
 * <li>"Fastest" = Return a vehicular route with the smallest, calculated
 * travel time. This is the standard, and default routing style.</li>
 * <li>"MoreFreeways" = Return a vehicular route that will attempt to use as
 * many limited access roads (e.g. freeways) as possible.</li>
 * <li>"NoFreeways" = Return a vehicular route that avoids limited access
 * roads (e.g. freeways) entirely. This route will take only surface street
 * and arterial roads to the destination.</li>
 * <li>"Pedestrian" = Return a route fit for Pedestrian traffic. Routes will
 * avoid limited access roads, ignore vehicular signage restrictions, obey
 * impassible physical restrictions (like grade separations), take the most
 * direct path possible, and utilize pedestrian only foot-traffic paths.</li>
 * <li>"Shortest" = Return a vehicular route with the shortest total distance
 * traveled.</li>
 * </ul>
 * When a route has more than than three total points (ie more than an origin,
 * one mid-point, and a destination), the route can be optimized. The waypoints,
 * or mid-points between the origin and destination, are re-calculated for
 * optimal travel. The new optimized route follows the rules prescribed by the
 * routing style. For example, a route prescribed to "AvoidFreeways" will still
 * avoid freeways whether or not it is being optimized.
 * @description Construct a new RoutePreference object.
 * @param {String} routePreference required The style of route to calculate.
 * Valid settings are, "Fastest", "Shortest", "Pedestrian", "AvoidFreeways",
 * "NoFreeways", "MoreFreeways", or "Easy".
 * @param {UOM} uom required Defines the units of measure in which the distances
 * along a route are returned.
 * @param {String} routeQueryType optional Tells the DDS Web Services which
 * basic routing style to use. Valid settings are "RMAN" or (default) "RTXT".
 * It is recommended to not change this setting unless you have been instructed
 * to do so.
 * @see RouteQuery
 * @see UOM
 * @constructor
 */
function RoutePreference( routePreference, uom, routeQueryType ) {
    


    /**
    * maneuverMaps is a flag to trigger each RouteInstruction to include
    * a URL to a small 200x200 image representing the maneuver in a top up
    * orientation
    * @type String URL
    * @default false
    */
    this.maneuverMaps=false;
    /**
    * configures the height and width of the maneuver maps
    * @type Object
    * @default {height:200,width:200}
    */
    this.maneuverMapConfig={
        format:"GIF",
        orientation:"north-up",
        height:200,
        width:200
    };
    /**
     * The style of route to calculate. Valid settings are, "Fastest",
     * "Shortest", "Pedestrian", "AvoidFreeways", "NoFreeways", "IgnorePipes",
     * "MoreFreeways", or "Easy".
     * @type String
     */
    this.routePreference = routePreference  || "Fastest";

    /**
     * DDS RouteControl allow for granual tuning of the DDS routing engine.
     * To use this control you must be familiar with DDSQL.  Please contact
     * our support team for deeper insights.
     * @type String
     */
    this.routeControl;
    /**
     * The type of vehicle type to use in calculating the route.
     * Valid values are  "PassengerCar", "4WD", "HOV", "Emergency", "Taxi",
     * "PublicBus", "DeliveryTruck", "TransportTruck", "Motorcycle" and
     * "Pedestrian"
     */
    this.vehicleType = null;
    /**
     * Defines a list of valid vehicle types.
     * Keys are valid values in XML requests, values are descriptions. 
     **/
    this.validVehicleTypes = {
        "PassengerCar": "Regular passenger cars",
        "4WD": "Vehicles with four wheel drive",
        "HOV": "High Occupancy Vehicles",
        "Emergency": "Emergency Vehicles, Ambulance",
        "Taxi": "Taxis",
        "PublicBus": "Public buses, ex: city bus",
        "DeliveryTruck": "Delivery Trucks",
        "TransportTruck": "Transport Trucks",
        "Motorcycle": "Motorcycles",
        "Pedestrian": "Pedestrians"
    };
    /**
     * Defines the units of measure in which the distances along a route are
     * returned.
     * @type UOM
     */
    this.uom = uom || new UOM("KM");
    /**
     * Tells the DDS Web Services which basic routing style to use. Valid
     * settings are "RMAN" or (default) "RTXT". It is recommended to not
     * change this setting unless you have been instructed to do so.
     * @type String
     * @default RTXT
     */
    this.routeQueryType = routeQueryType || "RTXT";
    /**
     * Optional parameter override default maneuver rules file used on server.
     * @private
     * @type String
     * @default null
     */
    this.rules = null;
    /**
     * Defines whether the waypoints between the origin and destination should
     * be traversed in an optimal order. 'true' means optimize the order,
     * 'false' means traverse the path through the waypoints in the original
     * order described.
     * @type boolean
     * @default false
     */
    this.optimized = false;
    /**
     * expectedStartTime is for use with DDS predictive traffic.
     * @type string}
     */
    this.expectedStartTime = null;
    /**
     * The number of alternate routes aside from the primary route.
     * @type number
     */
    this.alternateRoutes = 0;
    /**
     * Array of areas to avoid. This list provides additional control
     * above and beyond the chosen route style.
     * @type Array
     * @default []
     * @see RoutePreference#addAvoidArea
     */
    this.avoidAreas = [];
    /**
     * Array of feature types to avoid. This list provides additional control
     * above and beyond the chosen route style.
     * Recommend filling this array via the {@link RoutePreference#setAvoidFeature}
     * to prevent spelling or case errors.
     * @type Array
     * @default []
     * @see RoutePreference#setAvoidFeature
     */
    this.avoidList = [];
    /**
     * Controls the raw number of positions returned from a routing request.
     * Routes, especially medium size to large routes, can potentially return
     * more positions than can be shown at the resolution of the map. A
     * generalization factor can be added to this route. Think of the
     * generalization as a resolution contol: points that can't be separately
     * shown will be dropped out of the returned RouteGeometry.
     * The generalization factor is the meters per pixel along the horizontal.
     * We recommend using the accompanying setGeneralizationFactor to generate
     * the correct resolution.
     * @type float
     * @default 0
     */
    this.generalizationFactor = 0;
    /**
     * Required to be used in conjunction with the generalizationFactor to
     * inform the backend DDS Web Services wherein the generalization will
     * occur. To make sure the entire route is retrieved, set this to the
     * bounding box described by the way points.
     * @type BoundingBox
     * @default null
     */
    this.generalizationBBox = null;
    /**
     * Configuration object for Logistics style routing; ONLY for use with a
     * deCarta Logistics platform, will break all other platforms!
     * @type Object
     * @default null
     */
    //this.logisticsPreference = null;
    /**
     * Choice of returning the route geometry. True requests the route geometry
     * in the results, false prevents the route geometry from being returned.
     * @type boolean
     * @default true
     */
    this.returnRouteGeometry = true;
    /**
     * return a routeId
     */
    this.provideRouteHandle = false;
    /**
     * Choice of returning the route instructions. True requests the route
     * instructions in the results, false prevents them from being sent back.
     * @type boolean
     * @default true
     */
    this.returnRouteInstructions = true;

    /**
     * If set to true, the route will use exclusionzone stored on server side, and the route will avoid the
     * exclusion zones.
     * @type boolean
     * @default false;
     */
    this.useExclusionZone = false;
} // END RoutePreference() constructor


/**
 * Set whether the waypoints between the origin and destination should be
 * traversed in an optimal order. 'true' means optimize the order, 'false'
 * means traverse the path through the waypoints in the original order
 * described.
 * @param {boolean} optimized required 'true' means optimize the order,
 * 'false' means traverse the path through the waypoints in the original order
 * described.
 */
RoutePreference.prototype.setOptimized = function(optimized){
    
    this.optimized=optimized;
};
/**
 * Retrieve whether the waypoints between the origin and destination will be
 * traversed in an optimal order. 'true' means optimize the order, 'false' means
 * traverse the path through the waypoints in the original order described.
 * @returns {boolean} 'true' means optimize the order, 'false' means traverse
 * the path through the waypoints in the original order described.
 */
RoutePreference.prototype.getOptimized = function(){
    
    return this.optimized;
};
/**
 * Optional parameter override default maneuver rules file used on server.
 * @private
 * @param {String} rules optional parameter override default maneuver rules file
 * used on server.
 */
RoutePreference.prototype.setRules = function(rules){
    
    this.rules=rules;
};
/**
 * Retrieve any default maneuver rules overrides.
 * @private
 * @return {String} rules parameter override default maneuver rules file used on
 * server.
 */
RoutePreference.prototype.getRules = function(){
    
    return this.rules;
};

/**
 * expectedStartTime is for use with DDS predictive traffic.
 * @param {String} expectedStartTime format YYYY-DD-MMTHH:MI:SS-HH:MI e.g.
 * 2008-02-25T11:12:00-08:00 this is the local time with the offset from GMT.
 */
RoutePreference.prototype.setExpectedStartTime = function(expectedStartTime){
    
    this.expectedStartTime = expectedStartTime;
};
/**
 * expectedStartTime is for use with DDS predictive traffic.
 * @return {String} expectedStartTime
 */
RoutePreference.prototype.getExpectedStartTime = function(){
    
    return this.expectedStartTime;
};

/**
 * Return the array of areas to avoid.
 * @returns {Object[]} Array of objects describing which features should be
 * avoided.
 */
RoutePreference.prototype.getAvoidAreas = function() {
    
    return this.avoidAreas;
};

/**
 * Adds an area to the list of areas to avoid.
 * @example
 * @param {object|null} area Object representing the area that will be avoided.
 * The properties on the object describe the area.
 * If a falsey value is passed in as an argument, the current list of
 * avoidAreas will be erased.
 * @param {string} area.name The type of area that we wish to avoid.
 * Valid settings are:
 * "Line", a continuous array of positions that will be avoided during a route;
 * "Polygon", an enclosed area described by a continuous array of positions;
 * "Rectangle", an enclosed area described by two minimum and maximum positions;
 * "Circle", an area described by a point and a radius.
 * @param {Position[]} area.pos An array of positions that, depending on the
 * shape being described, has a different meaning.
 * For a Line this describes the continuous segments of road network to avoid.
 * For a Polygon this describes the area enclosed by the Polygon. The Polygon
 * will automatically be closed between the final and initial position in the
 * array.
 * For a Rectangle there should be only two positions: the lower left corner
 * of the Rectangle followed by the Position representing the upper right corner.
 * For a Circle there should be only one position in the array, that being
 * the center point.
 * @param {Radius} [area.radius] Only used with a Circle to describe the total
 * area of the circle.
 */
RoutePreference.prototype.addAvoidArea = function( area ) {
   
   // Avoid error checking in this function. Rely on the user getting things right
   if ( !area ) {
       this.avoidAreas = [];
   }
   else {
       this.avoidAreas.push(area);
   }
};

/**
 * Return the array of features to avoid.
 * @returns {Array} Array of strings describing which features should be
 * avoided.
 */
RoutePreference.prototype.getAvoidList = function() {
    
    return this.avoidList;
};

/**
 * Sets the vehicle type to be used for routing. Essentially, provides a modicum
 * of error checking should the input be an invalid type.
 * A list of valid types and their description can be obtained by calling
 * getValidVehicleTypes
 * @param {string} type required The vehicle type.
 * @thows {Exception} If type is invalid.
 */
RoutePreference.prototype.setVehicleType = function(type) {
    if (type in this.validVehicleTypes){
        this.vehicleType = type;
        return;
    }
    throw new Exception( "RoutePreference.setVehicleType: invalid type: " + type);
}

/**
 * Returns the currently set vehicle type.
 * @return {string} vehicle type
 */
RoutePreference.prototype.getVehicleType = function() {
    return this.vehicleType;
}

/**
 * Returns a list of valid vehicle types.
 * @return {object} Object where the keys are valid vehicle types and the values
 * descriptions of the type;
 */
RoutePreference.prototype.getValidVehicleType = function() {
    return this.validVehicleTypes;
}

/**
 * Sets one type of feature to avoid. Essentially, provides a modicum of error
 * checking should the input be an invalid feature to avoid. Currently
 * allowed settings:
 * @example
 * Ferry
 * Toll
 * Tunnels
 * Bridges
 * @param {string} feature required The feature type to set to avoid when a route
 * is computed with this RoutePreference.
 * @thows {Exception} If feature is invalid.
 */
RoutePreference.prototype.setAvoidList = function( feature ) {
   
   if ( typeof feature == "string" || feature instanceof "String" ) {
       switch( feature.toLowerCase() ) {
           case "ferry":
               this.avoidList.push("Ferry");
               return;
           case "toll":
               this.avoidList.push("Toll");
               return;
           case "tunnels":
               this.avoidList.push("Tunnels");
               return;
           case "bridges":
               this.avoidList.push("Bridges");
               return;
           default:
               // Fall through, we'll throw below
               break;
       }
   }
   // We shouldn't get here
   throw new Exception( "RoutePreference.setAvoidList: invalid argument: " +
          "feature: " + feature );
};

/**
 * Return the currently set generalization factor, if there is one.
 * @returns {float} The currently set generalization factor. A result of 0
 * is the equivalent of an off setting.
 */
RoutePreference.prototype.getGeneralizationFactor = function() {
    
    return this.generalizationFactor;
};

/**
 * Set the current generalization factor for this RoutePreference.
 * @param {Array} wayPoints required The stop points that will make up the
 * route we wish to generalize.
 * @param {integer} zoomLevel required The minimum Zoom Level we wish to create
 * a generalization for.
 * @throws {Exception} Invalid waypoints or zoomLevel.
 */
RoutePreference.prototype.setGeneralizationFactor = function( wayPoints, zoomLevel ) {
    
    try {
        this.generalizationBBox = Utilities.positionsToBoundingBox( wayPoints );
        this.generalizationFactor = Utilities.generalizationFactor( this.generalizationBBox, zoomLevel );
    }
    catch (e) {
        // Just pass back up
        throw e;
    }
    
};

/**
 * Set the useExclusionZone attribute, if set to true, then the routing will avoid the exclusion zones stored
 * on server side.
 * @param {boolean} useExclusionZone required The useExclusionZone attribute
 */
RoutePreference.prototype.setUseExclusionZone= function(useExclusionZone){
    this.useExclusionZone=useExclusionZone;
}


/**
 *
 * DDS RouteControl allows for granual tuning of the DDS routing engine.
 * To use this control you must be familiar with DDSQL.  Please contact
 * our support team for deeper insights.
 * @param {String} ddsql query for the routing engine
 */
RoutePreference.prototype.setRouteControl= function(routeControl){
    this.routeControl=routeControl;
}

/**
 * Flag to tell the server to return a routeID (dehydrated route).  If you do not use routeID's
 * you should set this to false everytime since it will increase the performance of the routing engine.
 * @param {boolean} provideRouteHandle return routeID
 */
RoutePreference.prototype.setProvideRouteHandle= function(provideRouteHandle){
    this.provideRouteHandle=provideRouteHandle;
}


/**
 * Initialize the logistics preferences object with the currently supported
 * properties. The following properties are currently allowed:
 * <ul>
 * <li>RoutePreference.logisticsPreference.preferredRoute: correseponds to
 * the DDS ROUTEREG keyword and the Web Services Logistics
 * child element PreferredRoute</li>
 * <li>RoutePreference.logisticsPreference.hazmat: corresponds to the
 * DDS HAZMAT keyword and the Web Services Logistics child element Hazmat</li>
 * <li>RoutePreference.logisticsPreference.vehicleParameters: corresponds to
 * the DDS VEHPARAMS keyword and the Web Services Logistcs child element
 * VehicleParameters</li>
 * <li>RoutePreference.logisticsPreference.vehicleTypes: corresponds to the
 * DDS VEHTYPES keyword and the Web Services Logistics child element
 * VehicleTypes</li>
 * <li>RoutePreference.logisticsPreference.preferredTurn: corresponds to the
 * DDS TURNREG keyword and the Web Services Logistics child element
 * PreferredTurn</li>
 * </ul>
 * For how to set these keywords, please see the Drill Down Server Logistics
 * user manual for the valid options. This object simply performs a pass through
 * to the web services which in turn performs a pass through of the values
 * directly to the DDS. We recommend making sure that you restrict your users
 * to just the options that are valid for the DDS, as unexpected results may
 * occur if you let invalid values be sent in a route query.
 */
//RoutePreference.prototype.enableLogistics = function() {
//    
//
//    this.logisticsPreference = {};
//    this.logisticsPreference.preferredRoute = "";
//    this.logisticsPreference.hazmat = "";
//    this.logisticsPreference.vehicleParameters = "";
//    this.logisticsPreference.vehicleTypes = "";
//    this.logisticsPreference.preferredTurn = "";
//};


/**
 * @fileoverview RouteQuery
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class RouteQuery initiates the calculation of a route and directions.
 * The RouteQuery allows you to get all the 
 * route details, including the geometry that defines the path of the route. 
 * This can be used in conjunction with the client-side Shape rendering API to 
 * overlay a custom-defined route dynamically (e.g. without a refresh) on a Map.
 * A RouteQuery is also useful when you wish to compute a route but don't have 
 * any need to associate the route results with an instance of a Map.
 * @description Construct a new RouteQuery object.
 * @constructor
 * @see Map#setShapeRendering
 */
function RouteQuery() {
    

    /**
     * Generate XLS messages as strings.
     * @private
     * @type deCarta.XMLStringBuilder
     */
    this.xmlRecFac = new deCarta.XMLStringBuilder();
    /**
     * Store route callback handling functions. Functions are indexed by
     * requestId of the DetermineRouteRequest.
     * @private
     * @type Array
     * @default []
     */
    var _callBackArray = [];
    /**
     * Self realization.
     * @private
     */
    var self = this;

    /**
     * Authenticate the RouteQuery. If you have already authenticated another 
     * object, or have manually set the authentication fields of the Credentials
     * object, you do not have to use this function.
     * @param {String} clientName required Set with the clientName 
     * authentication token.
     * @param {String} clientPassword required Set with the clientPassword 
     * authentication token.
     * @throws {Exception} exception "Error authenticating RouteQuery, invalid 
     * parameters."
     * @see Credentials
     */
    this.authenticate = function( clientName, clientPassword ) {
        
        if(!clientName || !clientPassword || clientName=="" || clientPassword==""){
            throw new Exception("Error authenticating RouteQuery, invalid parameters.");
            return false;
        }
        Credentials.clientName = clientName;
        Credentials.clientPassword = clientPassword;
        this.xmlRecFac.clientName = clientName;
        this.xmlRecFac.clientPassword = clientPassword;
    };



    /**
     * Compute a route and return the detailed information within an instance of
     * the {@link Route} class.
     * <p>Calling this function makes an asynchronous request to the DDS Web 
     * Services. To handle the results, the application should provide a 
     * callBack function that has the following prototype:</p>
     * <p><code>function callBack(route)</code></p>
     * <p>where</p>
     * <ul>
     * <li>callBack = Arbitrary function name</li>
     * <li>route = A Route object that describes the route, or null if there
     * was an error determining the route.</li>
     * </ul>
     * @param {Array} positions An array of Positions that determine 
     * the stops of the route to be calculated. The first Position is the 
     * origin, the last Position is the destination, and each Position in 
     * between is considered a waypoint.
     * @param {RoutePreference} routePreference Provides rules to the 
     * RouteQuery that determine how a route is calculated.
     * @param {function} callBack A function that accepts a Route 
     * object as a parameter.
     * @param {function} [timeoutCallback] Function to be called in case this
     * particular query times out.
     * @throws {Exception} If a function is not passed in as a callBack.
     * @see RoutePreference
     * @see Route
     */
    this.query = function( positions, routePreference, callBack, timeoutCallback ){
        
        var reqId = Utilities.getRequestId();
        if ( typeof callBack == 'function' ) {
            _callBackArray[reqId] = callBack;
        } else {
            throw new Exception("RouteQuery.query: callBack must be a function, arg was: " + callBack );
        }
        var xml = this.xmlRecFac.createRouteGeometryRequest( positions, reqId, routePreference );
        JSRequest.send(xml, self.queryCallback, null, timeoutCallback);        
    };

    /**
     * Used to re-request a previously made route via a Route Identification 
     * value. Every route generated by the DDS Web Services
     * can return a RouteHandle tag that contains a routeID attribute. The
     * value of the routeID attribute can be passed back through this function
     * to regenerate an identical route. The use of a routeID is only advantageous
     * if you need to reproduce a copy of a previously generated route quickly:
     * routeIDs need a fraction of the processing power to "rehydrate" compared 
     * to what is required to calculate the original route. Other than the
     * difference in paramaters, this method performs the same as
     * {@link RouteQuery#query}.
     * @param {string} routeId A previously generated routeID value.
     * @param {function} callBack A function that accepts a Route 
     * object as a parameter.
     * @param {function} [timeoutCallback] Function to be called in case this
     * particular query times out.
     * @throws {Exception} If a function is not passed in as a callBack.
     * @see Route
     */
    this.queryById = function( routeId, callBack, timeoutCallback ){
        
        var reqId = Utilities.getRequestId();
        if ( typeof callBack == 'function' ) {
            _callBackArray[reqId] = callBack;
        } else {
            throw new Exception("RouteQuery.queryById: callBack must be a function, arg was: " + callBack );
        }
        //createRouteGeometryRequestDOM = function(positionList, requestId, routePreference, expectedStartTime )
        var xml = this.xmlRecFac.createRouteGeometryByIdRequest( routeId , reqId );

        //document.getElementById("xml").value="";
        JSRequest.send(xml,self.queryCallback, null, timeoutCallback);
    };

    /**
     * Handle all responses from the Web Services for the two types of route
     * queries.
     * @param {Object} data required The XLS response from web services jsonified.
     * @private
     */
    this.queryCallback = function( data ) {
        
        var reqId = data.XLS.Response.requestID;
        var results;
        if ( deCarta.JSONParser.parseErrors(data) ) {
            // Return expected error indicator
            results = null;
        }
        else {
            results = deCarta.JSONParser.parseRoutes(data);
        }
        if ( (reqId >= 0) && _callBackArray[reqId] ) {
            _callBackArray[reqId](results);
            _callBackArray[reqId] = undefined;
        }
    };
}


/**
 * @fileoverview ScaleBar visualizes the current scale of the map.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class ScaleBar for representing the dynamic scale of earth distance to pixel
 * distance. Map instances and ScaleBar instances have a one to one
 * relationship. Currently the proper method of using a ScaleBar is to create
 * a new instance of this class and pass the instance directly to the Map
 * object via {@link Map#addScaleBar}.
 * @description Construct a new ScaleBar object.
 * @constructor
 * @param opts (optional) an Object literal containing configuration options.
 * <pre>
 * {
 *      screenPosition: 'bottomRight', //topLeft, topRight, bottomLeft,
 *                                     //bottomRight (default: bottomRight)
 *      xMargin: 0, // x px from edge of map. default: 0.
 *      yMargin: 0, // y px from edge of map. default: 0.
 * }
 * </pre>
 * @see Map#addScaleBar
 */
function ScaleBar(opts){

    if (!opts) opts = {};
	this.setOpts(opts);
	this.init();
}
// ------------------------------------------------------------- Fields
/**
 * Map instance this scalebar is associated with.
 * @type Map
 * @default null
 * @private
 */
ScaleBar.prototype.map = null;
/**
 * General identifcation for this map control. Part of the general map control
 * interface. Treat as a read-only property.
 * @type string
 * @default "ScaleBar"
 * @private
 */
ScaleBar.prototype.type = "ScaleBar";
/**
 * The height of this ScaleBar. Only used during positioning.
 * @type number
 * @default 40
 * @private
 */
ScaleBar.prototype.frameHeight = 40;
/**
 * The width of the ScaleBar. Used during positioning and when calculating
 * the length available for the display scales.
 * @type number
 * @default 120
 * @private
 */
ScaleBar.prototype.frameWidth = 120;
/**
 * The on page div containing this scaleBar.
 * @type DOM Element (div)
 * @default null
 * @private
 */
ScaleBar.prototype.frame = null;
/**
 * The CSS class that applies to this ScaleBar. Also functions as the
 * id of the on screen frame.
 * @type string
 * @default "decarta-scaleBar"
 * @private
 */
ScaleBar.prototype.cssClass = "decarta-scaleBar";
/**
 * Human readable Imperial current scale.
 * @type DOM Element (div)
 * @default null
 * @private
 */
ScaleBar.prototype.measureImperial = null;
/**
 * Human readable Metric current scale.
 * @type DOM Element (div)
 * @default null
 * @private
 */
ScaleBar.prototype.measureMetric = null;
/**
 * The CSS class that applies to the measure length of the ScaleBar.
 * @type string
 * @default "decarta-scaleBarMeasure"
 * @private
 */
ScaleBar.prototype.measureCssClass = "decarta-scaleBarMeasure";
/**
 * This puts scale in ScaleBar. This is the imperial half.
 * @type DOM Element (Div)
 * @default null
 * @private
 */
ScaleBar.prototype.scaleImperial = null;
/**
 * CSS class for the scalebar.
 * @type string
 * @default "decarta-scaleBarImperialScale"
 * @private
 */
ScaleBar.prototype.scaleImperialCssClass = "decarta-scaleBarImperialScale";
/**
 * This puts scale in ScaleBar. This is the metric half.
 * @type DOM Element (Div)
 * @default null
 * @private
 */
ScaleBar.prototype.scaleMetric = null;
/**
 * CSS class for the Imperial scalebar.
 * @type string
 * @default "decarta-scaleBarMetricScale"
 * @private
 */
ScaleBar.prototype.scaleMetricCssClass = "decarta-scaleBarMetricScale";


ScaleBar.prototype.opts = {
    screenPosition: 'bottomRight',
    xMargin: 0,
    yMargin: 0
}

/**
 * Set up the internal options object
 */
ScaleBar.prototype.setOpts = function(opts) {    
    if (typeof opts.screenPosition !== 'undefined') this.opts.screenPosition = opts.screenPosition;
    if (typeof opts.xMargin !== 'undefined') this.opts.xMargin = opts.xMargin;
    if (typeof opts.yMargin !== 'undefined') this.opts.yMargin = opts.yMargin;
}


/**
 * Initialize settings needed for the ScaleBar object. All building
 * of the ScaleBar happens after it is associated with a map.
 * @private
 */
ScaleBar.prototype.init = function() {
    
};
/**
 * Build the on page DOM elements, and associated event handling, that form
 * the ScaleBar. Does not place the ScaleBar onto the map.
 * @private
 */
ScaleBar.prototype.build = function() {
    
    
    // Imperial numbers and scale go on top...
    this.measureImperial = document.createElement("div");
    this.measureImperial.className = this.measureCssClass;
    Utilities.setUnselectable(this.measureImperial);
    // ...and the imperial scale
    this.scaleImperial = document.createElement("div");
    this.scaleImperial.className = this.scaleImperialCssClass;
    if ( Utilities.ie6 ) {
        // There seems to be a problem with height of the scalebars in ie6... shocking
        // This forces text to be inserted into the empty div, tricking ie6 into
        // making sure the height is the size of the text
        this.scaleImperial.innerHTML = "&nbsp;";
    }
    Utilities.setUnselectable(this.scaleImperial);

    // Metric measurements go on the bottom...
    this.measureMetric = document.createElement("div");
    this.measureMetric.className = this.measureCssClass;
    Utilities.setUnselectable(this.measureMetric);
    // ...and the metric scale
    this.scaleMetric = document.createElement("div");
    this.scaleMetric.className = this.scaleMetricCssClass;
    if ( Utilities.ie6 ) {
        // There seems to be a problem with height of the scalebars in ie6... shocking
        // This forces text to be inserted into the empty div, tricking ie6 into
        // making sure the height is the size of the text
        this.scaleMetric.innerHTML = "&nbsp;";
    }
    Utilities.setUnselectable(this.scaleMetric);

    // The container for the ScaleBar, helps control positioning
    this.frame = document.createElement("div");
    this.frame.id = this.cssClass;
    this.frame.className = this.cssClass;
    Utilities.setUnselectable(this.frame);
    // Append children elements to the frame
    this.frame.appendChild(this.measureImperial);
    this.frame.appendChild(this.scaleImperial);
    this.frame.appendChild(this.scaleMetric);
    this.frame.appendChild(this.measureMetric);
}; /* end init */

/**
 * Interface used by the Map to grab the correct DOM object to append to the
 * page.
 * @returns {DOM Element} The DOM element representation of the ScaleBar
 * that should be appended to the map object.
 * @private
 */
ScaleBar.prototype.appendThis = function() {
    
    // Lazy create the frame
    if (!this.frame) {
        this.build();
    }

    return this.frame;
};

/**
 * Interface for the Map object to remove the ScaleBar from the
 * DOM.
 * @returns {DOM Element} The DOM element representation of the ScaleBar that
 * should be removed from the map object.
 * @private
 */
ScaleBar.prototype.removeThis = function() {
    
    this.map = null;

    //@todo add any cleanup to this function, should we wish to.
    
    return this.frame;
};

/**
 * Repositions the ScaleBar relative to the associated Map instance.
 * To be called after the CopyrightMessage has been associated with a Map
 * and usually only needed when the Map has been resized. Part of the general
 * map control interface.
 * @param {DOMDimensions} ddim required Dimenions of map against which to
 * position this control.
 * @private
 */
ScaleBar.prototype.position = function( ddim ) {
    
    if ( !this.map ) {
        return;
    }
    var px = "px";
	
	switch (this.opts.screenPosition){
		case 'topLeft':
			this.frame.style.top = this.opts.yMargin + px;
			this.frame.style.left = this.opts.xMargin + px;
		break;
		case 'topRight':
			this.frame.style.top = this.opts.yMargin + px;
			this.frame.style.left = ddim.width - this.opts.xMargin - this.frameWidth + px;
		break;
		case 'bottomLeft':            
			this.frame.style.top = ddim.height - this.opts.yMargin - this.frameHeight + px;
			this.frame.style.left = this.opts.xMargin + px;
		break;
		default:
		case 'bottomRight':
			this.frame.style.top = ddim.height - this.opts.yMargin - this.frameHeight + px;
			this.frame.style.left = ddim.width - this.opts.xMargin - this.frameWidth + px;
		break;
	}
};
/**
 * Cause a ScaleBar attached to a map to recalculate the displayed scale.
 * @private
 */
ScaleBar.prototype.calculate = function(){
    

    //------------------------------------- Bit o' error checking and prevention
    if(!this.map || !this.map.getZoomController()){
        return;	
    }
    try{
        this.map.getCenterPosition()
    }catch(e){
        return;
    }

    //------------------------------------- Calculate our base units per pixel
    var gx = this.map.getZoomController().getGXConvertedZoomLevel();
    var sl = Utilities.radsPerPixelAtZoom(this.map.getTileSize(), gx);
    var p = this.map.getCenterPosition();
    // Assign cosine lat correction from the center of our view
    var cosLatCorrection = Math.cos(((p.lat)*(Math.PI/180)));
    // Work with the mercator pixel longitude
    var pixLon = Utilities.lon2pix(p.lon, sl);
    // Find the distance between 1 Mercator Pixel of longitude at the center
    var p1 = Utilities.pix2lon(pixLon+1, sl);
    var p2 = Utilities.pix2lon(pixLon, sl);
    var degreesPerPixel = p1 - p2;
    var metersPerDegree = parseFloat(cosLatCorrection * 111325);
    // Approximate length of a pixel can now be found by metersPerDegree
    var metersPerPixel = ( degreesPerPixel * metersPerDegree );
    // And we approximate our imperial base unit
    var feetPerPixel = metersPerPixel * 3.28;
    // We adjust the allowable size of the scale bar here to prevent clipping
    var frameWidth = this.frameWidth - 15;

    //------------------------------------- Figure out size of display scale
    this.scaleMetric.style.width = getScaleMetricWidth(metersPerPixel, frameWidth) + "px";
    this.scaleImperial.style.width = getScaleImperialWidth(feetPerPixel, frameWidth) + "px";

    //------------------------------------- Display new text
    this.measureMetric.innerHTML = getMeasureMetric(metersPerPixel, frameWidth);
    this.measureImperial.innerHTML = getMeasureImperial(feetPerPixel, frameWidth);

    /**
     * Code to figure out the max size of our Imperial scale bar.
     * @param {number} feetPerPixel required Number of feet per pixel at this
     * zoom level.
     * @param {number} frameWidth required Maximum allowable number of pixels
     * to draw with. Need to pass in because inner functions can't properly
     * reference prototype fields.
     * @returns {number} Pixel width to set the Imperial scale bar.
     */
    function getScaleImperialWidth( feetPerPixel, frameWidth ) {
        // Calculate our index from the following table to determine what is an
        // acceptable distance to display on the screen given our ScaleBar
        // size
        // Units are in feet
        var calculationUnits = [ 25,
            50,
            100,
            200,
            500,
            1000,
            2000,
            5280,
            10560,
            26400,
            52800,
            132000,
            264000,
            396000,
            528000,
            1056000,
            1584000,
            2640000,
            3168000,
            3696000,
            4224000,
            4752000,
            5280000,
            10560000,
            15840000,
            21120000,
            26400000 ];
        // The maximum scale equates to the total distance we can accomadate
        // We need the relative distance here match up with our display value
        // in the complimentary mesurement function.
        var maxScale = feetPerPixel * frameWidth;
        var i;
        var numIndexes = calculationUnits.length;
        for ( i = 0; i < numIndexes; i++ ) {
            if ( maxScale <= calculationUnits[i] ) {
                // We have our index in var i now
                break;
            }
        }
        // Translate the number pixels we can actually show on the screen
        // The actual index we use is the one previous to make sure it fits
        // on screen
        // Zero is our lowest index
        i = (i-1 > 0) ? i - 1 : 0;
        var scaleNumPix = calculationUnits[i] / feetPerPixel;
        // Return our the width of our scale
        return scaleNumPix;
    } /* end getScaleImperialWidth */

    /**
     * Code to figure out Imperial measurement to display.
     * @param {number} feetPerPixel required Number of feet per pixel at this
     * zoom level.
     * @param {number} frameWidth required Maximum allowable number of pixels
     * to draw with. Need to pass in because inner functions can't properly
     * reference prototype fields.
     * @returns {string} Imperial text to display.
     * @inner
     */
    function getMeasureImperial( feetPerPixel, frameWidth ) {
        // Calculate our index from the following table to determine
        // (units are in feet)...
        var calculationUnits = [25,
            50,
            100,
            200,
            500,
            1000,
            2000,
            5280,
            10560,
            26400,
            52800,
            132000,
            264000,
            396000,
            528000,
            1056000,
            1584000,
            2640000,
            3168000,
            3696000,
            4224000,
            4752000,
            5280000,
            10560000,
            15840000,
            21120000,
            26400000 ];
        // ...which units should be displayed.
        var displayUnits = [ "25 ft",
            "50 ft",
            "100 ft",
            "200 ft",
            "500 ft",
            "1000 ft",
            "2000 ft",
            "1 mi",
            "2 mi",
            "5 mi",
            "10 mi",
            "25 mi",
            "50 mi",
            "75 mi",
            "100 mi",
            "200 mi",
            "300 mi",
            "500 mi",
            "600 mi",
            "700 mi",
            "800 mi",
            "900 mi",
            "1000 mi",
            "2000 mi",
            "3000 mi",
            "4000 mi",
            "5000 mi"];
        // The maximum scale is the number of pixels allowed on screen
        var maxScale = feetPerPixel * frameWidth;
        var i;
        var numIndexes = calculationUnits.length;
        for ( i = 0; i < numIndexes; i++ ) {
            if ( maxScale <= calculationUnits[i] ) {
                // We have our index in var i now
                break;
            }
        }
        // Return our string
        // The actual index we use is the one previous to make sure it fits
        // on screen
        // Zero is our lowest index
        i = (i-1 > 0) ? i - 1 : 0;
        return displayUnits[i];
    } /* end getMeasureImperial */

    /**
     * Code to figure out the max size of our Metric scale bar.
     * @param {number} metersPerPixel required Number of meters per pixel at this
     * zoom level.
     * @param {number} frameWidth required Maximum allowable number of pixels
     * to draw with. Need to pass in because inner functions can't properly
     * reference prototype fields.
     * @returns {number} Pixel width to set the Metric scale bar.
     * @inner
     */
    function getScaleMetricWidth( metersPerPixel, frameWidth ) {
        // Calculate our index from the following table to determine what is an
        // acceptable distance to display on the screen given our ScaleBar
        // size
        // Units are in meters
        var calculationUnits = [ 10,
            25,
            50,
            100,
            200,
            500,
            1000,
            2000,
            5000,
            10000,
            25000,
            50000,
            75000,
            100000,
            200000,
            300000,
            500000,
            600000,
            700000,
            800000,
            900000,
            1000000,
            2000000,
            3000000,
            4000000,
            5000000];
        // The maximum scale equates to the total distance we can accomadate
        // We need the relative distance here match up with our display value
        // in the complimentary mesurement function.
        var maxScale = metersPerPixel * frameWidth;
        var i;
        var numIndexes = calculationUnits.length;
        for ( i = 0; i < numIndexes; i++ ) {
            if ( maxScale <= calculationUnits[i] ) {
                // We have our index in var i now
                break;
            }
        }
        // Translate the number pixels we can actually show on the screen
        // The actual index we use is the one previous to make sure it fits
        // on screen
        // Zero is our lowest index
        i = (i-1 > 0) ? i - 1 : 0;
        var scaleNumPix = calculationUnits[i] / metersPerPixel;
        // Return our the width of our scale
        return scaleNumPix;
    } /* end getScaleMetricWidth */

    /**
     * Code to figure out Metric measurement to display.
     * @param {number} metersPerPixel required Number of meters per pixel at this
     * zoom level.
     * @param {number} frameWidth required Maximum allowable number of pixels
     * to draw with. Need to pass in because inner functions can't properly
     * reference prototype fields.
     * @returns {string} Metric text to display.
     * @inner
     */
    function getMeasureMetric( metersPerPixel, frameWidth ) {
        // Calculate our index from the following table to determine
        // (units are in meters) ...
        var calculationUnits = [ 10,
            25,
            50,
            100,
            200,
            500,
            1000,
            2000,
            5000,
            10000,
            25000,
            50000,
            75000,
            100000,
            200000,
            300000,
            500000,
            600000,
            700000,
            800000,
            900000,
            1000000,
            2000000,
            3000000,
            4000000,
            5000000];
        // ...which units should be displayed.
        var displayUnits = [ "10 m",
            "25 m",
            "50 m",
            "100 m",
            "200 m",
            "500 m",
            "1 km",
            "2 km",
            "5 km",
            "10 km",
            "25 km",
            "50 km",
            "75 km",
            "100 km",
            "200 km",
            "300 km",
            "500 km",
            "600 km",
            "700 km",
            "800 km",
            "900 km",
            "1000 km",
            "2000 km",
            "3000 km",
            "4000 km",
            "5000 km"];
        // The maximum scale is the number of pixels allowed on screen
        var maxScale = metersPerPixel * frameWidth;
        var i;
        var numIndexes = calculationUnits.length;
        for ( i = 0; i < numIndexes; i++ ) {
            if ( maxScale <= calculationUnits[i] ) {
                // We have our index in var i now
                break;
            }
        }
        // Return our string
        // The actual index we use is the one previous to make sure it fits
        // on screen
        // Zero is our lowest index
        i = (i-1 > 0) ? i - 1 : 0;
        return displayUnits[i];
    } /* end getMeasureMetric */
};

// ---------------------------------------------------------- Old Code
/**
 * Return the containing DIV of this ScaleBar.
 * @private
 * @deprecated Should no longer be needed externally or internally.
 */
ScaleBar.prototype.getDiv = function() {
    
    return this.frame;
};

/**
  * @fileoverview SearchCriteria class file.
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */

/**
 * Construct a new SearchCriteria object.
 * @class Used by the {@link POIQuery}, SearchCriteria defines what sort of
 * Points of Interest, or POIs, are retrieved during a POI search. An
 * instance of a SearchCriteria defines the where POIs should be searched for
 * and what type of POIs should be returned.
 * @param {String} [queryString] POIs must have this sub-string
 * located in their name to be returned. Example, 'pizza' or 'parking'.
 * @param {Position} position The center point to search from.
 * @param {Radius} [radius=new Radius(0.5)] How far to search from the center point.
 * POIs outside of the search radius will not be returned.
 * @param {int} [maximumResponses=10] The maximum number of POIs to
 * return, cannot exceed 100.
 * @param {String} [database] If the DDS Web Services has an external
 * POI database, look in the database defined by this name. By default, the
 * query will search the base RMF data. Unless instructed to do otherwise,
 * leave off this parameter.
 * @param {UOM} [defaultUOM] Enforces units of distance to describe the found POIs in.
 * @throws {Exception} if too many responses are requested, or if Position
 * is not valid.
 * @see POIQuery
 * @see POI
 * @extends AbstractSearchCriteria
 * @constructor
 */
function SearchCriteria( queryString, position, radius, maximumResponses, database, defaultUOM) {
    
    this.queryString = queryString;
    /**
     * The center point to search from.
     * @type Position
     */
    this.position = null;
    // defensive copying, in case we get a malleable obj.position
    if( position && position.clone){
        this.position = position.clone();
    } else {
        throw new Exception("SearchCriteria constructor: position not valid");
    }
    /**
     * How far to search from the center point. POIs outside of the search
     * radius will not be returned.
     * @type Radius
     * @default 0.5 KM search radius
     */
    this.radius = radius || new Radius( 0.5 );

    if(maximumResponses)
        this.maximumResponses = maximumResponses;
    if(database)
        this.database = database;
    if(database)
        this.defaultUOM = defaultUOM;
}

// Extend class, first prototype, then reset the constructor
SearchCriteria.prototype = new AbstractSearchCriteria();
SearchCriteria.prototype.constructor = AbstractSearchCriteria;

/**
 * @fileoverview ServerMonitor
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * A ServerMonitor can be used to check on basic status of server.
 * The ServerMonitor is of little use to users who are utilizing a cross-domain
 * DDS Web Services as it makes use of an XMLHttpRequest. If you are using
 * dynamic script tags, consider registering a callback function with
 * {@link JSRequest.registerXMLResponseInterceptor}.
 * @description Construct a new ServerMonitor object.
 * @constructor
 */
function ServerMonitor() {
    

    /**
     * Array of callBack functions indexed by requestID.
     * @type Array
     */
    var _callBackArray = [];

    /**
     * Builds the necessary RUOK requests.
     * @type deCarta.XMLStringBuilder
     */
    var _xmlStringBuilder = new deCarta.XMLStringBuilder();

    /**
     * Query function for checking system status. This is useful for testing
     * the setup and configuration of Web Services.
     * The callBack function will be passed an informational object that
     * can be used to determine specific information about the server.
     * @example
     * // create a new monitor
     * var sm = new ServerMonitor();
     * // our callback, not seen here, will handle the response object
     * // the name of our callback function is arbitrary
     * sm.query(handleResponse);
     * // once the query returns, handleResponse will be passed one object of
     * // the following design (arbitrarily we name the parameter response):
     * response.status == the final status from the XMLHttpRequest
     * response.xml == the response to our RUOK request as a serialized XLS string
     * response.json == the response to our RUOK request as a JSON object
     * @param {function} callBack Function used to parse the information
     * returned from the server.
     * @return {boolean} Will fail almost silently if no callback function
     * is passed in (false), or will signal that the query has been initiated
     * (true).
     */
    this.query = function(callBack){
        
        if ( !callBack || (typeof callBack != "function") ) {
            return false;
        }
        var reqId = Utilities.getRequestId();
        _callBackArray[reqId] = callBack;
        var xmlRequestString = _xmlStringBuilder.createRUOKRequest(reqId);
        this.sendServerMonitorQueryRequest( xmlRequestString );
        return true;
    };
    /**
     * Performs the sending of the request and handles the response all in
     * one.
     * @param {string} xmlRequestString Serialized XLS request to be sent to
     * the server.
     * @private
     */
    this.sendServerMonitorQueryRequest = function( xmlRequestString ) {
        
        
        try {
            netscape.security.PrivilegeManager.enablePrivilege("UniversalPreferencesWrite UniversalBrowserWrite UniversalPreferencesRead UniversalBrowserRead");
        } catch (e) {}

        // Send our request to the JSON servlet
        var url = Credentials.url;
        if(url.indexOf("/openls/openls") > -1){
              url = url.substring(0, url.indexOf("/openls/openls"));
              url = url+"/openls/JSON?responseFormat=ALL";
        }
        var xmlhttp = null;
        try {
            if ( XMLHttpRequest ) {
                xmlhttp = new XMLHttpRequest();
            }
            else {
                xmlhttp = new ActiveXObject();
            }
        } catch(e) {}
        // handle problems here
        if ( !xmlhttp ) {
            throw new Exception("ServerMonitor: I can't believe your system cannot generate an XMLHttpRequest. Oh the shame.");
        }
        xmlhttp.open("POST", url, true);
        xmlhttp.onreadystatechange = function() {
            if (xmlhttp.readyState == 4) {
                // build our response object then pass back
                var rawResponse = eval(xmlhttp.responseText);
                var response = {};
                // Documentation of this response object kept with the query.
                response.status = xmlhttp.status;
                response.xml = rawResponse.xmlResponse;
                response.json = rawResponse.response;
                if ( _callBackArray[response.json.XLS.Response.requestID] ) {
                    _callBackArray[response.json.XLS.Response.requestID](response);
                }
            }
        }
        xmlhttp.send(xmlRequestString);
    };
}


/**
 * @fileoverview ShapeDrawingTool Class file.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class The ShapeDrawingTool object is primarily used to provide an interactive
 * shape drawing bar for instances of the {@link Map} class. Once added to a Map, the
 * ShapeDrawingTool provides the user a graphical interface to draw DDSShapes.
 * @param {function} shapeOnClick Function that as listener to the shapes drawn by this tool. If not specified,
 * the tool has a default shapeOnClick listner, which pop out an info window, you can input name and
 * description, and do save, delete and cancel operation. Refer to geofence1.html for how to write the custom
 * shapeOnClick listener.
 * @constructor
 * @see Map#addShapeDrawingController
 */
//function ShapeDrawingTool(buildInfoWindowContent,deleteHandler,saveHandler ){
function ShapeDrawingTool(shapeOnClick){
    

    //   ************************************************** Constructor Checks and Public Fields
    /**
     * The map associated with the shape drawing tool.
     */
    this.map = null;
    /**
     * The frame div of this tool UI.
     */
    this.frame=null;
    this.type="ShapeDrawingTool";
    /**
     * If we specify domView=false, then the UI will not be shown up.
     */
    this.domView=true;
    
    //var _infoWindow = infoWin || null;
    //var _buildInfoWindowContent=buildInfoWindowContent || constructInfoWindowContent;
    var _shapeClickHandler=shapeOnClick || defaultShapeClickHandler;
    
    var _self = this;
    var _drawTool = null;

    var _dropdownMenu = null;
    //var _shapes =[];
    var _shape = null;
    var _dashLine = null;
    var _squarePins = [];
    var _isIE           = Utilities.ie;
    var _dragTool = null;
    var _originalMapEvents=null;
    var _toolName=null;


    /**
     * Sets-up the shape drawing tool.
     * @private
     */
    this.initialize = function(){
        
        if (!this.domView) {
            return;
        }

        this.frame=document.createElement("DIV");
        this.frame.id="decarta-shapeDrawingTool"
        this.frame.style.cssText="position:absolute;z-index:9999;left:100px;top:10px;"
        deCarta.IdManager.setTag( this.frame, "ignoreForMapEvents" );
        
        _dragTool=document.createElement("img");
        _dragTool.src=Credentials.imgPath + "draw-tool-drag-selected.png";
        _dragTool.style.cssText="width:31px;height:31px;position:absolute;left:0px;top:0px;"
        _dragTool.onclick= function(){
            clear(true);
        };
        this.frame.appendChild(_dragTool);
        
        var toolName="circle";
        _drawTool=document.createElement("IMG");
        _drawTool.src= Credentials.imgPath + "draw-tool-"+toolName+".png";
        _drawTool.style.cssText="width:39px;height:31px;position:absolute;left:31px;top:0px;"
        _drawTool.toolName=toolName;
        _drawTool.onclick= function(e){
            e=e||event;
            e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
            var xRelPos=e.clientX-Utilities.getAbsoluteLeft(_drawTool) + Utilities.getScrollLeft();
            //if click on the shape or the chooser
            if(xRelPos>this.offsetWidth*2/3){
                _dropdownMenu.style.display="block";
                
            }else if(xRelPos<this.offsetWidth*2/3){
                _dropdownMenu.style.display="none";
                _self.drawShape(this.toolName);
                
            }

        }
        deCarta.IdManager.setTag( _drawTool, "ignoreForMapEvents" );
        this.frame.appendChild(_drawTool);
        initDropdownMenu();
        this.frame.appendChild(_dropdownMenu);

    //saveMapEvents();
    //initInfoWindow();
    };

    function initDropdownMenu(){
        _dropdownMenu=document.createElement("DIV");
        //_dropdownMenu.style.cssText=""
        _dropdownMenu.className = "decarta-drawingToolMenu";

        deCarta.IdManager.setTag( _dropdownMenu, "ignoreForMapEvents" );

        var circle=document.createElement("DIV");
        circle.innerHTML="Draw a circle";
        circle.className="decarta-drawingToolMenuItemOff";
        circle.onmouseover= function(){
            this.className="decarta-drawingToolMenuItemOn";
        }
        circle.onmouseout= function(){
            this.className="decarta-drawingToolMenuItemOff";
        }
        circle.onclick= function(){
            _drawTool.toolName='circle';
            _self.drawShape('circle');
        }
        deCarta.IdManager.setTag( circle, "ignoreForMapEvents" );
        _dropdownMenu.appendChild(circle);

        var line=document.createElement("DIV");
        _dropdownMenu.appendChild(line);
        line.className="decarta-drawingToolMenuItemOff";
        line.innerHTML="Draw a line";
        line.onmouseover= function(){
            this.className="decarta-drawingToolMenuItemOn";
        }
        line.onmouseout= function(){
            this.className="decarta-drawingToolMenuItemOff";
        }
        deCarta.IdManager.setTag( line, "ignoreForMapEvents" );
        line.onclick= function(){
            _drawTool.toolName='line';
            _self.drawShape('line');
        }

        var poly=document.createElement("DIV");
        _dropdownMenu.appendChild(poly);
        poly.innerHTML="Draw a polygon";
        poly.className="decarta-drawingToolMenuItemOff";
        poly.onmouseover= function(){
            this.className="decarta-drawingToolMenuItemOn";
        }
        poly.onmouseout= function(){
            this.className="decarta-drawingToolMenuItemOff";
        }
        deCarta.IdManager.setTag( poly, "ignoreForMapEvents" );
        poly.onclick= function(){
            _drawTool.toolName='poly';
            _self.drawShape('poly');
        }
    }

    /** we can call this function to draw directly without using the UI of shapeDrawingTool
     *@param {string} toolName this toolName should be circle, poly, or line
     */
    this.drawShape = function(toolName){
        if(toolName!='circle' && toolName!='poly' && toolName!='line'){
            throw new Exception("toolName should be circle or poly or line");
        }
        if(!_toolName) saveMapEvents();
        shapeToolOnclick(toolName);
    }


        
    function shapeToolOnclick(toolName){

        clear(true);
        _toolName=toolName;
        if(_drawTool) _drawTool.src=Credentials.imgPath + "draw-tool-"+_toolName+"-selected.png";
        if(_dragTool) _dragTool.src=Credentials.imgPath + "draw-tool-drag.png";

        if(toolName=="circle"){
            _shape=new DDSCircle();
            _shape.setFillColor("(77.0.255)");
        } else if(toolName=="line"){
            _shape=new DDSLine();
            
        }  else{
            _shape=new DDSLine();

        }
        _shape.addEventListener("onclick",shapeClickHandler);

        _dashLine=new DDSLine();
        
        //_self.map.mapDiv.style.cursor="crosshair";
        _self.map.getTilesContainer().style.cursor="crosshair";
        EventRegistry.addListener(_self.map,"moveend",function(){
            _self.map.getTilesContainer().style.cursor="crosshair";
        });
        EventRegistry.addListener(_self.map,"zoomend",function(){
            var squarePins=_squarePins;
            for(var ii=0;ii<squarePins.length;ii++){
                squarePins[ii].setPosition(squarePins[ii].position);
            }
        });

        EventRegistry.addListener(_self.map,"click",function(p){
            var squarePin=new SquarePin(p);
            _squarePins.push(squarePin);
            _self.addSquarePinToMap(squarePin);
            //squarePin.frame.onclick=squarePinOnclick;
           
            if(toolName=="circle"){
                if(!_shape.position){
                    _shape.position=p;
                    //_self.map.mapDiv.onmousemove = whileDragging;
                    _self.map.getTilesContainer().onmousemove = whileDragging;
                
                }else{
                    clear();
                    var radius=Utilities.positions2Distance(_shape.position,p);
                    _shape.setRadius(radius);
                    _self.map.addOverlay(_shape);
                    shapeClickHandler(_shape);
                }
            }else{
                _shape.positions.push(p);
                if(_shape.positions.length==2) _self.map.addOverlay(_shape);
                if(_shape.positions.length>2) _shape.setPositions(_shape.positions);
                _self.map.getTilesContainer().onmousemove = whileDragging;
                
            }

        });

        

    }

    function saveMapEvents(){
        _originalMapEvents={};
        _originalMapEvents.click=_self.map.getEventListener('click');
        _originalMapEvents.moveend=_self.map.getEventListener('moveend');
        _originalMapEvents.zoomend=_self.map.getEventListener('zoomend');

    }

    function restoreMapEvents(){
        for(var z in _originalMapEvents){
            if(_originalMapEvents[z] && _originalMapEvents.hasOwnProperty(z)){
                _self.map.addEventListener(z,_originalMapEvents[z]);
            }else if(_originalMapEvents.hasOwnProperty(z)){
                _self.map.clearListeners(z);
            }
        }
    }

    function squarePinOnclick(e){
        //cancel the drawing, remove all square pins and shapes
        e = e ? e : window.event; /* get IE event ( not passed ) */
        e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
        
        var toolName=_toolName;
        var squarePin=this.squarePin;
        if(toolName=="circle"){
            clear(true);
        }else if(toolName=="line"){
            if(_squarePins.length==1) clear(true);
            else{
                var positions=_shape.positions;
                if(this.squarePin==_squarePins[0] ||  squarePin==_squarePins[_squarePins.length-1]){
                    if(squarePin==_squarePins[0]) positions.push(squarePin.position);
                    clear();
                    _shape.setPositions(positions);
                    shapeClickHandler(_shape);

                }else{
                    positions.push(squarePin.position);
                    _shape.setPositions(positions);
                    var squarePinNew=new SquarePin(squarePin.position);
                    _squarePins.push(squarePinNew);
                    _self.addSquarePinToMap(squarePinNew);
                }

            }
        }else{
            if(_squarePins.length==1) clear(true);
            else{
                positions=_shape.positions;
                if(this.squarePin==_squarePins[0] ||  squarePin==_squarePins[_squarePins.length-1]){
                    //positions.push(_squarePins[0].position);
                    clear();
                    _shape.type="polygon";
                    _shape.setFillColor("(77.0.255)");
                    _shape.setPositions(positions);
                    shapeClickHandler(_shape);

                }else{
                    positions.push(squarePin.position);
                    _shape.setPositions(positions);
                    squarePinNew=new SquarePin(squarePin.position);
                    _squarePins.push(squarePinNew);
                    _self.addSquarePinToMap(squarePinNew);
                }

            }
        }
    }

    function lineToolOnclick(){
        _dropdownMenu.style.display="none";
    }

    function polyToolOnclick(){
        _dropdownMenu.style.display="none";
    }

    function whileDragging(e){
        // Logging here causes too much noise. Manually turn on if needed.
        //
        // potentially used to calculate click positions
        // Grab the correct event object
        e = e ? e : window.event;

        // Map is officially moving now, as such movestart won't fire anymore
        if(!_squarePins.length) return;
        var clickScreenPix = new PixelPoint( e.clientX, e.clientY );
        var startP=_squarePins[_squarePins.length-1].position;
        var p = _self.map.screenPixToPos(clickScreenPix);
        
        var sl=Utilities.radsPerPixelAtZoomLevel(_self.map.getTileSize(),_self.map.getZoomController().getZoomLevel());
        var vectorX=p.lon-startP.lon;
        if(vectorX>180) vectorX=vectorX-360;
        else if(vectorX<-180) vectorX=vectorX+360;
        var vectorY=p.lat-startP.lat;
        if(p.lat==90 || p.lat==-90) return;
        var vectorY2=vectorY/Math.cos(p.lat*Math.PI/180);
        var vectorAngle=Math.atan2(vectorY2,vectorX);
        var degreePerPixelDistanceY=Math.sin(vectorAngle)*sl*180/Math.PI*Math.cos(p.lat*Math.PI/180);
        var degreePerPixelDistanceX=Math.cos(vectorAngle)*(sl*180/Math.PI);

        if(_dashLine) _self.map.removeOverlay(_dashLine);
        if(Math.sqrt(vectorX*vectorX+vectorY2*vectorY2)<15*sl*180/Math.PI) return;
        p=new Position(p.lat-5*degreePerPixelDistanceY,p.lon-5*degreePerPixelDistanceX);
        startP=new Position(startP.lat+10*degreePerPixelDistanceY,startP.lon+10*degreePerPixelDistanceX);

        _dashLine=new DDSLine();
        _dashLine.setPositions([startP, p]);
        _self.map.addOverlay(_dashLine);


    }

    /**
    * Interface used by the Map to grab the correct DOM object to append to the
    * page.
    * @returns {DOM Element|null} The DOM element representation of the ShapeDrawingTool
    * that should be appended to the map object, or null if there is nothing
    * to append.
    * @private
    */
    this.appendThis = function() {
        
        // Lazy create the frame
        if (!this.frame) {
            this.initialize();
        }
        // If we still don't have something
        var element = this.frame || null;
        return element;
    };

    /**
 * Interface for the Map object to remove the ScaleBar from the DOM.
 * @returns {DOM Element} The DOM element representation of the UI that
 * should be removed from the map object.
 * @private
 */
    this.removeThis = function() {
        
        this.map = null;

        //@todo add any cleanup to this function, should we wish to.

        return this.frame;
    };

    /**
 * Repositions the ShapeDrawingTool relative to the associated Map instance.
 * To be called after the tool has been associated with a Map
 * and usually only needed when the Map has been resized. Part of the general
 * map control interface.
 * @param {DOMDimensions} ddim required Dimenions of map against which to
 * position this control.
 * @private
 */
    this.position = function( ddim ) {
        
        if ( !this.map ) {
            return;
        }
        // Attach to the upper left. We don't actually use the dimensions
        // object
        if (this.frame) {
            
    //this.frame.style.top = "10px";
    //this.frame.style.left = "150px";
            
    }
    };

    this.addSquarePinToMap = function(squarePin){
        squarePin.setPosition(squarePin.position)
        _self.map.getTileDiv().appendChild(squarePin.frame);

    }

    this.removeSquarePinFromMap = function(squarePin){
        if(!squarePin || !squarePin.frame) return;
        _self.map.getTileDiv().removeChild(squarePin.frame);
        squarePin.frame=null;
        

    }

    this.getSquarePins = function(){
        return _squarePins;
    }

    function shapeClickHandler(shape){
        //ADD interner function here before call _shapeClickHandler
        //used when later we want to show pins for modifying shape
        _shapeClickHandler(shape);
    }

    function defaultShapeClickHandler(shape){
        var map=shape.map;
        var centerPix=map.positionToMapLayerPixel(shape.getPosition());
        map.getInfoWindow().setPosition( centerPix.x, centerPix.y );
        //constructInfoWindowContent(shape.getTitle(),shape.getDescription());
        buildAndAddContent(shape);
        //_buildInfoWindowContent(shape);
        map.getInfoWindow().show(shape);
    }

    function buildAndAddContent(shape){
        //var frame=_buildInfoWindowContent(shape);
        var frame=constructInfoWindowContent(shape);
        var map=shape.map;
        //        map.getInfoWindow().bubbleContent.innerHTML="";
        //        map.getInfoWindow().bubbleContent.appendChild(frame);
        //        map.getInfoWindow().setContentSelectable(true);
        //        map.getInfoWindow().resetMapEventIgnorance();
        map.getInfoWindow().setContentSelectable(true);
        map.getInfoWindow().setContent(frame);
    }

    
    function constructInfoWindowContent(shape){
        var map=shape.map;

        var frame=document.createElement("div");
        frame.style.width="100%";
        frame.style.height="100%";
        //initialize infowindow content div
        var titleDiv=document.createElement("div");
        var titleLabel=document.createElement("span");
        titleLabel.className="decarta-drawingToolInfoWin";
        titleLabel.innerHTML="Title      ";
        titleDiv.appendChild(titleLabel);
        var titleInput=document.createElement("input");
        titleInput.type="text";
        //titleInput.value=title?title:"";
        titleInput.value=shape?shape.title:"";
        titleInput.id="titleInput";
        titleInput.size="20";
        titleDiv.appendChild(titleInput);
        //frame.appendChild(titleInput);
        frame.appendChild(titleDiv);
        var descDiv=document.createElement("div");
        descDiv.style.cssText="width:100%;height:100%;overflow:auto;"
        var descLabel=document.createElement("div");
        descLabel.className="decarta-drawingToolInfoWin";
        descLabel.innerHTML="Description";
        descDiv.appendChild(descLabel);
        var descTextarea=document.createElement("textarea");
        //descTextarea.value=desc?desc:"";
        descTextarea.value=shape?shape.description:"";
        descDiv.appendChild(descTextarea);
        frame.appendChild(descDiv);

        var buttonsDiv=document.createElement('div');
        frame.appendChild(buttonsDiv);
        var del=document.createElement("input");
        del.type="button";
        del.value="delete";
        del.onclick= function(){
            map.getInfoWindow().hide();
            map.removeOverlay(shape);
        }
        //frame.appendChild(del);
        buttonsDiv.appendChild(del);

        var save=document.createElement("input");
        save.type="button";
        save.value="save";
        save.onclick= function(){
            if(titleInput.value) titleInput.value=titleInput.value.replace(/^\s*|\s*$/g,"");
            shape.setTitle((titleInput.value)?(titleInput.value):"");
            if(descTextarea.value) descTextarea.value=descTextarea.value.replace(/^\s*|\s*$/g,"");
            shape.setDescription((descTextarea.value)?(descTextarea.value):"");
            
            map.getInfoWindow().hide();
            shape.customProperties.saved=true;
        }
        //frame.appendChild(save);
        buttonsDiv.appendChild(save);

        var cancel=document.createElement("input");
        cancel.type="button";
        cancel.value="cancel";
        cancel.onclick= function(){
            map.getInfoWindow().hide();
            if(shape.customProperties.saved!=true)
                map.removeOverlay(shape)
        }
        //frame.appendChild(cancel);
        buttonsDiv.appendChild(cancel);
  
        return frame;
    }

    function SquarePin(position){
        this.position=position;
        this.frame=null;

        this.frame=document.createElement("DIV");
        this.frame.style.cssText="border:1px solid blue;background-color:white;opacity:50%;z-index:110;position:absolute;width:10px;height:10px;";
        this.frame.squarePin=this;
        this.frame.id="decarta_square_pin "+position.toString();
        var pix=_self.map.positionToMapLayerPixel(this.position);
        this.frame.style.left=pix.x-5+"px";
        this.frame.style.top=pix.y-5+"px";
        this.frame.onclick=squarePinOnclick;

        this.setPosition = function(position){
            this.position=position;
            var pix=_self.map.positionToMapLayerPixel(this.position);
            this.frame.style.left=pix.x-5+"px";
            this.frame.style.top=pix.y-5+"px";
        }
        
        

        this.equals = function(squarePin){
            if(this.position.equals(squarePin.position))
                return true;
            else
                return false;
        }

        
    }

    function clear(removeShape){
        if(_drawTool){
            var src=_drawTool.src;
            src=src.replace(/-selected\.png$/,".png");
            _drawTool.src=src;
        }
        if(_dragTool) _dragTool.src=Credentials.imgPath + "draw-tool-drag-selected.png";
        if(_dropdownMenu) _dropdownMenu.style.display="none";
        _toolName=null;

        for(var i=0;i<_squarePins.length;i++){
            _self.removeSquarePinFromMap(_squarePins[i]);
        }
        if(_dashLine) _self.map.removeOverlay(_dashLine);
        //if(_infoWindow) _infoWindow.hide();
        _self.map.getInfoWindow().hide();

        _dashLine=null;
        _squarePins=[];
        //_self.map.mapDiv.onmousemove=null;
        _self.map.getTilesContainer().onmousemove=null;
        _self.map.getTilesContainer().style.cursor="default";
        //        EventRegistry.clearListeners(_self.map,"click");
        //        EventRegistry.clearListeners(_self.map,"moveend");
        //        EventRegistry.clearListeners(_self.map,"zoomend");

        if(removeShape){
            if(_shape && _shape.customProperties.saved!=true) _self.map.removeOverlay(_shape);
            _shape=null;
        }

        restoreMapEvents();
    }

    
    /**
     * Return the default shapeClickHandler. In case if you want to use this handler in some shapes or other
     * object that's not drawn by this tool.
     */
    this.getDefaultShapeClickHandler = function(){
        return defaultShapeClickHandler;
    }

    /**
     * Set the domView. Only effective before you append this tool to map.
     * @param {boolean} view If false, UI dom will not be constructed and appended.
     */
    this.setDomView = function(view) {
        view = (view) ? true : false;
        this.domView = view;
    };

    /**
     * Show the UI.
     */
    this.show = function(){
        
        if (this.frame) {
            this.frame.style.display="block";
        }
    };

    /**
     * Hide the UI.
     */
    this.hide = function(){
        
        if (this.frame) {
            this.frame.style.display="none";
        }
    };

} /* end ShapeDrawingTool class and constructor */





/**
 * @fileoverview deCarta String utility functions
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @namespace Used for some private string utility functions that I find useful.
 * @description deCarta specific String functions.
 * @private
 */
deCarta.String = {};

/**
 * Boolean string check: it's either a string or a String or it's not.
 * @param {string} potentialString required Something to check for stringiness.
 * @returns {boolean} true if it object is determined to be a JavaScript
 * string, false if object is determined not to be a JavaScript string.
 * @private
 * @static
 */
deCarta.String.isString = function( potentialString ) {
    
    if ( typeof potentialString === 'string' || potentialString instanceof String)
        return true;
    else
        return false;
};


/**
 * Trim the white space off the front and back of a string.
 * Implements a String trim function for JavaScript.
 * @param {string} trimString required String to trim the white space from.
 * @returns {string} The string passed in minus the preceding and trailing
 * whitespace.
 * @private
 * @static
 */
deCarta.String.trim = function(trimString) {
    
    return trimString.replace(/^\s*/, "").replace(/\s*$/, "");
};



/**
 * Trim the white space off the end of a string.
 * Implements a String rtrim function for JavaScript.
 * @param {string} trimString required String to trim the white space from.
 * @returns {string} The string passed in minus the trailing whitespace.
 * @private
 * @static
 */
deCarta.String.rtrim = function(trimString) {
    
    return trimString.replace(/\s*$/, "");
};


/**
 * Trim the white space off the beginning of a string.
 * Implements a String ltrim function for JavaScript.
 * @param {string} trimString required String to trim the white space from.
 * @returns {string} The string passed in minus the preceding whitespace.
 * @private
 * @static
 */
deCarta.String.ltrim = function(trimString) {
    
    return trimString.replace(/^\s*/, "");
};

/**
 * On some browsers, enforcing correct Unicode display can be difficult (e.g.
 * at the time of writing, newer widget run times found on mobile).
 * This black-magic method seems to work quite well cross-browser.
 * @param {string} dirty String to be cleaned up for display in the
 * HTML view.
 * @private
 * @static
 */
deCarta.String.cleanUTF8 = function(dirty) {
    
    // Honestly, I figured out why this enforces correct UTF-8 character display
    // when the original string is supposedly in UTF-8 to begin with, but oh well
    var christinaAguilera = decodeURIComponent(encodeURIComponent(dirty));
    return christinaAguilera;
};


/**
 * @fileoverview Portable StyleSheet for the deCarta.js
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class To aid in portability, and to address backwards compatibility,
 * we will be pulling out the embedded style code from the JS. As the deCarta.js
 * has not ever had an accompanying deCarta.css, we instead have chosen to
 * build the deCarta styles dynamically. Our portable, default styles will be
 * easy to override for those who wish to do so, although we encourage planning
 * and care for anyone who attempts this. The deCarta.js will use a static
 * instance of this class; all overrides should be applied to that object.
 * @description Construct a new deCarta stylesheet. We recommend against creating
 * a custom style class above and beyond what the deCarta.js creates by
 * default. We recommend instead rewriting the style-sheet reference.
 * @see deCarta.StyleManager.cssString
 * @constructor
 * @private
 */
deCarta.StyleManager = {};

/**
 * Signals whether the styles have been added to the page or not.
 * @type boolean
 * @default false
 */
deCarta.StyleManager.stylesCreated = false;

/**
 * A stringified version of the deCarta.css file that will be injected into
 * the page.
 * @type string
 */
deCarta.StyleManager.cssString = "" +

    //---------------------------------------------- begin deCarta.Log */

    /* For use with the default InfoWindow (bubble) "close" div */
    /* ".decarta-close{position:absolute; width:20px; height:20px; top:2px; left:178px; display:block; cursor:pointer;}"+*/
    ".decarta-close{position:absolute; width:20px; height:20px; top:2px; right:2px; display:block; cursor:pointer;}"+
    /* For use with the content of the default InfoWindow (bubble) div */
     ".decarta-bubbleContent{padding:16px;}"+
    /* Style for the default InfoWindow (bubble) container */
     ".decarta-bubble{display:none; width:200px; background-color:#ffffff; filter:alpha(opacity=100); opacity:1; border: 1px solid #cccccc; position:absolute; z-index:10000; color:#000000; font-size:11px;}"+
    /* Style for the copyright message. */
     ".decarta-copyright{background-color:#ffffff; opacity:50; filter:alpha(opacity=80); opacity:0.8; padding:1px; font-family:arial; color:#000000; font-size:11px; border:1px solid #cccccc; display:block; position:absolute; z-index:9999;}"+
    /* Styles for the MapTypeController (chooser to the map object). */
     ".decarta-mapTypeController{background-color:#ffffff; opacity:50; filter:alpha(opacity=80); opacity:0.8; padding:3px; font-family:Arial; color:#000000; font-size:11px; font-weight:bold; border:1px solid #cccccc; display:block; position:absolute; height:14px;width:154px; visibility:visible; z-index:9999;}"+
     ".decarta-mapTypeControllerLink{text-decoration:none;}"+
    /* Style for the default ZoomController zoom in, zoom out, and level buttons (selected and unselected) */
     ".decarta-zoomButton{padding:0; margin:0; display:block;}" +

    /* Style for the ZoomController button container DIV */

//     ".decarta-zoom{cursor: pointer; width: 20px; height:278px;top: 10px; left: 10px; position: absolute; z-index: 9999;}" +
//    ".decarta-zoomTop{margin:0px;padding:0px;position:absolute;left:0px;width:20px;top:0px;height:20px;}" +
//    ".decarta-zoomPillar{margin:0px;padding:0px;position:absolute;left:0px;width:20px;top:20px;height:238px;}" +
//    ".decarta-zoomBottom{margin:0px;padding:0px;position:absolute;left:0px;width:20px;top:258px;height:20px;}" +
//    ".decarta-zoomSlider{maring:0px;padding:0px;position:absolute;left:0px;width:20px;height:14px;}" +


     ".decarta-zoom{cursor: pointer; width: 20px; height:278px;top: 10px; left: 10px; position: absolute; z-index: 9999;}" +
    ".decarta-zoomTop{margin:0px;padding:0px;position:absolute;left:0px;width:20px;top:0px;height:20px;}" +
    ".decarta-zoomPillar{margin:0px;padding:0px;position:absolute;left:0px;width:20px;top:20px;height:170px;}" +
    ".decarta-zoomBottom{margin:0px;padding:0px;position:absolute;left:0px;width:20px;top:190px;height:20px;}" +
    ".decarta-zoomSlider{maring:0px;padding:0px;position:absolute;left:0px;width:20px;height:10px;}" +


    /* Drawing Tool */
    ".decarta-drawingToolMenu{position:absolute;left:31px;top:31px;width:120px;background-color:white;display:none;}" +
    ".decarta-drawingToolMenuItemOn{padding:3px;background-color:#bbb;color:#000;font-size:11px;font-family:arial}" +
    ".decarta-drawingToolMenuItemOff{padding:3px;background-color:#fff;color:#888;font-size:11px;font-family:arial}" +
    ".decarta-drawingToolInfoWin{padding:3px;background-color:#fff;color:#888;font-size:11px;font-family:arial}" +

    /* ScaleBar container and unit display */
     ".decarta-scaleBar{position:absolute; width:120px; text-align:left; z-index:9999;}" +
     ".decarta-scaleBarMeasure{font-family:arial; font-size:8pt; padding:0px 0px 0px 3px; margin:0;}" +
     ".decarta-scaleBarImperialScale{display:block; padding:0; margin:0; font-size:6px; height:6px; border-left:2px solid #000; border-right:2px solid #000; border-bottom:1px solid #000;}" +
     ".decarta-scaleBarMetricScale{display:block; padding:0; margin:0; font-size:6px; height:6px; border-left:2px solid #000; border-right:2px solid #000; border-top:1px solid #000;}" +
    /* Map viewport */
     ".decarta-mapviewport{position:relative; z-index:0; overflow:hidden;}" +
    /* Div containing the actual map tiles. */
     ".decarta-tiles{position:absolute; left:0px; top:0px; z-index:0;}" +
    /* Used with Satellite map tiles */
     ".decarta-maptile{z-index:0; position:absolute; display:none;}"+

    /* for drawing a bbox on the map for zooming */
     ".decarta-bbox-div{border:4px solid #999;position:absolute}"+


    /* Used with Satellite map tiles */
     ".decarta-panController{z-index:100; position:absolute; top:1px; left:1px; height:60px; width:60px; padding:0px; margin:0px; }"+
     ".decarta-panController-north{position:absolute; top:0px; left:20px; height:20px; width:20px; padding:0px; margin:0px; cursor: pointer;}"+
     ".decarta-panController-south{position:absolute; top:40px; left:20px; height:20px; width:20px; padding:0px; margin:0px; cursor: pointer;}"+
     ".decarta-panController-east{position:absolute; top:20px; left:40px; height:20px; width:20px; padding:0px; margin:0px; cursor: pointer;}"+
     ".decarta-panController-west{position:absolute; top:20px; left:0px; height:20px; width:20px; padding:0px; margin:0px;cursor: pointer; }"+
     ".decarta-panController-center{position:absolute; top:20px; left:20px; height:20px; width:20px; padding:0px; margin:0px;cursor: pointer; }"+

     /* Style for map overview */
     ".decarta-mapOverviewController-mapArrayDivWin{position:absolute;border: 1px solid blue;background-color: rgb(102, 102, 204); opacity: 0.4;-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=40)';filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=40);z-index:10020;}"+
     ".decarta-mapOverviewController-mapDivWin{position:absolute;border: 1px solid blue;background-color: rgb(102, 102, 204); opacity: 0.4;-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=40)';filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=40);z-index:10021;}"+
     ".decarta-mapOverviewController-mapDiv{position:absolute;left:0px;top:0px;overflow:hidden;}"+
     ".decarta-mapOverviewController-frame{position:absolute;right:0px;bottom:0px;width:17px;height:17px;z-index:10010;background-color:gray;}"+
     ".decarta-mapOverviewController-mapToggle{position: absolute; right: 0px; bottom: 0px; width: 17px; height: 17px;z-index:10020;}"+
     ".decarta-mapOverviewController-mapToggleImg{position:absolute;left:0px;top:0px;width:17px;height:17px;}"+
     ".decarta-mapOverviewController-mapDivWrapper{position:absolute;left:5px;top:5px;overflow:hidden;}"+
     ".decarta-mapOverviewController-mapArrayDiv{position:absolute; left:0px; top:0px;}"+
    ".decarta-tiles img {-webkit-transform-origin: 0 0 }"+
    ".decarta-tiles img {-webkit-transform: translate3d(0, 0, 0) }"+
    ".decarta-tiles img {-moz-transform: translate3d(0, 0, 0)}"+
    ".decarta-tiles img {-o-transform: translate3d(0, 0, 0)}"+
    
    "";


/**
 * If the deCarta stylesheet has not already been created, inject it into the
 * page.
 */
deCarta.StyleManager.init = function() {
    
    if ( deCarta.StyleManager.stylesCreated ) {
        // already created, do nothing
        return;
    }
    if ( document.styleSheets[0] && document.styleSheets[0].cssText ) {
        // This seems to work the best for IE6+, go figure, it's like innerHTML
        // for stylesheets, additionally IEs always seem to supply us a free
        // stylesheet
        document.styleSheets[0].cssText += deCarta.StyleManager.cssString;
    } else {
        // Work elsewhere
        var style = document.createElement("style");
        style.appendChild(document.createTextNode(deCarta.StyleManager.cssString));
        document.getElementsByTagName("head")[0].appendChild(style);
    }
    // prevent multiple creations
    deCarta.StyleManager.stylesCreated = true;
};

/**
 * Determines the value of a requested style that is currently applied to
 * an element. Will work correctly even if the style hash on the JavaScript
 * object has not been set.
 * Thanks to Quirksblog and dhtmlkitchen.
 * @param {DOM element} el required The DOM element to check the style property
 * for.
 * @param {string} style required The spelling of the CSS classname (e.g.
 * background-color) to check the value of.
 * @reutrns {string} The value of the CSS style as it is currently set on the
 * object.
 * @static
 */
deCarta.StyleManager.getCurrentStyle = function( el, style ) {
    var value = el.style[toCamelCase(style)];

    if(!value) {
        if(document.defaultView) {
            // FF, Opera, Safari(?)
            value = document.defaultView.getComputedStyle(el, "").getPropertyValue(style);
        }
        else if(el.currentStyle) {
            // Internet explorer
            value = el.currentStyle[toCamelCase(style)];
        }
    }
    return value;

    /**
     * Converts a CSS string input to a camel cased version of itself. Needed
     * by IE for CSS name checks.
     * @example
     * toCamelCase("z-index"); // returns zIndex
     * toCamelCase("border-bottom-style"); // returns borderBottomStyle.
     * @param {string} s required The CSS friendly name to convert to IE
     * (and JS) style friendly name.
     * @returns {string} The camel cased CSS name.
     * @inner
     */
    function toCamelCase(s) {
        for(var exp = /-([a-z])/;
            exp.test(s);
            s = s.replace(exp, RegExp.$1.toUpperCase()) );
        return s;
    }
};

/** 
 * @fileoverview TextOverlay
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
 
 // TODO More type checking for the TextOverlay object
 // TODO More cow bell
 
/**
  Construct a new TextOverlay object.
  @class When a {@link Pin} needs to use the same generic {@link Icon} more than
  once on a {@link Map}, it might be desirable to overlay a label on top of the
  Icon. TextOverlay is often used to sequentially a set of Pins from most to 
  least important, and can even be used to label Icons (e.g. "Pizza" labeled on
  top of a generic restaurant Icon).
  <p>The TextOverlay itself is generated on the client side as an HTML div. 
  Therefore, the parameters used to define the TextOverlay should take into 
  consideration the capabilities of the client browser.</p>
  @param {String} text required The actual text string to overlay. Example, "1" 
  or "Pizza".
  @param {int} anchorX required Number of pixels to offset the left edge of the
  div containing the text from the left edge of the Icon on which it is overlaid.
  @param {int} anchorY required Number of pixels to offset the top edge of the 
  div containing the text from the top edge of the Icon on which it is overlaid.
  @param {String} color optional The color in which display the text. Any color,
  formatted as a CSS color value, acceptable by the browser will work. Example,
  'WHITE' or '#FFFFFF' or 'rgb(255,255,255)'. Recommend setting as the default 
  will be chosen by the browser.
  @param {String} size optional The font size in which to display the text. Any
  font size, formatted as a CSS font-size value, acceptable by the browser will
  work. Example, 'medium' or '100%' or '12pt'. Recommend setting as the default
  will be chosen by the browser.
  @param {String} fontFamily optional The font family with which to display the
  text. Any font family, formatted as a CSS font-family value, acceptable by the
  browser will work. Example, 'times' or 'arial' or 'monospace' or 'sans-serif'.
  Recommend setting as the default will be chosen by the browser.
  @param {String} className optional The TextOverlay, when appended to the map,
  is simply a DIV object. To ease styling of the TextOverlay, a class can be
  provided that corresponds to a predefined CSS class definition. Describing
  CSS class selectors is outside of the scope of this document, but for a good 
  reference, please see <a href="http://www.w3schools.com/Css/css_syntax.asp">
  http://www.w3schools.com/Css/css_syntax.asp</a>.
  @see Pin
  @see Icon
  @constructor
 */
function TextOverlay( text, anchorX, anchorY, color, size, fontFamily, className ) {
    
    
    /** @private */
    this.text = text || "";
    /** @private */
    this.anchorX = anchorX || 0;
    /** @private */
    this.anchorY = anchorY || 0;
    /** @private */
    this.color = color || null;
    /** @private */
    this.size = size || null;
    /** @private */
    this.fontFamily = fontFamily || null;
    /** @private */
    this.className = className || null;
    
    /**
      Concatenates the text, X anchor, Y anchor, font size, font family, 
      and class name fields, in that order and returns that string.
      @return {String} The TextOverlay object as a single, space-delimited, 
      unpunctuated, string.
     */
    this.toString = function(){
         return this.text + " " + this.anchorX + " " + this.anchorY + " " + 
             this.size + " " + this.fontFamily + " " + this.className;
    }
 }
 
 
 
 /**
  Retrieve the number of pixels to offset the left edge of the div containing 
  the text from the left edge of the Icon on which it is overlaid. To reset the
  number of pixels offset, use {@link TextOverlay#setAnchorX}.
  @return {int} Number of pixels to offset the left edge of the div containing
  the text from the left edge of the Icon on which it is overlaid.
  @see TextOverlay#setAnchorX
  */
 TextOverlay.prototype.getAnchorX = function(){
     
     return this.anchorX;
 };
 /**
  Retrieve the number of pixels to offset the top edge of the div containing 
  the text from the top edge of the Icon on which it is overlaid. To reset the 
  number of pixels offset, use {@link TextOverlay#setAnchorY}.
  @return {int} Number of pixels to offset the top edge of the div containing 
  the text from the top edge of the Icon on which it is overlaid.
  @see TextOverlay#setAnchorY
  */
 TextOverlay.prototype.getAnchorY = function(){
     
     return this.anchorY;
 };
 /**
  Retrieve the actual text string to overlay. To change the text, use 
  {@link TextOverlay#setText}.
  @return {String} The text overlay.
  @see TextOverlay#setText
  */
 TextOverlay.prototype.getText = function(){
     
     return this.text;
 };
 /**
  * Retrieve the class attribute used for CSS styling.
  * To change the CSS class attribute, use {@link TextOverlay#setClassName}.
  * @return {String} The CSS class attribute.
  * @see TextOverlay#setText
  */
 TextOverlay.prototype.getClassName = function() {
     
     return this.className;
 };
 /**
  Retrieve the font color in which to display the text. To change the font 
  color, use {@link TextOverlay#setColor}.
  @return {String} The font color.
  @see TextOverlay#setText
  */
 TextOverlay.prototype.getColor = function(){
     
     return this.color;
 };
 /**
  Retrieve the font size in which to display the text. To change the font size,
  use {@link TextOverlay#setSize}.
  @return {String} The font size.
  @see TextOverlay#setSize
  */
 TextOverlay.prototype.getSize = function(){
     
     return this.size;
 };
 /**
  Retrieve the font family in which to display the text. To change the font 
  family, use {@link TextOverlay#setFontFamily}.
  @return {String} The font family.
  @see TextOverlay#setFontFamily
  */
 TextOverlay.prototype.getFontFamily = function(){
     
     return this.fontFamily;
 };
 /**
  Set a new x anchor for the div containing the text.
  @param {int} anchorX required Number of pixels to offset the left edge of the
  div containing the text from the left edge of the Icon on which it is overlaid.
  */
 TextOverlay.prototype.setAnchorX = function(anchorX){
     
     this.anchorX = anchorX;
 };
 /**
  Set a new y anchor for the div containing the text.
  @param {int} anchorY required Number of pixels to offset the top edge of the
  div containing the text from the top edge of the Icon on which it is overlaid.
  */
 TextOverlay.prototype.setAnchorY = function(anchorY){
     
     this.anchorY=anchorY;
 };
 /**
  Set a new text string to be used as the text overlaid.
  @param {String} text required The actual text string to overlay. Example, "1"
  or "Pizza".
  */
 TextOverlay.prototype.setText = function(text){
     
     this.text=text;
 };
 /**
  * Sets a new CSS class name used to style this TextOverlay.
  * To have an effect, the class name provided to this instance of the 
  * TextOverlay must already be defined in an external or internal CSS 
  * stylesheet.
  * @param {String} className required The class name to apply to this
  * TextOverlay. As with general CSS styling, multiple, space delimited
  * class names me be passed within the string of the single argument.
  */
 TextOverlay.prototype.setClassName = function(className) {
     
     this.className = className;
 };
 /**
  Set a new color in which to display the text.
  @param {String} color required Any color, formatted as a CSS color value, 
  acceptable by the browser will work. Example, 'WHITE' or '#FFFFFF' or 
  'rgb(255,255,255)'.
  */
 TextOverlay.prototype.setColor = function(color){
     
     this.color=color;
 };
 /**
  Set a new font size in which to display the text.
  @param {String} size required Any font size, formatted as a CSS font-size 
  value, acceptable by the browser will work. Example, 'medium' or '100%' or 
  '12pt'.
  */
 TextOverlay.prototype.setSize = function(size){
     
     this.size=size;
 };
 /**
  Set a new font family in which to display the text.
  @param {String} fontFamily required Any font family, formatted as a CSS 
  font-family value, acceptable by the browser will work. Example, 'times' or 
  'arial' or 'monospace' or 'sans-serif'.
  */  
 TextOverlay.prototype.setFontFamily = function(fontFamily){
     
     this.fontFamily=fontFamily;
 };
 

/** 
  * TrafficIncident
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
/**
 * @class Instances of the TrafficIncident class are created by a successful
 * TrafficIncidentQuery. They describe traffic alerts for a specific location,
 * anything from accidents to road work. The underlying DDS Web Services
 * performs the calculations necessary to slow down, or alter, routes around an
 * incident. TrafficIncidents are provided to help aid users in visualizing why
 * traffic is bad in a specific area.
 * <p><b>NOTE:</b> Traffic queries should only be made against DDS Web Services
 * that are hosting traffic data.</p>
 * @description Construct a new TrafficIncident object.
 * @param {Position} position required The latitude and longitude coordinate at
 * which this incident occurs.
 * @param {String} description optional A human understandable description of
 * this incident.
 * @param {String} severity optional Severity of the incident.
 * @constructor
 * @see TrafficIncidentQuery
 * @see Credentials#trafficEnabled
 */
function TrafficIncident(position,description,severity) {
    
    /**
     * The latitude and longitude coordinate at which this incident occurs.
     * @type Position
     */
    this.position = position;
    /**
     * A human understandable description of this incident.
     * @type string
     * @default ""
     */
    this.description = description || "";
    /**
     * The severity of the incident.
     * @type string
     * @default ""
     */
    this.severity = severity || "";
    /**
       Concatenates the position and description fields, in that order and returns that string.
       @return {String} the TrafficIncident object as a single, space-delimited, unpunctuated, string.
     */
    this.toString = function(){
        return this.position+"  "+this.description;
    };
}


/**
  * @fileoverview TrafficIncidentQuery
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */

/**
 * @class Traffic feeds usually provide two specific types of information. One
 * type of information is called flow data. Flow data impacts the speed of a
 * specific road. The DDS Web Services automatically integrates flow data, when
 * available, and uses it to alter the time, and even the path, of a calculated
 * route. The other type of traffic information is purely informative, and is
 * referred to as incident information. Traffic incidents can be turned into a
 * {@link Pin} and overlaid on a {@link Map} to describe why the traffic is bad
 * in a certain area. Traffic incidents are gathered from the traffic feed, and
 * are not always available.
 * NOTE: Traffic queries should only be made against DDS Web Services that are
 * hosting traffic data.
 * @description Construct a new TrafficIncidentQuery object.
 * @see TrafficIncident
 * @see TrafficIncidentSearchCriteria
 * @constructor
 */
function TrafficIncidentQuery() {
    
    
    /** @private */
    this.xmlRecFac	   = new deCarta.XMLStringBuilder();
    /** @private */
    var _xmlRequestDOM = null;
    /** @private */
    var _callBackArray = [];
    /** @private */
    var self = this;


    /**
     * Authenticate the TrafficIncidentQuery. If you have already authenticated
     * another object, or have manually set the authentication fields of the
     * Credentials object, you do not have to use this function.
     * @param {String} clientName required Set with the clientName authentication token.
     * @param {String} clientPassword required Set with the clientPassword authentication token.
     * @throws {Exception} "Error authenticating TrafficIncidentQuery, invalid parameters."
     * @see Credentials
     */
    this.authenticate = function(clientName,clientPassword){
        
        if( !clientName || !clientPassword ){
            throw new Exception("Error authenticating TrafficIncidentQuery, invalid parameters.");
        }
        Credentials.clientName = clientName;
        Credentials.clientPassword = clientPassword;
        // 4.4.1
        this.xmlRecFac.clientName = clientName;
        this.xmlRecFac.clientPassword = clientPassword;
    };

    /**
     * Search the traffic feed data for incidents. The incidents returned must
     * match the specifications defined by the provided
     * {@link TrafficIncidentSearchCriteria}.
     * <p>Calling this function makes an asynchronous request to the DDS Web
     * Services. To handle the TrafficIncidents returned by a successful search,
     * the application should provide a callBack function that has the following
     * prototype:</p>
     * <p><code>function callBack(arrayTrafficIncidents)</code></p>
     * <p>where</p>
     * <ul>
     * <li>callBack = Arbitrary function name</li>
     * <li>arrayPOIs = The found TrafficIncidents returned within an Array, or
     * null if there was a search error.</li>
     * </ul>
     * <p>If no POIs are found that match the TrafficIncidentSearchCriteria,
     * the callBack function will be passed an empty array</p>
     * @param {TrafficIncidentSearchCriteria} searchCriteria
     * TrafficIncidents returned must match these constraints.
     * @param {function} callBack A function to catch, and handle, the
     * array of TrafficIncidents found.
     * @param {function} [timeoutCallback] Function to be called in case this
     * particular query times out.
     * @throws {Exception} If a function is not passed in as a callBack.
     * @see TrafficIncidentSearchCriteria
     * @see TrafficIncident
     */
    this.query = function(searchCriteria, callBack, timeoutCallback){
        
        var reqId = Utilities.getRequestId();
        if ( typeof callBack == 'function' ) {
            _callBackArray[reqId] = callBack;
        } else {
            throw new Exception("TrafficIncidentQuery.query: callBack must be a function, arg was: " + callBack );
        }
        _xmlRequestDOM = this.xmlRecFac.createTrafficIncidentRequest(searchCriteria, reqId);
        JSRequest.send(_xmlRequestDOM,self.queryCallback, null, timeoutCallback);
    };
    /**
     * Handle the request returned from the server.
     * @private
     */
    this.queryCallback = function(data) {
        

        var trafficList = [];
        var reqId = data.XLS.Response.requestID;
        if ( deCarta.JSONParser.parseErrors(data) ) {
            // Skips the next step, forcing an empty array to be returned
        }
        else {
            var incidents = data.XLS.Response.TrafficResponse.Incident;
            var numIncidents = incidents.length;
            // Handle the fact we might get an object OR an array back
            if ( !numIncidents ) {
                // Must have a single Incident xls message object back
                trafficList.push(new TrafficIncident(new Position(incidents.Position),incidents.Description, incidents.severity));
            }
            else {
                // Must have an array of objects
                for(var i=0; i < incidents.length; i++) {
                    var inc = incidents[i];
                    trafficList.push(new TrafficIncident(new Position(inc.Position),inc.Description, inc.severity));
                }
            }
        }
        if ( (reqId >= 0) && _callBackArray[reqId] ) {
            _callBackArray[reqId](trafficList);
            _callBackArray[reqId] = undefined;
        }
    };
}


/** 
  * TrafficIncidentSearchCriteria
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */

/**
 * @class Used by the {@link TrafficIncidentQuery}, TrafficIncidentSearchCriteria
 * defines what sort of incidents are retrieved during a search. An instance of
 * this class defines where incidents should be searched for, how many incidents
 * should be returned, and the severity of the incidents to look for.
 * <b>NOTE:</b> Traffic queries should only be made against DDS Web Services
 * that are hosting traffic data.
 * @description Construct a new TrafficIncidentSearchCriteria object.
 * @param {Position} position required The center point to search from.
 * @param {Radius} radius required How far to search from the center point. Incidents outside of the search radius will not be returned.
 * @param {int} maximumResponses required The maximum number of incidents to return, cannot exceed 100.
 * @param {int} minimumSeverity optional 1-5, 1 being the least severe, 5 being the most severe. Defaults to 1 (all) incidents returned.
 * @see TrafficIncidentQuery
 * @see TrafficIncident
 * @constructor
 */
function TrafficIncidentSearchCriteria(position,radius,maximumResponses,minimumSeverity) {
    
    
    if(maximumResponses>100){
        throw new Exception("maximumResponses cannot exceed 100");
    }
    /**
     * The center point to search from.
     * @type Position
     */
    this.position = position.clone(); // defensive copying, in case we get a malleable obj.position
    /**
     * How far to search from the center point. Incidents outside of the search
     * radius will not be returned.
     * @type Radius
     */
    this.radius = radius;
    /**
     * The maximum number of incidents to return, cannot exceed 100.
     * @type int
     */
    this.maximumResponses = maximumResponses;
    /**
     * The minimum severity of incident to return. 1-5, 1 being the least
     * severe, 5 being the most severe.
     * @type int
     */
    this.minimumSeverity = minimumSeverity;
}


/**
 * @fileoverview Unit of Measure - KM M MI FT
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */

/**
 * @class The Unit of Measure (UOM) class is used by other classes where the 
 * units of distance are not explicitly defined.
 * @description Construct a new UOM object.
 * @param {String} value required The unit of measure. "KM" for kilometers, "M" 
 * for meters, "MI" for miles, and "FT" for feet.
 * @constructor
 */
function UOM(value) {
    
    
    /*
     * <enumeration value="KM"/>
     * <enumeration value="M"/>
     * <enumeration value="DM"/>
     * <enumeration value="MI"/>
     * <enumeration value="YD"/>
     * <enumeration value="FT"/>
     */
    if(value!="KM" && value!="M" && value!="MI" && value!="FT"){
        throw new Exception("invalid UOM type,  KM M MI FT");
    }	
    /** 
     * The Unit of Measure specified for this object.
     * @type String 
     */
    this.value = value;
    /**
     * Return the units defined by this UOM.
     * @return {String} The UOM value as a string.
     */
    this.toString = function(){
        return this.value;
    };
}


/** 
 * @fileoverview Static, general utility functions.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */



/**
 * @namespace Utilities is a conglomeration of various utility functions used 
 * by the deCarta JavaScript API that, due to their usefulness in select 
 * circumstances, have been made public.
 * @description The Utilities namespace.
 */
function Utilities() {}



/**
 * Earth radius in meters.
 **/

Utilities.EARTH_RADIUS_METERS = 6371000.000000; 

/** 
 * Generates a regular expression that can be used to find all white space.
 * Use this regular expression along with another to search for all white
 * space and replace with something else.
 * @example
 * // a simple way to find all spaces in a string and replace with a comma.
 * var string=string.replace(Utilities.regx2,",");
 * @private 
 * @type string
 */
Utilities.regx2 = new RegExp("\\s", "g");

/**
 * Searches an XLS string for the requestID attribute, if it exists, and
 * returns it.
 * Function relies on the fact that one unique requestID should be found in
 * all JSAPI requests.
 * @param {String} xlsString The serialized XLS message
 * @return {string|null} Returns the requestID or null if the request ID cannot
 * be found.
 * @private
 */
Utilities.parseRequestIDFromXLS = function(xlsString) {
    var reqIdRegEx = /requestID=[\'\"]([0-9]+)/;
    var regExResults = reqIdRegEx.exec(xlsString);
    var requestID = null;
    if ( regExResults && regExResults[1] ) {
        requestID = regExResults[1];
    }
    return requestID;
};

/**
 * Determines whether or not a JavaScript object is empty or not.
 * @param {object} obj Object to check.
 * @return {boolean} true if the object is empty, false if not.
 * Certain derived objects (like string primitives) will return true.
 * @private
 */
Utilities.isObjectEmpty = function(obj) {
    var result = true;
    for ( var i in obj ) {
        if ( obj.hasOwnProperty(i) ) {
            result = false;
            break;
        }
    }
    return result;
};

// remove KML tools
/** Converts kml string from OpenSearchQuery into an array of KML instances. 
 *  This currently only understands Placemarks with geometry types of point, 
 *  line, polygon, and multigeometry (which must be made up of points, lines, 
 *  or polygons). 
 * @param {String} kml
 * @return {Array} array of KML instances
 * @see KML
 */
Utilities.parseKML = function(kml){

    var regx = new RegExp("&", "g");
    kml = kml.replace(regx," ")
    regx = new RegExp("<kml xmlns=");
    kml = kml.replace(regx,"<kml xmlns:goog=");
    var kmls = [];

    var oDomDoc = (new DOMParser()).parseFromString(kml, "text/xml");
			
    oDomDoc.setProperty("SelectionLanguage", "XPath");
    oDomDoc.setProperty("SelectionNamespaces", "xmlns:goog='http://earth.google.com/kml/2.2' xmlns:atom='http://www.w3.org/2005/Atom'");
			
    var placemark = oDomDoc.selectNodes("//Placemark");

    for(var i=0; i<placemark.length;i++){
        //Utilities.p(i)
        var name;
        var desc;
        var geometry;
        for(var ii=0; ii<placemark[i].childNodes.length;ii++){
            try{
                // Name
                if(placemark[i].childNodes[ii].nodeName=="name")
                    name=Sarissa.getText(placemark[i].childNodes[ii]) || ""; // or empty string
                // description
                if(placemark[i].childNodes[ii].nodeName=="description")
                    desc=Sarissa.getText(placemark[i].childNodes[ii]) || ""; // or empty string
                // Point
                if(placemark[i].childNodes[ii].nodeName=="Point"){
                    var point=Utilities.parseKMLCoords(placemark[i].childNodes[ii].childNodes);
                    geometry=new KMLGeometry("Point",point[0]);
                }
                // Polygon
                if(placemark[i].childNodes[ii].nodeName=="Polygon"){
                    var polygon=Utilities.parseKMLCoords(placemark[i].childNodes[ii].childNodes);
                    geometry=new KMLGeometry("Polygon",polygon);
                }
                // LineString
                if(placemark[i].childNodes[ii].nodeName=="LineString"){
                    var line=Utilities.parseKMLCoords(placemark[i].childNodes[ii].childNodes);
                    geometry=new KMLGeometry("LineString",line);
                }
                // MultiGeometry
                if(placemark[i].childNodes[ii].nodeName=="MultiGeometry"){
                    var multi=Utilities.parseKMLMultiGeometry(placemark[i].childNodes[ii].childNodes);
                    //Utilities.p("multi[0].type  "+multi[0].type)
                    geometry=new KMLGeometry("MultiGeometry",multi);
                }
            }catch(e){
                //Utilities.p("error in parser "+e.message)
                continue;
            }
        }
        if(geometry){
            //Utilities.p(i+" if "+geometry.coordinates)
            kmls.push(new KML(geometry,name,desc));
            geometry=undefined;	
            name="";
            desc="";
        } else {
    //Utilities.p(i+" else "+geometry)
    }
    }				
    return kmls;
};



/** 
 * @private
 */
Utilities.parseKMLMultiGeometry = function(dom){
    var arr=[];
    for(var i=0; i<dom.length; i++){
        var type=dom[i].nodeName;
        var geo=Utilities.parseKMLCoords(dom[i].childNodes);
        arr.push(new KMLGeometry(type,geo));
    }
    return arr;
};

/** 
 * recursive algorithm outside closure 
 * @private 
 */
Utilities.parseKMLCoords = function(dom){
    var positions=[];
    var kml;
    recur(dom);
    function recur(dom){
        for(var i=0;i<dom.length;i++){
            if(dom[i].nodeName=="coordinates"){
                var string=Sarissa.getText(dom[i])
                var string=string.replace(Utilities.regx2,",");
                var coords=string.split(",");
                var check=0;	
                var lat,lon;
                for(var i=0;i<coords.length;i++){
                    if(check==0){
                        //Utilities.p("lon "+coords[i])
                        lon=coords[i];
                        check++;
                        continue;
                    }else if(check==1){
                        //Utilities.p("lat "+coords[i])
                        lat=coords[i];
                        positions.push(new Position(lat,lon));
                        check++;
                        continue;
                    }else if (check==2){
                        check=0;
                        continue;
                    }
                }
                //kml=new KMLGeometry("Polygon",positions);
                kml=positions;
                break;
            } else {
                if(dom[i].childNodes.length){
                    recur(dom[i].childNodes);
                }	
            }	
        }
    }
    return kml;
};
// end removal of KML tools


/** 
 * A browser agnostic getElementByTagName function.
 * A getElementByTagName that works with safari and namespaced tags.
 * @private 
 * @param {String} dom required The document to search through.
 * @param {String} namespace required The namespace prefix for the XML tags.
 * @param {String} tag required The element tag name to search for.
 * @return {DOM} returns the results of a getElementsByTagName call appropriate
 * for the client browser.
 */
Utilities.getElementByTagName = function(dom,namespace,tag){
    // Used in a couple of places
    var nsTag = namespace+":"+tag;
    var el;
    if (navigator.userAgent.toLowerCase().indexOf("safari") > -1) {
        // This is not future proof, but the need for this will disappear in 442
        // Safari 4, complicated by the need to support previous Safaris, has
        // some weird quirks try to use getElementsByTagNameNS first...
        el = dom.getElementsByTagNameNS('*', tag)[0];
        // ...but for some lame reason, this will fail sometimes...
        if (!el) {
            // ...and if it does fail, then fall back and whip out the hacktastic!
            var elems = dom.getElementsByTagName('*');
            var numElems = elems.length;
            for ( var i = 0; i < numElems; i++ ) {
                if ( elems[i].nodeName == nsTag ) {
                    el = elems[i];
                    break;
                }
            }
        }
    }
    else {
        // Everything else
        el = dom.getElementsByTagName(nsTag)[0];
    }
    return el;
};
		


/** 
 * Output the correct CSS suffix for use with pixels.
 * @private 
 * @return {string} Returns the string "px".
 */
Utilities.px="px";



/** 
 * Convert an array of coordinates to a VR7 construct.
 * Aids in the tedious conversion of nicely organized array of Position
 * coordinates into a vector string, a VR7, that can be consumed by the
 * Drill Down Server. For more information on VR7, please see the DDS user
 * manual.
 * @private
 * @param {Array} positions required An array of Position coordinates to be
 * converted into the VR7. There really should be at least 2 coordinates
 * for a spec VR7, you can probably get away with 1 coordinate, and it is not
 * advisable to send an empty VR7 to the DDS.
 * @return {String} Retuns the string of coordinates that would immediately
 * follow the "VR7=" string in a DDS query.
 */
Utilities.LL2VR7 = function(positions){
    var posPrev = positions[0];
    var tenMil=10000000;
    var vr = (positions.length)+","+(positions[0].lat* tenMil)+","+(positions[0].lon* tenMil);
    for(var i=1;i<positions.length;i++){
        var vr1 =  Math.round((positions[i].lat - posPrev.lat) * tenMil);
        var vr2 =  Math.round((positions[i].lon - posPrev.lon) * tenMil);
        posPrev=positions[i];
        vr+=","+vr1+","+vr2;
    }
    return vr;
};



/**
 * Provides a simple and useful object for timing procedures.
 * @example
 * //Usage:
 * var timer = new Utilities.timer();
 * timer.start();
 * ... call procedures, do things, wash the dishes ...
 * var timeSurpassed = timer.stop();
 * ... compare timeSurpassed with something else, slap yourself high 5 ...
 * @private
 * @return {number} the number of milliseconds elapsed since .green was called
 * is returned with a call to .red
 */
Utilities.timer = function(){
    this.green = null;
    this.red = null;
    this.start = function(){
        this.green=new Date().getTime();
    }
    this.stop = function(){
        this.red=new Date().getTime();
        return this.red - this.green;
    }
};

/**
 * Is 'true' if the browser is Internet Explorer, 'false' if it is not.
 * Yes, browser sniffing is bad, but only if you use it irresponsibly.
 * @type Boolean
 */
Utilities.ie = '\v'=='v';
/**
 * Is 'true' if the browser is Internet Explorer 6, 'false' if it is not.
 * Yes, browser sniffing is bad, but only if you use it irresponsibly.
 * @type Boolean
 */
Utilities.ie6 = (document.all && !window.opera && (typeof document.documentElement.style.maxHeight == "undefined")) ? true : false;

/**
 * Makes PNG image transparency display correctly in IE 6.
 * Make sure to only pass PNGs into this function, as this function has no
 * error detection.
 * @param {HTML IMG} img An html img element.
 */
Utilities.fixPng = function(img) {
    if (img.src){
        var src = img.src;
        if(img.style.height && img.style.width){
            img.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + src + "', sizingMethod='scale')";
        } else{
            img.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + src + "')";
        }
        // Drop in the transparent image
        img.src = Credentials.transparentGIF;
    } else if (img.style.backgroundImage){
        //in case it's a div with a bg'
        var src = img.style.backgroundImage.replace('url(', 'src=\''); //"img/double-left.png");
        src = src.replace(')', '\'');
        img.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader ("+src +  "')";
        img.style.backgroundImage = '';
      

    }
};



/**
 * Retrieve the scrollTop property of the DOM. 
 * @return {int} How far the top edge of the DOM window has been scrolled down 
 * the page, in pixels.
 */
Utilities.getScrollTop = function(){
    var _scrollTop=0; 
    if (document.documentElement && document.documentElement.scrollTop){
        _scrollTop=document.documentElement.scrollTop; 
    }else if (document.body && document.body.scrollTop){
        _scrollTop=document.body.scrollTop; 
    }
    return parseInt(_scrollTop);
};



/**
 * Retrieve the scrollLeft property of the DOM.
 * @return {int} int How far the left edge of the DOM window has been scrolled 
 * to the right across the page, in pixels.
 */
Utilities.getScrollLeft = function(){
    var _scrollLeft=0; 
    if (document.documentElement && document.documentElement.scrollLeft){
        _scrollLeft=document.documentElement.scrollLeft; 
    }else if (document.body && document.body.scrollLeft){
        _scrollLeft=document.body.scrollLeft; 
    }
    return parseInt(_scrollLeft);
};



/**
 * Used to parse dates in the P0DT0H0M0S string format. These date strings are 
 * returned by the DDS Web Services. If calls are being made directly to the DDS
 * Web Services, this can be used to translate quickly translate the time format
 * into a useful description.
 * @param {String} pod - required
 * @return {String} The P0DT0H0M0S format written out as a single, human 
 * understandable string.
 * @see WSXMLTunnel
 */
Utilities.podParse = function(pod){
    var days    = parseInt(pod.substring(pod.indexOf('P')+1,pod.indexOf('D')));//days
    var hours   = parseInt(pod.substring(pod.indexOf('T')+1,pod.indexOf('H')));//hours
    var minutes = parseInt(pod.substring(pod.indexOf('H')+1,pod.indexOf('M')));//minutes
    var seconds = parseInt(pod.substring(pod.indexOf('M')+1,pod.indexOf('S')));//seconds
    if (days > 0) 	
        return ((days*24)+hours) + ' hours ' + minutes + ' minutes ';
    else if (hours > 0) 	
        return hours + ' hours ' + minutes + ' minutes ';
    else if (minutes > 0)  	
        return  minutes + ' minutes ' + seconds + ' seconds ';
    else 
        return  seconds + ' seconds';
};
/**
 * returns object in format: {days:d,hours:h,minutes:m,seconds:s}.
 * @param {String} pod - required
 * @return {Object} returns object in format: {days:d,hours:h,minutes:m,seconds:s}.
 * @see WSXMLTunnel
 */
Utilities.podParseJSON = function(pod){
    var d    = parseInt(pod.substring(pod.indexOf('P')+1,pod.indexOf('D')));//days
    var h   = parseInt(pod.substring(pod.indexOf('T')+1,pod.indexOf('H')));//hours
    var m = parseInt(pod.substring(pod.indexOf('H')+1,pod.indexOf('M')));//minutes
    var s = parseInt(pod.substring(pod.indexOf('M')+1,pod.indexOf('S')));//seconds
    return {
        days:d,
        hours:h,
        minutes:m,
        seconds:s
    };
};



/**
 * Turns an XML Document Object into into displayable HTML. Converts angled 
 * brackets into special character references (&gt; and &gt;) and wraps it in 
 * PRE tags, preserving the identation.
 * @param {XMLDocument} oDomDoc required The XML Document to serialize.
 * @return {String} The browser viewable XML Document.
 */
Utilities.htmlizeXMLDom = function(oDomDoc){
    var regx1 = new RegExp("\\>", "g");
    var regx2 = new RegExp("\\<", "g");
    var xmlS  = (Sarissa.serialize(oDomDoc));
    xmlS = xmlS.replace(regx1,"&gt;");
    xmlS = xmlS.replace(regx2,"&lt;");
    return "<PRE>"+xmlS+"</PRE>";
};



/**
 * Creates a textarea element dynamically and prints diagnostic text or HTML output 
 * to it. The first call creates the div html and inserts the first amount of 
 * text. Each additional call appends the text passed in as the argument. The 
 * div will appear in the upper right of the browser window. This function now
 * points to deCarta.log.
 * @private
 * @param {String} txt Diagnostic string to display in the window.
 * @deprecated use deCarta.log
 */
Utilities.p = function(txt) {
    
};

/**
 * Clears a console output div created by Utilities.p. This function now passes
 * the clear command to deCarta.log.
 * @private
 * @deprecated use deCarta.log
 */
Utilities.c = function(){
    
};



/**
 * This is a client side generalizer which takes an array of Position Objects 
 * and throws away redundant Positions according to the zoom scale and line 
 * width you are rendering.  This will speed up the client side drawing 
 * considerably.
 * @param {Array} list required Array of Position types
 * @param {ZoomController or number} zoom required The zoom controller attached to
 * the map object to generalize against OR the integer zoom level at which
 * to generalize, usually gained via the ZoomController method getZoomLevel.
 * @param {int} lineWidth required 
 * @param {int} tileSize required The length, in pixels, of the side of one
 * square map tile.
 * @returns {Array} Minimal Array of Position types to draw with at this
 * zoom level.
 * @see Position
 */
Utilities.generalize = function(list, zoom, lineWidth, tileSize){
    
    //var timer  = new Utilities.timer();
    //timer.start();
    lineWidth = Math.round(lineWidth/2);

    // We allow the deCarta zoom level to be passed in, or the older style
    // of passing in a ZoomController
    var zoomLevel = zoom.getZoomLevel ? zoom.getZoomLevel() : zoom;
    var sl = Utilities.radsPerPixelAtZoomLevel(tileSize, zoomLevel);
    var len = list.length;
    var newList=[];
    var bbox,ulatpix,ulonpix,llatpix,llonpix,upper,lower;
    for(var i=0; i<len; i++){
        if(i==0  || !bbox.contains(list[i])){
				
            ulatpix = Utilities.lat2pix(list[i].lat,sl)+lineWidth;
            ulonpix = Utilities.lon2pix(list[i].lon,sl)+lineWidth;
            llatpix = Utilities.lat2pix(list[i].lat,sl)-lineWidth;
            llonpix = Utilities.lon2pix(list[i].lon,sl)-lineWidth;
					
            upper = Utilities.pix2lat(ulatpix,sl)+" "+Utilities.pix2lon(ulonpix,sl);
            lower = Utilities.pix2lat(llatpix,sl)+" "+Utilities.pix2lon(llonpix,sl);
            bbox = new BoundingBox(new Position(lower),new Position(upper));

            newList.push(list[i]);
            continue; 					
        }
    }
    //Utilities.p("STOP converted "+len+" to "+newList.length+" points in "+timer.stop()+" ms");
    return newList;
};

/**
 * Group a list of Position objects for non-overlapping display on a map.
 * Like the generalizer, this function is designed to reduce the clutter on
 * a map. The difference between the grouper and the generalizer is that this
 * function:<br/>
 * Returns an array of arrays. The first element of the main array is the
 * group representative. Each element of the main array contains an array, the
 * length of which determines the number of items grouped at the location
 * of the first item.<br/>
 * No points are thrown out, all points are returned and grouped. The idea
 * is to reuse this function at each zoom level to regroup the data, as
 * desired.<br />
 * Each Position passed in is checked against any other positions already
 * on the group "stack." If the position falls within the radius of one of
 * the groups, it is added to the group (aka. pushed onto the array). If not
 * the position starts a new group.<br/>
 * When all positions have been grouped, the entire array of arrays will
 * be returned. The first element in the first position of each sub-array
 * will contain the ideal location on which to pin the map.<br/>
 * Note: given the radius of the groups is quite literal, if a Position would
 * be even one pixel outside of a group, it will form a new group. Group areas
 * can overlap, so it is a good idea to make the pixel radius of a group
 * larger than the icon that will eventually represent it on the map.
 * @param {Array} posArray required An array of Position objects to group.
 * Positions within this array will not be altered.
 * @param {ZoomController or number} zoom required The zoom controller attached to
 * the map object to group against OR the integer zoom level at which
 * to generalize, usually gained via the ZoomController method getZoomLevel.
 * @param {integer} radius required The number of screen pixels to use as a
 * capture area for any new group. Must be at least 1 pixel.
 * @param {int} tileSize required The length, in pixels, of the side of one
 * square map tile.
 * @throws {Exception} If posArray, zoom or radius are not valid, we throw.
 * @returns {Array} an array of arrays of Positions grouped by screen pixels
 * at the current zoom level. 
 */
Utilities.grouper = function( posArray, zoom, radius, tileSize ) {
    
    
    // Idiot check
    if ( !posArray || !zoom || radius <= 0 ) {
        throw new Exception ("Utilities.grouper: Invalid input " +
            "posArray: " + posArray + " zoom: " + zoom + " radius: " + radius);
    }
    
    // DEBUG
    //Utilities.p("START<br/>");
    //var timer  = new Utilities.timer();
    //timer.start();
    
    // Figure out the conversion of pixels to degrees,
    // working with either the ZoomController or the zoom integer
    var zoomLevel = zoom.getZoomLevel ? zoom.getZoomLevel() : zoom;
    var sl = Utilities.radsPerPixelAtZoomLevel(tileSize, zoomLevel);
    
    // Nunber of positions we need to deal with
    var numPos = posArray.length;
    
    // DEBUG
    //Utilities.p( "Num of positions to process: " + numPos + "<br/>" );
    
    // Our construction variables
    // ulatpix and ulonpix: the upper Mercator pixel location of the bounding
    // box, and they will be reconverted to...
    // upper: the Position coordinates of the upper right corner of the bounding
    // box.
    // llatpix, llonpix and lower: make up the lower left corner
    // of the bounding box, much as the upper corner is made.
    // bbox: Formed as a new BoundingBox from the upper and lower Position
    // variables. This new bounding box will form the new grouping.
    var bbox, ulatpix, ulonpix, llatpix, llonpix, upper, lower;
    // All group areas go into our group stack, and correspond to the group
    // index in our list to return
    var groupBBoxes = [];
    // A bit clunky, but for accuracy we should push the true center of
    // the group on last, so we store the position here for now.
    var groupBBoxCenters = [];
    // And finally our current number of groups
    var numGroups = 0;
    
    // loop counter variables
    var i, j;

    // And finally our value to return
    var groupedList = [];

    for ( i = 0; i < numPos; i++ ) {
        
        // Check if the point is within a group
        for ( j = 0; j < numGroups; j++ ) {
            // Group the first opportunity
            if ( groupBBoxes[j].contains( posArray[i] ) ) {
                groupedList[j].push( posArray[i] );
                break;
            }
        }
        // If this fails, than this point has been successfully added to a
        // group and we should move on. This also takes care of our
        // corner case i == 0
        if ( j != numGroups ) {
            continue;
        }
        else {
            // We need to make a new group from this point
            ulatpix = Utilities.lat2pix( posArray[i].lat, sl) + radius;
            ulonpix = Utilities.lon2pix( posArray[i].lon, sl) + radius;
            llatpix = Utilities.lat2pix( posArray[i].lat, sl) - radius;
            llonpix = Utilities.lon2pix( posArray[i].lon, sl) - radius;
					
            upper = Utilities.pix2lat( ulatpix, sl ) + " " + Utilities.pix2lon( ulonpix, sl );
            lower = Utilities.pix2lat( llatpix, sl ) + " " + Utilities.pix2lon( llonpix, sl );

            bbox = new BoundingBox( new Position(lower), new Position(upper) );

            // We gots ourselves a new box - Fra-gee-lay. That must be Italian.
            groupBBoxes[numGroups] = bbox;
            groupBBoxCenters[numGroups] = posArray[i];
            groupedList[numGroups] = [];
            // I'm sure this will potentially be a problem in the future, and
            // this is the warning about it, but maybe not
            numGroups++;
            continue;
        }
    }
    
    // Finally, we need to push the box centers onto the array
    for ( i = 0; i < numGroups; i++ ) {
        groupedList[i].push( groupBBoxCenters[i] );
    }
    
    // DEBUG 
    //Utilities.p( "STOP converted to " + groupedList.length + " groups in " + timer.stop() + " ms<br/>" );
    //var finalCount = 0;
    //for ( i = 0; i < groupedList.length; i++ ) {
    //    finalCount += groupedList[i].length;
    //}
    //Utilities.p( "Number of total points: " + finalCount );
        
    return groupedList;    
};

/**
 * An interface for the {@link Utilities.grouper} function that provides for
 * sorting of an array of objects by their named "position" property. Useful
 * for sorting various positioned map objects, like {@link Pin} and {@link POI}
 * without needing to separate these objects from their associated Positions.
 * @static
 * @param {Array} objArray required An array of objects to group.
 * All objects must contain a poperty named "position" of type Position or
 * operation will fail. Original array, and objects in array, will not be
 * changed.
 * @param {ZoomController or number} zoom required The zoom controller attached to
 * the map object to group against OR the integer zoom level at which
 * to generalize, usually gained via the ZoomController method getZoomLevel.
 * @param {integer} radius required The number of screen pixels to use as a
 * capture area for any new group. Must be at least 1 pixel.
 * @param {int} tileSize required The length, in pixels, of the side of one
 * square map tile.
 * @throws {Exception} If objArray, zoom or radius are not valid.
 * @returns {Array} an array of arrays of Objects grouped by screen pixels
 * at the current zoom level.
 * @see Position
 * @see Utilities.grouper
 */
Utilities.groupObjByPosition = function( objArray, zoom, radius, tileSize ) {
    

    var i, j;               // counter
    var numElems, numSubElems;        // array length
    var posArray = [];   // temporary position clones, passed to Utilities.grouper
    var gt = "gTag";     // Used as a backpointer from position copy to associated object
    var groupedPosArray; // catches return from Utilities.grouper
    var resultObjArray;  // final array containing objects
    
    // Sanity check, assume if one object has a position, they all do
    // Also check to make sure that the Position prototype has not somehow started using gTag
    if ( !objArray || !objArray[0].position || !zoom || radius <= 0 || !tileSize || Position.prototype[gt] ) {
        throw new Exception ("Utilities.groupObjByPosition: Invalid input " + "objArray: " + objArray + " zoom: " + zoom + " radius: " + radius + " tileSize: " + tileSize );
    }

    // Make copies of all of the associated positions
    numElems = objArray.length;
    for ( i = 0; i < numElems; i++ ) {
        posArray[i] = objArray[i].position.clone();
        // associate object with position, for future sorting
        posArray[i][gt] = objArray[i];
    }

    // Sort the positions, pass through other params
    groupedPosArray = Utilities.grouper(posArray, zoom, radius, tileSize );

    // Sort objects into their groups
    resultObjArray = [];
    numElems = groupedPosArray.length;
    for ( i = 0; i < numElems; i++ ) {
        // We'll need a new sub-array for each grouping
        resultObjArray[i] = [];
        numSubElems = groupedPosArray[i].length;
        for ( j = 0; j < numSubElems; j++ ) {
            // Push the back-referenced objects into the correct grouped order
            // no need to kill the back reference after this function exits
            // since we used cloned positions to group with
            resultObjArray[i][j] = groupedPosArray[i][j][gt];
        }
    }

    // Objects re-ordered into a new array of arrays.
    return resultObjArray;
};

/**
 * Generates a long random number. This can be used where you need to create a 
 * short-term unique id. Because this uses the Math.random() function to 
 * generate the random number, it is unlikely, albeit possible, that the same 
 * number may be repeated over a long enough stretch of time.
 * @return {Float} A random number, between 0 and 9,999,999.
 */
Utilities.getRequestId = function(){
    return Math.floor(Math.random()*10000000); 
};



/**
 * Determine the absolute left of a DOM element.
 * @param {object} obj required DOM element.
 * @return {int} int The absolute left, in pixels, of the DOM element.
 */
Utilities.getAbsoluteLeft = function(obj) {
    var left = obj.offsetLeft;
    var parent = obj.offsetParent;
    while (parent != null) {
        left += parent.offsetLeft;
        parent = parent.offsetParent;
    }
    return left;
};



/**
 * Determine the absolute top of a DOM element.
 * @param {object} obj required DOM element.
 * @return {int} int The absolute top, in pixels, of the DOM element.
 */
Utilities.getAbsoluteTop = function(obj) {
    var top = obj.offsetTop;
    var parent = obj.offsetParent;
    while (parent != null) {
        top += parent.offsetTop;
        parent = parent.offsetParent;
    }
    return top;
};

Utilities.getOffsetFromAncestor = function(obj, ancestor){
    var top = 0;
    var left = 0;
    var parent = obj.offsetParent;
    while (parent != null && parent!=ancestor) {
        top += parent.offsetTop;
        left += parent.offsetLeft;
        parent = parent.offsetParent;
    }
    
    return {"left":left,"top":top};
}



/**
 * This function frees memory used by map.  This should be called when the map
 * page unloads.
 * @param {Map} map required Map object to free.
 */
Utilities.unloadMap= function(map){
    map.removeAllPins();
    Utilities.purge(map.mapDiv);
};



/**
 * Purge elements from the DOM to claim memory. The purge function takes a 
 * reference to a DOM element as an argument. It loops through the element's 
 * attributes. If it finds any functions, it nulls them out. This breaks the 
 * cycle, allowing memory to be reclaimed. It will also look at all of the 
 * element's descendent elements, and clear out all of their cycles as well. The
 * purge function is harmless on Mozilla and Opera. It is essential on IE. The
 * purge function should be called before removing any element, either by the 
 * removeChild method, or by setting the innerHTML property. 
 * @param {DOMElement} d required DOM object.
 */	
Utilities.purge = function(d) {
    var a = d.attributes, i, l, n;
    if (a) {
        l = a.length;
        for (i = 0; i < l; i += 1) {
            n = a[i].name;
            if (typeof d[n] === 'function') {
                d[n] = null;
            }
        }
    }
    a = d.childNodes;
    if (a) {
        l = a.length;
        for (i = 0; i < l; i += 1) {
            Utilities.purge(d.childNodes[i]);
        }
    }
};



/**
 * Alert message containing a space delimited string of every property on an
 * object.
 * @private
 * @param {Object} obj required The Object to check for properties.
 */
Utilities.what = function(obj){
    var what="";
    for ( var x in obj ) {
        what+="  "+x;
    }
    alert(what);
};



/**
 * Utility function for reorganizing the prefixes from the XML returned from the
 * DDS Web Services.  This is useful when dealing with incrementing 'ns' 
 * (namespace) prefixes. This replaces all the namespace prefixes with either 
 * xls or gml, the namespace name, respectively.
 * @param {String} XMLText required The XML Document to normalize.
 */
Utilities.normalizePrefixes = function(XMLText){
    //self.println("function Utilities.normalizePrefixes()");
    var reg1 = new RegExp("ns1:", "g"); 
    var tmp1 = XMLText.replace(reg1,"xls:");
    var reg2 = new RegExp("ns\\d+:", "g"); 
    var tmp2 = tmp1.replace(reg2,"gml:");  
    var reg3 = new RegExp("\\sxmlns:ns\\d+=\"http://www.opengis.net/gml\"", "g"); 
    var tmp3 = tmp2.replace(reg3,"");  
    var reg4 = new RegExp("xmlns:ns1=\"http://www.opengis.net/xls\"", "g"); 
    var tmp4 = tmp3.replace(reg4,"xmlns:xls=\"http://www.opengis.net/xls\" xmlns:gml=\"http://www.opengis.net/gml\"");  
    return tmp4;
};



/**
 * Convert a Position and radial distance (in kilometers) to a BoundingBox 
 * object. Note: The radius for this function is distance only, it is not an 
 * instance of {@link Radius}.
 * @param {Position} pos required The location to center the BoundingBox.
 * @param {float} radius A distance, in kilometers, describing the radius.
 * @return {BoundingBox} The BoundingBox object described by the input values.
 */    
Utilities.centerContextToBoundingBox = function(pos, radius){
    var degreesofRadius = radius/111.111;
    var degreesofRadiusLon = radius/111.111/Math.cos(((pos.lat*Math.PI)/180));
    var minLon=(pos.lon-parseFloat(degreesofRadiusLon));
    var maxLon=(pos.lon+parseFloat(degreesofRadiusLon));
    //var degreesofLat = degreesofRadius * Math.cos(((pos.lat*Math.PI)/180));
    var degreesofLat = degreesofRadius;
    var minLat=(pos.lat-parseFloat(degreesofLat));
    var maxLat=(pos.lat+parseFloat(degreesofLat));
    return new BoundingBox(new Position(minLat,minLon), new Position(maxLat,maxLon));
};
		


/**
 * Convert a position and planar distances into a bounding box.
 * Create a bounding box from planar dimensions and a center coordinate.
 * @private
 * @param {Position} pos required The center coordinate of the bounding box.
 * @param {Number} radiusX required The x distance (width) in kilometers of the
 * bounding box.
 * @param {Number} radiusY required The y distance (height) in kilometers of the
 * bounding box.
 * @return {BoundingBox} The BoundingBox object described by the input values.
 */    
Utilities.centerContextToBoundingBoxViewable = function(pos, radiusX, radiusY){
		
    //self.println("function Utilities.centerContextToBoundingBoxViewable()");
    // 111.111 km per degree
    var degreesofRadiusX = radiusX/111.111;
    var degreesofRadiusY = radiusY/111.111;
    var minLon=(pos.lon-parseFloat(degreesofRadiusX));
    var maxLon=(pos.lon+parseFloat(degreesofRadiusX));
    var degreesofLatY = degreesofRadiusY * Math.cos(((pos.lat*Math.PI)/180));
    var minLat=(pos.lat-parseFloat(degreesofLatY));
    var maxLat=(pos.lat+parseFloat(degreesofLatY));
    return new BoundingBox(new Position(minLat,minLon), new Position(maxLat,maxLon));
};



/**
 * Given a bounding box, and the length of a side of a square in pixels,
 * this function will convert the input latlon to pixels on the square. 
 * the latlong is space separated, e.g. "37.3798273 -122.38743"
 * @private
 * @param {BoundingBox} bb
 * @param {Position} pos
 * @param {int} pixels
 */
Utilities.latLonToPixels = function(bb,pos,pixels){
    var pixelX = pixels * ((pos.lon- bb.minPosition.lon)/(bb.maxPosition.lon-bb.minPosition.lon));
    var pixelY = pixels * ((bb.maxPosition.lat-pos.lat)/(bb.maxPosition.lat-bb.minPosition.lat));
    return new PixelPoint( Math.round(pixelX), Math.round(pixelY));
};



/** 
 * This utility is a fix for European browsers that represent floats with
 * commas instead of decimals, example: 3,20 instead of 3.20.
 * @private
 * @param {Object} radius required A primitive or object representing a radius.
 * @return {string} The radius value using a decimal instead of a comma.
 */
Utilities.formatRadiusToString = function(radius){
    if (typeof radius == 'number' || typeof radius != 'string')
        radius = radius.toString(); // cast to string
    return radius.replace(new RegExp("\,"),"\.");
};



/**
 * Convert pixel coordinates to latitude and longitude.
 * Mainly used to convert the on-screen coordinates of a mouse click in pixels 
 * to latitude and longitude coordinates.
 * @private
 * @param {number} x required The x (horizontal) pixel value of the on screen
 * coordinates.
 * @param {number} y required The y (vertical) pixel value of the on screen
 * coordinates.
 * @param {number} _centerX required The x (horizontal) pixel coordinate for
 * the map.
 * @param {number} _centerY required The y (vertical) pixel coordinate for
 * the map.
 * @param {number} _tileSize required The distance, in pixels, of the dimensions
 * of a tile. Tiles are always assumed to be square.
 * @param {number} _verticalTiles required The number of vertical tiles that
 * make up the map.
 * @param {Position} cPos required The center Position (latitude and longitude)
 * of the map.
 * @param {number} _presentRadius required The current, approximately estimated,
 * degrees radius of the map in kilometers.
 * @throws {Exception} Throws any exception created by one of the internal
 * function calls inside of an alert box.
 * @return {Position} The on-screen coordinates converted to a latitude, 
 * longitude coordinate.
 */
Utilities.pixelsToLatLon = function(x,y,_centerX,_centerY,_tileSize,_verticalTiles, cPos,_presentRadius){
    //self.println("function Utilities.pixelsToLatLon()");
    try{
        x = _centerX - x;
        y = _centerY - y;
        var cLat = cPos.getLat();
        var cLon = cPos.getLon();
        var _degreesOnMap=(_presentRadius*2)/111.111;
        var _degreesofLatInPixel= _degreesOnMap/(_tileSize*_verticalTiles);
        var _degreesofLonInPixel = (_degreesOnMap/Math.cos(((cLat*Math.PI)/180)))/(_tileSize*_verticalTiles);  
        if(y!=0)
            cLat =""+( parseFloat(cLat)+parseFloat(y*_degreesofLatInPixel));
        if(x!=0)
            cLon =""+( parseFloat(cLon)-parseFloat(x*_degreesofLonInPixel));
        return new Position(cLat,cLon);
    }catch(e){
        throw new Exception(e.message);
    }
};

/**
 * Find the minPos and maxPos indexes for longitue part of bbox
 *@private
 *
 */
Utilities.positionsToBoundingBoxLonSpanIndexes = function(positions){
    if(!positions || positions.length<2)
        throw new Exception("Utilities.positionsToBoundingBox requires at least two positions");
    //first step, sort all points according to lon
    var posArray=[];
    posArray=positions.slice(0);
    sort(posArray);
    //second step, treat this array as circle, find the smallest binding box

    var length=posArray.length;
    var smallestLonSpan=360;
    var minPosIndex=0;
    var maxPosIndex=length-1;
    for(var j=0;j<length;j++){
        maxPosIndex=(length+(j-1)%length)%length;
        var tmpLonSpan=span(posArray[j].lon,posArray[maxPosIndex].lon);
        if(tmpLonSpan<smallestLonSpan){
            smallestLonSpan=tmpLonSpan;
            minPosIndex=j;
        }
    }
    maxPosIndex=(length+(minPosIndex-1)%length)%length;

    var minPosIdx,maxPosIdx;
    for(i=0;i<positions.length;i++){
        if(positions[i]==posArray[minPosIndex]){
            minPosIdx=i;
            break;
        }
    }
    for(i=0;i<positions.length;i++){
        if(positions[i]==posArray[maxPosIndex]){
            maxPosIdx=i;
            break;
        }
    }

    return [minPosIdx,maxPosIdx];

    //calculate the longitude span
    function span(lon1,lon2){
        if(lon1<lon2){
            return lon2-lon1;
        }else
            return lon2+360-lon1;
    }

    //sorting
    function sort(positionArray){

        var i=Math.floor((positionArray.length-1-1)/2);
        for(;i>=0;i--) filterDown(i,positionArray.length-1);
        for(i=positionArray.length-1;i>0;i--){
            var tmp=positionArray[0];
            positionArray[0]=positionArray[i];
            positionArray[i]=tmp;
            filterDown(0,i-1);
        }

        function filterDown(start,end){
            var current=start;
            var child=start*2+1;
            var tmp;
            while(child<=end){
                if(child<end && positionArray[child].lon<positionArray[child+1].lon){
                    child=child+1;
                }
                if(positionArray[current].lon>positionArray[child].lon) {
                    break;
                }else{
                    tmp=positionArray[current];
                    positionArray[current]=positionArray[child];
                    positionArray[child]=tmp;
                    current=child;
                    child=current*2+1;
                }
            }

        }
    }

}

/**
 * Convert an array of Positions to a BoundingBox. The BoundingBox will only be
 * as large as necessary to encompass the Positions. Because of this, certian 
 * positions might exist on the edge or in the corners of the BoundingBox.
 * @param {Array} positions required An Array of at least two Positions to 
 * circumscribe a BoundingBox around.
 * @throws {Exception} Throws an exception if at least two positions are not 
 * passed in the array. 
 * @return {BoundingBox} A rectangle that surrounds the input positions.
 */
Utilities.positionsToBoundingBox = function(positions) {
    //if(!positions || positions.length<2)
        //throw new Exception("Utilities.positionsToBoundingBox requires at least two positions");
    if(!positions || positions.length<1)
        throw new Exception("Utilities.positionsToBoundingBox requires at least one position");
    if(positions.length==1){
        return new BoundingBox(positions[0],positions[0]);
    }
    //first step, get the minLon and maxLon
    var lonIdxes=Utilities.positionsToBoundingBoxLonSpanIndexes(positions);
    var minLon=positions[lonIdxes[0]].lon;
    var maxLon=positions[lonIdxes[1]].lon;
    //now we get the minLat and maxLat
    var minLat=90;
    var maxLat=-90;
    for(var j=0;j<positions.length;j++){
        if(positions[j].lat<minLat) minLat=positions[j].lat;
        if(positions[j].lat>maxLat) maxLat=positions[j].lat;
    }

    return new BoundingBox(new Position(minLat,minLon),new Position(maxLat,maxLon));

}


/**
 * Convert an array of Pins to a BoundingBox. The BoundingBox will be as large
 * as necessary to encompass the Icon associated with the Pin.
 * @param {Array} pins required An Array of at least two Pins to
 * circumscribe a BoundingBox around.
 * @param {int} scale required Scale at which to approximate the the icon pixel
 * x/y dimensions to lat/lon offsets.
 * @throws {Exception} Throws an exception if at least two Pins are not
 * passed in the array. 
 * @return {BoundingBox} A rectangle that surrounds the input Pins.
 */
Utilities.pinsToBoundingBox = function( pins, scale ) {
    
    if ( !scale ) {
        throw new Exception("Utilities.pinsToBoundingBox requires a scale argument");
    }
    if ( !pins || pins.length < 2 ) {
        throw new Exception("Utilities.pinsToBoundingBox requires at least two pins");
    }

    var posArray=[];
    for(var i=0;i<pins.length;i++) posArray[i]=pins[i].getPosition();
    var lonIdxes=Utilities.positionsToBoundingBoxLonSpanIndexes(posArray);
    var minLonPinBbox = pins[lonIdxes[0]].getViewableBoundingBox( scale );
    var minLon=minLonPinBbox.minPosition.lon;
    var maxLonPinBbox = pins[lonIdxes[1]].getViewableBoundingBox( scale );
    var maxLon=maxLonPinBbox.maxPosition.lon;

    var minLat=90;
    var maxLat=-90;
    for(i=0;i<pins.length;i++){
        var pinBoundary = pins[i].getViewableBoundingBox( scale );
        if(pinBoundary.minPosition.lat<minLat){
            minLat=pinBoundary.minPosition.lat;
        }
        if(pinBoundary.maxPosition.lat>maxLat){
            maxLat=pinBoundary.maxPosition.lat;
        }
    }

    return new BoundingBox(new Position(minLat,minLon),new Position(maxLat,maxLon));

}

/** 
 * Determine the number of pixels between two latitudes at a zoom level.
 * @private
 * @param {number} lat1 required The first latitude.
 * @param {number} lat2 required The second latitude.
 * @param {ZoomController} zoom required The ZoomController used for the current
 * map.
 * @param {int} tileSize required The length, in pixels, of the side of one
 * square map tile. As a convenience to those who might already be using this
 * function, tileSize can be ignored and a value of GLOBALS.DEFAULT_MAP_TILE_SIZE
 * will be assumed.
 * @return {number} Absolute integer value of number of pixels between the
 * latitude arguments.
 */
Utilities.pixYDist = function(lat1, lat2, zoom, tileSize) {
    // This is okay, as zero is not valid
    if ( !tileSize ) {
        tileSize = GLOBALS.DEFAULT_MAP_TILE_SIZE;
    }
    var zl = zoom.getGXConvertedZoomLevel();
    var sl =  Utilities.radsPerPixelAtZoom(tileSize, zl);
    var p1 = Math.round(Utilities.lat2pix(lat1,sl));
    var p2 = Math.round(Utilities.lat2pix(lat2,sl));
    return Math.abs(p1 - p2);
};



/** 
 * Determine the number of pixels between two longitudes at a zoom level.
 * @private
 * @param {number} lon1 required The first longitude.
 * @param {number} lon2 required The second longitude.
 * @param {ZoomController} zoom required The ZoomController used for the current
 * map.
 * @param {int} tileSize required The length, in pixels, of the side of one
 * square map tile. As a convenience to those who might already be using this
 * function, tileSize can be ignored and a value of GLOBALS.DEFAULT_MAP_TILE_SIZE
 * will be assumed.
 * @return {number} Absolute integer value of number of pixels between the
 * longitude arguments.
 */
Utilities.pixXDist= function(lon1, lon2, zoom, tileSize) {
    // This is okay, as zero is not valid
    if ( !tileSize ) {
        tileSize = GLOBALS.DEFAULT_MAP_TILE_SIZE
    }
    var zl = zoom.getGXConvertedZoomLevel();
    var sl = Utilities.radsPerPixelAtZoom(tileSize, zl);
    var p1 = Math.round(Utilities.lon2pix(lon1,sl));
    var p2 = Math.round(Utilities.lon2pix(lon2,sl));
    return Math.abs(p1 - p2);
};



/** 
  This function will return the Mercator Pixel value for a given latitude and 
  scale level. You can get the current scale level with the following lines of 
  code:
  <p><code>var scaleLevel = zoom.getGXConvertedZoomLevel();</code></p>
  <p><code>var scale = Utilities.radsPerPixelAtZoom(map.getTileSize(), scaleLevel);</code></p>
  <p>Note: getGXConvertedZoomLevel() map.getTileSize() are undocumented function 
  of the ZoomController and Map classes, only for use with these Utilities 
  functions.</p>
  @param {String} lat required The decimal latitude value.
  @param {int} scale required The results of the code above used to calculate 
  the scale.
  @return {float} The calculated Mercator Pixel.
 */
/*Utilities.lat2pix= function(lat, scale){
    var radLat = (parseFloat(lat)*(2*Math.PI))/360;
    var ecc = 0.08181919084262157;
    //var ecc = 0.998434489;
			
    //			if(radLat>0.9999) radLat = 0.9999;
    //			else if (radLat<-0.9999) radLat = -0.9999;
    var sinPhi = Math.sin(radLat);
    var eSinPhi = ecc * sinPhi;
			
    var retVal = Math.log(((1.0 + sinPhi) / (1.0 - sinPhi)) *
        Math.pow((1.0 - eSinPhi) / (1.0 + eSinPhi), ecc)) / 2.0;
    return (retVal / scale);
};
*/


/** 
  This function will return the Mercator Pixel value for a given longitude and 
  scale level. You can get the current scale level with the following lines of 
  code:
  <p><code>var scaleLevel = zoom.getGXConvertedZoomLevel();</code></p>
  <p><code>var scale = Utilities.radsPerPixelAtZoom(map.getTileSize(), scaleLevel);</code></p>
  <p>Note: getGXConvertedZoomLevel() map.getTileSize() are undocumented function 
  of the ZoomController and Map classes, only for use with these Utilities 
  functions.</p>
  @param {String} lon required The decimal longitude value.
  @param {int} scale required The results of the code above used to calculate 
  the scale.
  @return {float} The calculated Mercator Pixel.
 */
Utilities.lon2pix= function(lon, scale){
    return ((lon/180)*Math.PI) / scale;
};
		


/**
 * Compute the radians per pixel at the zoom level.
 * @param {int} tileSize required The number of pixels per width or height of the
 * tile, and should be retrieved using a map.getTileSize() call.
 * Note: getTileSize() is an undocumented function of the 
 * Map class, only for use with these Utilities functions.
 * @param {int} gxZoom required The value returned from zoom.getGXConvertedZoomLevel().
 * Note: getGXConvertedZoomLevel() is an undocumented function of the 
 * ZoomController class, only for use with these Utilities functions.
 * @return {int} Number of radians per pixel.
 * @deprecated Use Utilities.radsPerPixelAtZoomLevel to avoid the getGXConvertedZoomLevel
 * conversion.
 *
 */
Utilities.radsPerPixelAtZoom = function(tileSize,gxZoom) {
    return 2*Math.PI / (tileSize << gxZoom);
};

/**
 * Compute the radians per pixel at a deCarta zoom level.
 * @param {int} tileSize required The number of pixels per width or height of the
 * tile, and should be retrieved using a map.getTileSize() call.
 * Note: getTileSize() is an undocumented function of the
 * Map class, only for use with these Utilities functions.
 * @param {int} zoomLevel required The value returned from zoom.getZoomLevel().
 * @return {int} Number of radians per pixel.
 */
Utilities.radsPerPixelAtZoomLevel = function(tileSize, zoomLevel) {
    // The following is the definition of a "gxZoom"
    var gxZoom = Math.abs(21-zoomLevel);
    return 2*Math.PI / (tileSize << gxZoom);
};

/**
 * Compute a GX Zoom level when needed. This allows deCarta zooms to be passed
 * around inside of deCarta objects, and when necessary, a zoom can be converted
 * to a GX reference.
 * @param {number} zoomLevel required The deCarta zoom level to convert to
 * a GX reference zoom level.
 * @returns {number} the gx referenced zoom level.
 */
Utilities.deCartaToGXZoomLevel = function(zoomLevel) {
    // The following is the definition of a "gxZoom"
    var gxZoom = Math.abs(21 - parseInt(zoomLevel, 10));
    return gxZoom;
};

/** 
  This function will return the longitude for a given Mercator Pixel and scale 
  level. You can get the scale level with the following lines of code: 
  <p><code>var scaleLevel = zoom.getGXConvertedZoomLevel();</code></p>
  <p><code>var scale = Utilities.radsPerPixelAtZoom(map.getTileSize(), scaleLevel);</code></p>
  <p>Note: getGXConvertedZoomLevel() map.getTileSize() are undocumented function 
  of the ZoomController and Map classes, only for use with these Utilities 
  functions.</p>
  @param {int} x required The x value of the pixel coordinate to translate.
  @param {int} scale required The results of the code above used to calculate 
  the scale.
  @return {float} The calculated longitude.
 */
Utilities.pix2lon = function(x, scale) {
    return (x * scale)*180/Math.PI;
};



/** 
  This function will return the latitude for a given Mercator Pixel and scale 
  level. You can get the scale level with the following lines of code: 
  <p><code>var scaleLevel = zoom.getGXConvertedZoomLevel();</code></p>
  <p><code>var scale = Utilities.radsPerPixelAtZoom(map.getTileSize(), scaleLevel);</code></p>
  <p>Note: getGXConvertedZoomLevel() map.getTileSize() are undocumented function 
  of the ZoomController and Map classes, only for use with these Utilities 
  functions.</p>
  @param {int} y required The y value of the pixel coordinate to translate.
  @param {int} scale required The results of the code above used to calculate 
  the scale.
  @return {float} The calculated latitude.
 */
/*Utilities.pix2lat = function(y, scale) {
    var phiEpsilon = 1E-7;
    var phiMaxIter = 12;
    var t = Math.pow(Math.E, -y * scale);
    var prevPhi = Utilities.mercatorUnproject(t);
    var newPhi = Utilities.findRadPhi(prevPhi, t);
    var iterCount = 0;
    while ( iterCount < phiMaxIter && 
        Math.abs(prevPhi - newPhi) > phiEpsilon) {
        prevPhi = newPhi;
        newPhi = Utilities.findRadPhi(prevPhi, t);
        iterCount++;
    }
    return newPhi*180/Math.PI;
};*/



/** 
 * Unprojects a screen coordinate y value into a latitude, or phi, value.
 * @private
 * @param {number} t required In the Gudermannian function, t is the results
 * of (e^y).
 * @returns {number} The unprojected latitude, or phi, value for a current
 * y when t is correctly defined as (e^y).
 */
Utilities.mercatorUnproject = function(t) {
    return (Math.PI / 2) - 2 * Math.atan(t);
};
	     
 
 
/** 
 * Determines a latitude, or phi, in radians. This is a utility function
 * for use with Utilities.pix2lat(), and essentially is used to solve the
 * mercator conversion of screen coordinate y to actual latitude.
 * @private
 * @param {number} phi required The radial approximate latitude for the y
 * coordinate at the current zoom level.
 * @param {number} t required In the Gudermannian function, t is the results
 * of (e^y).
 * @returns {number} A solution for the mercator function when solving for
 * latitude, or phi, from y.
 */
Utilities.findRadPhi = function(phi, t) {
    var ecc = 0.08181919084262157;
    //var ecc = 0.998434489;
    var eSinPhi = ecc * Math.sin(phi);
    return 	(Math.PI / 2) - 
    (2 * Math.atan (t * Math.pow((1 - eSinPhi) / (1 + eSinPhi), ecc / 2)));
};


/**
 * Determines a generalization factor, in meters-per-pixel-horizontal assuming
 * a Mercator Ellipsoidal projection, that can be applied to a route.
 * This generalization factor can be used to tune the number of positions that
 * are returned from a route, decreasing the number of points that need be
 * transported back to the user client.
 * @param {BoundingBox} bbox required A bounding box describing the area to
 * be generalized.
 * @param {integer} zoomLevel required The real zoom level of a map to which
 * we will be generalizing to, equivalent to the range of numbers retrieved
 * via a zoomController.getZoomLevel() call.
 * @returns {float} The meters-per-pixel-horizontal for use to safely generalize 
 * objects within the boundaries described by the bounding box at the
 * request zoom level.
 * @throws {Exception} If the arguments are falsey.
 */
Utilities.generalizationFactor = function( bbox, zoomLevel ) {
    
    if ( !bbox || !zoomLevel || !bbox.minPosition ) {
        throw new Exception("Utilities.generalizationFactor: bad input." +
            "bbox: " + bbox + "zoomLevel: " + zoomLevel );
    }
    
    
    
    // Pre-calculated for included zoom values
    // Values for the meters-per-horizontal-pixel width at the equator
    // Assuming 111,319 meters-per-degree at the equator:
    var baseGeneralizationFactor = [
    0.14916746,  /* ZoomLevel 1  */
    0.298780196,
    0.597003797,
    1.19445287,
    2.388571783, /* ZoomLevel 5  */
    4.777143566,
    9.554287132,
    19.10857426,
    38.21725985,
    76.43440838, /* ZoomLevel 10 */
    152.8688168,
    305.7376335,
    611.475267,
    1222.950534,
    2445.901068, /* ZoomLevel 15 */
    4891.802136,
    9783.604272, /* ZoomLevel 17 */
    19567.20854,
    39134.41709,
    78268.83418,
    156537.6684, /* ZoomLevel 21 */
    313075.3367
    ];
    
    // With the table, the calculation is simple
    // Match the zoom level to the entry in the array
    // Cosine correct to the lowest possible latitude, which would be
    // the location of minimum required meters-per-pixel
    var minRadLat = bbox.minPosition.lat * Math.PI / 180;
    var baseGen = baseGeneralizationFactor[zoomLevel - 1];
    return (  baseGen * Math.cos( minRadLat ) );
};


////////////////////////////////////////////////////////////////////////////////
// BEGIN EVENT UTILITY FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

/**
 * Takes a DOM object and makes it unselectable / unhighlightable. Side effect
 * of this function is that it overrides the onselectstart event (IE) or
 * the style.MozUserSelect (FF).
 * @param {Object} element required The page element to make unselectable.
 * @see Utilities.setSelectable
 */
Utilities.setUnselectable = function( element ) {
    
    // An extra check. This function isn't called overly often, include just
    // in case.
    if ( element ) {
        if ( typeof element.onselectstart != "undefined" ) {
            
            element.onselectstart = function(e) {
                e = e||event;
                var source = e.target || e.srcElement;
                if ( source == "[object Text]" && source.parentNode ) {
                    // fix for safari... selection appears to happen within a TextNode
                    source = source.parentNode;
                }
                // Events that should be selectable will be marked as selectable
                if ( !deCarta.IdManager.checkTag(source, "txtSelectable") ) {
                    return false;
                }
                else {
                    return true;
                }
            }; // end event handler
        }
        else if ( typeof element.style.MozUserSelect != "undefined" ) {
            
            // Allows selective sub element TextNode selection with MozUserSelect="text"
            element.style.MozUserSelect = "-moz-none";
        }
        else {
            
        // Pass through
        }
    }
};

/**
 * Takes a DOM object and makes the text information selectable / highlightable.
 * Side effect of this function is that, for FireFox, it overrides the
 * style.MozUserSelect property.
 * This function should be explicitly run on all nested sub-elements that
 * need to be selectable.
 * @param {Object} element The page element to make selectable. This works
 * under the assumption that all objects associated by the page will have been
 * previously affected by being set to unselectable.
 * @see Utilities.setUnselectable
 */
Utilities.setSelectable = function( element ) {
    
    // An extra check. This function isn't called overly often, include just
    // in case.
    if ( element ) {
        if ( typeof element.onselectstart != "undefined" ) {
            
            deCarta.IdManager.setTag(element, "txtSelectable" );
        }
        else if ( typeof element.style.MozUserSelect != "undefined" ) {
            
            // Allows selective sub element TextNode selection with MozUserSelect="text"
            element.style.MozUserSelect = "text";
        }
        else {
            
        // Pass through
        }
    }
};

////////////////////////////////////////////////////////////////////////////////
// END EVENT UTILITY FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

// don't need the vr conversion utilities within the mobile build
/**
 * Pass in a VR string, returns an array of Positions.
 * @params vrString required Takes a VR string as returned by
 * the DDS. For ease, can include the "%VR=" part of the string or not.
 * @returns {Array} positions that make up the provided VR string.
 * @throws {Exception} if rudimentary error checking fails
 * @static
 */
Utilities.vrToPositions = function( vrString ) {
    

    // Quick sanity checks.
    if ( !vrString ) {
        throw new Exception( "vrToPositions: illegal argument: " + vrString );
    }

    // Chop off the VR keyword if present
    // All VR tokens are comma delimited
    var tokens = vrString.replace(/%[Vv][Rr]=/, "").split(',');
    
    // VRs always begin with how many points make up this polyline. This includes
    // the first absolute point. We remove it from the count (see below for why).
    var numPoints = tokens[0] - 1;
    
    // VRs begin with a latitude and longitude. This also counts as the first
    // point in the polyline
    var rawLat = vrOffsetToFloat(tokens[1]);
    
    var rawLon = vrOffsetToFloat(tokens[2]);
    
    // The remaining tokens are the offsets, and will contain one less
    var offsets = tokens.slice(3);
    
    // Array for our return values, which will take our first position.
    var posArray = [];
    posArray.push ( new Position(rawLat, rawLon) );
    // Counter variables for below
    var i;

    // Operate on one chunk at a time
    for ( i = 0; i < numPoints; i++ ) {
        // Propagate the offset changes forward, reusing our original
        // latitude and longitude
        // The latitude comes first...
        rawLat += vrOffsetToFloat(offsets[0]);
        
        // ...followed by the longitude...
        rawLon += vrOffsetToFloat(offsets[1]);
        
        // ... chop off what we've used so next round works...
        offsets = offsets.slice(2);
        
       
        var pos = new Position( rawLat, rawLon );
        posArray.push( pos );
    }

    return posArray;


    /**
    * Take a standard VR offset string and convert to it's equivalent
    * float. This function enforces 5 digits of precision through rounding.
    * @param {string} offset required The numeric VR offset fragment to
    * convert to a floating point.
    * @inner
    */
    function vrOffsetToFloat( offset ) {
        // Counter Variable
        var i;
        // Check for negativity first
        var isNegative = "";
        if ( offset.toString().charAt(0) == "-" ) {
            isNegative = "-";
            // Chop off the negative
            offset = offset.slice(1);
        }
        // The remaining are just numbers
        offset = offset.toString();
        var offsetLength = offset.length;
        // We'll use these internal to whatever we're doing
        var charArray;

        // This works only because we can count on the fact that standard
        // VRs have 5 digits of precision, no more, no less
        if ( offsetLength <= 5 && offsetLength > 0 ) {
            // We can use the charArray, load from the back end first
            charArray = ["0", "0", "0", "0", "0"];
            // We want the array index length
            var charArrayLength = 5;

            // using lt or eq to make sure to grab all items... reverse counting
            for ( i = 1; i <= offsetLength; i++ ) {
                charArray[ charArrayLength - i ] = offset.charAt( offsetLength - i );
            }
            
            // We've got everthing we need. Return the fractional offset
            // Enforce the 5 digit precision rule
            return (parseFloat(parseFloat( isNegative + "0." + charArray.join("") ).toFixed(5)));
        }
        else if ( offsetLength > 5 ) {
            // We've got a giant offset or the original number. Annoyingly
            // we still need to place that decimal
            charArray = [];
            for ( i = 0; i < offsetLength; i++ ) {
                // Load this one from the front
                charArray.push(offset.charAt(i));
                // We'll load at least one number before needing to check this
                if ( offsetLength - i - 1 == 5 ) {
                    // time to drop that decimal in place
                    charArray.push(".");
                }
            }
            // Enforce the 5 digit precision rule
            return (parseFloat(parseFloat( isNegative + charArray.join("") ).toFixed(5)));
        }
        else {
            // Should never get here. I hate this math enough to put a check here.
            throw new Exception( "vrToPositions failed in vrOffsetToFloat with " + offset );
        }
    } // End inner function. Return value is above.

};


/**
 * Pass in a VR7 string, returns an array of Positions.
 * @params vrString required Takes a VR7 string as returned by
 * the DDS. For ease, can include the "%VR7=" part of the string or not.
 * @returns {Array} positions that make up the provided VR7 string.
 * @throws {Exception} if rudimentary error checking fails
 * @static
 */
Utilities.vr7ToPositions = function( vrString ) {
    

    // Quick sanity checks.
    if ( !vrString ) {
        throw new Exception( "vr7ToPositions: illegal argument: " + vrString );
    }

    // Chop off the VR7 keyword if present
    // All VR tokens are comma delimited
    var tokens = vrString.replace(/%[Vv][Rr]7=/, "").split(',');
    
    // VRs always begin with how many points make up this polyline. This includes
    // the first absolute point. We remove it from the count (see below for why).
    var numPoints = tokens[0] - 1;
    
    // VRs begin with a latitude and longitude. This also counts as the first
    // point in the polyline
    var rawLat = vr7OffsetToFloat(tokens[1]);
    
    var rawLon = vr7OffsetToFloat(tokens[2]);
    
    // The remaining tokens are the offsets, and will contain one less
    var offsets = tokens.slice(3);
    
    // Array for our return values, which will take our first position.
    var posArray = [];
    posArray.push ( new Position(rawLat, rawLon) );
    // Counter variables for below
    var i;

    // Operate on one chunk at a time
    for ( i = 0; i < numPoints; i++ ) {
        // Propagate the offset changes forward, reusing our original
        // latitude and longitude
        // The latitude comes first...
        rawLat += vr7OffsetToFloat(offsets[0]);
        // ...followed by the longitude...
        rawLon += vr7OffsetToFloat(offsets[1]);
        // ... chop off what we've used so next round works...
        offsets = offsets.slice(2);

        var pos = new Position( rawLat, rawLon );
        posArray.push( pos );
    }

    return posArray;


    /**
    * Take a VR7 offset string and convert to it's equivalent
    * float. This function enforces 7 digit of precision through rounding.
    * @param {string} offset required The numeric VR offset fragment to
    * convert to a floating point.
    * @inner
    */
    function vr7OffsetToFloat( offset ) {
        // Counter Variable
        var i;
        // Check for negativity first
        var isNegative = "";
        if ( offset.toString().charAt(0) == "-" ) {
            isNegative = "-";
            // Chop off the negative
            offset = offset.slice(1);
        }
        // The remaining are just numbers
        offset = offset.toString();
        var offsetLength = offset.length;
        // We'll use these internal to whatever we're doing
        var charArray;

        // This works only because we can count on the fact that
        // VR7s have 7 digits of precision, no more, no less
        if ( offsetLength <= 7 && offsetLength > 0 ) {
            // We can use the charArray, load from the back end first
            charArray = ["0", "0", "0", "0", "0", "0", "0"];
            // We want the array index length
            var charArrayLength = 7;

            for ( i = 1; i <= offsetLength; i++ ) {
                charArray[ charArrayLength - i ] = offset.charAt( offsetLength - i );
            }
            // We've got everthing we need. Return the fractional offset
            // Enforce the 7 digit precision rule
            return parseFloat(parseFloat( isNegative + "0." + charArray.join("") ).toFixed(7));
        }
        else if ( offsetLength > 7 ) {
            // We've got a giant offset or the original number. Annoyingly
            // we still need to place that decimal
            charArray = [];
            for ( i = 0; i < offsetLength; i++ ) {
                // Load this one from the front
                charArray.push(offset.charAt(i));
                // We'll load at least one number before needing to check this
                if ( offsetLength - i - 1 == 7 ) {
                    // time to drop that decimal in place
                    charArray.push(".");
                }
            }
            // Enforce the 7 digit precision rule
            return parseFloat(parseFloat( isNegative + charArray.join("") ).toFixed(7));
        }
        else {
            // Should never get here. I hate this math enough to put a check here.
            throw new Exception( "vrToPositions failed in vrOffsetToFloat with " + offset );
        }
    } // End inner function. Return value is above.

};

/**
 * Convert an array of Positions to a standard VR keyword string.
 * Standard VR strings represent a polyline (vector) with 5 decimal points
 * of precision.
 * @param {Array} positions required The array of positions to translate to
 * a VR string.
 * @returns {string} a standard VR keyword string
 * @throws {Exception} if rudimentary error checking fails
 * @static
 */
Utilities.positionsToVr = function( positions ) {
    
    if( !positions && !positions.length ) {
        throw new Exception( "positionsToVr: cannot create empty VR string." );
    }

    // Counter variables
    var i;
    var numPositions = positions.length;
    // VR strings require a strict format
    var vrString = [];
    // The keyword prefix plus number of points which are not comma delimited
    vrString.push( "%VR=" + numPositions );
    // The first position along our string, we'll add the commas in at the end
    // lat always comes before lon
    vrString.push( decimalToVrChunk(positions[0].lat) );
    vrString.push( decimalToVrChunk(positions[0].lon) );
    // Handle the remaining positions as offsets, beginning with the first point
    // and each offset is cumulative
    var lastLat = positions[0].lat;
    var lastLon = positions[0].lon;
    // make sure to skip the first position
    for( i = 1; i < numPositions; i++ ) {
        var offsetLat = positions[i].lat - lastLat;
        vrString.push( decimalToVrChunk(offsetLat) );
        lastLat += offsetLat;
        var offsetLon = positions[i].lon - lastLon;
        vrString.push( decimalToVrChunk(offsetLon) );
        lastLon += offsetLon;
    }

    // Comma delimit everything and we're done
    return vrString.join(",");

    /**
    * Takes a decimal value and returns a chunk suitable for inclusion within
    * a VR string.
    * @param {float} dec required A floating point number to return in VR
    * friendly notation.
    * @returns {string} number converted to a VR friendly string.
    * @inner
    */
    function decimalToVrChunk ( dec ) {
        // Process
        // Assume the worst that we got a string and convert back to float.
        // Retrieve the floating point number with 5 floating digits of precision
        // Convert back to string and remove the decimal if it exists
        // Then return
        var vrChunk = parseFloat(parseFloat(dec).toFixed(5).toString().replace(/\./, "" ));
        return vrChunk;
    }
};

/**
 * Convert an array of Positions to a VR7 keyword string.
 * VR7 strings represent a polyline (vector) with 7 decimal points
 * of precision.
 * @param {Array} positions required The array of positions to translate to
 * a VR7 string.
 * @returns {string} a VR7 keyword string
 * @throws {Exception} if rudimentary error checking fails
 * @static
 */
Utilities.positionsToVr7 = function( positions ) {
    
    if( !positions && !positions.length ) {
        throw new Exception( "positionsToVr7: cannot create empty VR string." );
    }

    // Counter variables
    var i;
    var numPositions = positions.length;
    // VR strings require a strict format
    var vrString = [];
    // The keyword prefix plus number of points which are not comma delimited
    vrString.push( "%VR7=" + numPositions );
    // The first position along our string, we'll add the commas in at the end
    // lat always comes before lon
    vrString.push( decimalToVr7Chunk(positions[0].lat) );
    vrString.push( decimalToVr7Chunk(positions[0].lon) );
    // Handle the remaining positions as offsets, beginning with the first point
    // and each offset is cumulative
    var lastLat = positions[0].lat;
    var lastLon = positions[0].lon;
    // make sure to skip the first position
    for( i = 1; i < numPositions; i++ ) {
        var offsetLat = positions[i].lat - lastLat;
        vrString.push( decimalToVr7Chunk(offsetLat) );
        lastLat += offsetLat;
        var offsetLon = positions[i].lon - lastLon;
        vrString.push( decimalToVr7Chunk(offsetLon) );
        lastLon += offsetLon;
    }

    // Comma delimit everything and we're done
    return vrString.join(",");

    /**
    * Takes a decimal value and returns a chunk suitable for inclusion within
    * a VR7 string.
    * @param {float} dec required A floating point number to return in VR7
    * friendly notation.
    * @returns {string} number converted to a VR friendly string.
    * @inner
    */
    function decimalToVr7Chunk ( dec ) {
        // Process
        // Assume the worst that we got a string and convert back to float.
        // Retrieve the floating point number with 5 floating digits of precision
        // Convert back to string and remove the decimal if it exists
        // Then return
        var vrChunk = parseFloat(parseFloat(dec).toFixed(7).toString().replace(/\./, "" ));
        return vrChunk;
    }
};
// end removal of vr-position converters

/**
 * Calculate the distance between two arbitrary points in KM.
 * @return {Radius} Returns the distance in KM.
 */
Utilities.positions2Distance= function(pos1,pos2){
    var lat1Rad=pos1.lat*Math.PI/180;
    var lat2Rad=pos2.lat*Math.PI/180;
    var lon1Rad=pos1.lon*Math.PI/180;
    var lon2Rad=pos2.lon*Math.PI/180;
    var earthRadius=6366.191;

    //return distance in km
    var d= earthRadius*Math.acos(Math.cos(lat1Rad)*Math.cos(lat2Rad)*Math.cos(lon1Rad-lon2Rad)+Math.sin(lat1Rad)*Math.sin(lat2Rad));
    return new Radius(d,new UOM("KM"));
}

Utilities.positionsAngle = function(pos1, pos2, tileSize){

    if (!tileSize) tileSize = 256;
    
    var scale = Utilities.radsPerPixelAtZoom(tileSize, 21);

    var x1 = Utilities.lon2pix(pos1.lon, scale);
    var y1 = Utilities.lat2pix(pos1.lat, scale);

    var x2 = Utilities.lon2pix(pos2.lon, scale);
    var y2 = Utilities.lat2pix(pos2.lat, scale);

    var angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

    return angle;

}

/**
 * Sets opacity for the specified DOM element
 * @param (HTMLDomElement) elem
 * @param (int) opacity 0 - 100
 */

Utilities.setOpacity = function(elem, opacity){

    var xop = (opacity / 100);    
    var object = elem.style;
    object.opacity = xop;
    object.MozOpacity = (opacity / 100);
    object.KhtmlOpacity = (opacity / 100);
    object.filter = "alpha(opacity=" + opacity + ")";

    return true;
}

/**
 * Simple deep Object.extend
 * @param (dst) Destination object
 * @param (src) Source Object
 * @return modified destination
 */
Utilities.extend = function(dst, src){
    for (var elem in src){
        if (typeof dst[elem] == 'Array' || typeof dst[elem] == 'Object'){
            dst[elem] = Utilities.extend(dst[elem], src[elem]);
        }
        dst[elem] = src[elem];
    }
    return dst;
}

/**
 * Fades an element
 * @param (element) Dom element
 * @param (options) Object with options
 */


Utilities.fade = function(element, options){

    var opt = {
        from: 100,
        to: 0.0,
        duration: 500,
        fps: 10
    };

    opt = Utilities.extend(opt, options);
    
    var opacity = opt.from;
    Utilities.setOpacity(element, opacity);
    var stepSpeed = 1000 / opt.fps;
    var frames = Math.floor(opt.duration / stepSpeed);
    var valueStep = (opt.to - opt.from) / frames;

    var frame = 0;
    function fadeStep(element, opacity, frame){
        frame ++;
        if (frames == frame){
            Utilities.setOpacity(element, opt.to);
            if (typeof opt.onComplete === 'function'){
                opt.onComplete(element);
            }
        } else {
            opacity += valueStep;            
            Utilities.setOpacity(element, opacity);
            setTimeout(function(){fadeStep(element, opacity, frame)}, stepSpeed);
        }
    }
    fadeStep(element, opacity, frame);

}

/* Takes an object and sets the specified css properties on the element */
Utilities.setStyle = function(element, styles){

    var elementStyle = element.style;

    elementStyle.display = 'none';

    for (var property in styles)
      if (property == 'opacity') element.setOpacity(styles[property]);
      else
        elementStyle[(property == 'float' || property == 'cssFloat') ?
          (Object.isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
            property] = styles[property];

    elementStyle.display = 'block';

    return element;

}


Utilities.scope = function(fn, context){

    var slice = Array.prototype.slice;

    function update(array, args) {
        var arrayLength = array.length, length = args.length;
        while (length--) array[arrayLength + length] = args[length];
        return array;
    }

    function merge(array, args) {
        array = slice.call(array, 0);
        return update(array, args);
    }

    if (arguments.length < 2 && (typeof arguments[0] === 'Undefined')) return fn;
    var method = fn;
    var args = slice.call(arguments, 1);
    return function() {
        var a = merge(args, arguments);
        return method.apply(context, a);
    }

}


Utilities.urlParse = function(urlString){
    var result = {};
    var split = urlString.split('#');
    urlString = split[0];
    if (split[1]) result.hash = split[1];    
    split = urlString.split('?');
    result.baseUrl = split[0];
    result.queryParameters = {};
    if(split.length===1){
        return result;
    }
    var queryParameters = split[1].split('&');
    var params = {};
    for (var i = 0; i < queryParameters.length; i++){
        var val = queryParameters[i].split('=');
        params[val[0]] = val[1];
    }	
    result.queryParameters = params;
	
    return result;
}

Utilities.urlCompose = function(urlObj){
	
	var resultUrl = urlObj.baseUrl + '?';
    var first = true;
	var params = urlObj.queryParameters;
	
    for (var param in params){
        if (!first) {
            resultUrl += '&';
        } else {
            first = false
        }
        resultUrl += param + '=' + params[param];
    }
	
	return resultUrl;
}

/**
 * Remove an element and provide a function that inserts it into its original position
 * @param element {Element} The element to be temporarily removed
 * @return {Function} A function that inserts the element into its original position
 **/
Utilities.removeElementToReinsert = function(element){	

	var parentNode = element.parentNode;
	var nextSibling = element.nextSibling;
	parentNode.removeChild(element);
	return function() {
		if (nextSibling) {
			parentNode.insertBefore(element, nextSibling);
		} else {
			parentNode.appendChild(element);
		}
	};
}


Utilities.geolocateConvertPosition = function(position){
    position = position.coords || position;
    var pos = new Position(position.latitude + " " + position.longitude);
    return pos;
}
Utilities.geolocate = function(handleSuccess,handleFailure){
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(handleSuccess,handleFailure);
    } else if (window.google && google.gears) {
        var geo = google.gears.factory.create('beta.geolocation');
        if ( (geo) && (geo.getPermission()) ) {
            geo.getCurrentPosition(handleSuccess,handleFailure);
        }
    } else {
		throw('No geolocation support available');
	}
}
/* ---- NEW SPHERICAL STUFFS -------*/

Utilities.lat2pix = function(lat, scale){
    
    var f = Utilities['lat2pix_' + Credentials.projection.replace(':','')];
    if (!f) {            
        throw('Bad projection in the config! This is extremely bad.');
    }
    return f(lat, scale);
}

Utilities.lat2pix_EPSG3395 = function(lat, scale){

    var radLat = (parseFloat(lat) * (2 * Math.PI))/360;

    var ecc = 0.08181919084262157;

    var sinPhi = Math.sin(radLat);

    var eSinPhi = ecc * sinPhi;

    var retVal = Math.log(((1.0 + sinPhi) / (1.0 - sinPhi)) *
        Math.pow((1.0 - eSinPhi) / (1.0 + eSinPhi), ecc)) / 2.0;

    return (retVal / scale);

}
    
Utilities.lat2pix_EPSG3857 = function(lat, scale){
    
    var radLat = (parseFloat(lat) * (2 * Math.PI))/360; 
    var sinPhi = Math.sin(radLat);
    var retVal = Math.log((1.0 + sinPhi) / (1.0 - sinPhi)) / 2.0;
    return (retVal / scale);
}


/**
    * Given a longitude and a zoom level, returns a pixel value
    * Starting from top left of the world.
    **/
Utilities.lon2pix = function(lon, scale){

    return ((lon / 180) * Math.PI) / scale;
},


/**
    * Given a pixel value and a zoom level, returns the longitude
    */
Utilities.pix2lon = function(x, scale) {
    return (x * scale) * 180 / Math.PI ;
}

/**
    * Given a pixel value and a zoom level, returns the latitude
    */
Utilities.pix2lat = function(y, scale) {
    
    var f = Utilities['pix2lat_' + Credentials.projection.replace(':','')];
    if (!f) {            
        throw('Bad projection in the config! This is extremely bad.');
    }
    return f(y, scale);        
}

Utilities.pix2lat_EPSG3395 = function(y, scale){        

    var phiEpsilon = 1E-7;
    var phiMaxIter = 12;
    var t = Math.pow(Math.E, -y * scale);
    var prevPhi = Utilities.mercatorUnproject(t);
    var newPhi = Utilities.findRadPhi(prevPhi, t);
    var iterCount = 0;
    while ( iterCount < phiMaxIter &&
        Math.abs(prevPhi - newPhi) > phiEpsilon) {
        prevPhi = newPhi;
        newPhi = Utilities.findRadPhi(prevPhi, t);
        iterCount++;
    }
    return newPhi*180/Math.PI;

}
    
Utilities.pix2lat_EPSG3857 = function(y, scale){
    var t = Math.pow(Math.E, -y * scale);
    var phi = Utilities.mercatorUnproject(t);
    return phi*180/Math.PI;

}  


/**
    * Given a position and zoom level, get how many meters per pixels there are
    * @param {deCarta.Core.Position} p
    * @param {float} z the zoom level
    */
Utilities.metersPerPixelAtZoom = function(p, z){
    var C = 156543.04;
    var scale = C * Math.cos(p.lat * (Math.PI / 180)) / (Math.pow(2, z));
    return scale;
}

    /**
	 * @private
	 */
Utilities.mercatorUnproject = function(t) {
    return (Math.PI / 2) - 2 * Math.atan(t);
}

/**
        * @private
        */
Utilities.findRadPhi = function(phi, t) {
    var ecc = 0.08181919084262157;
    //var ecc = 0.998434489;
    var eSinPhi = ecc * Math.sin(phi);
    return 	(Math.PI / 2) -
    (2 * Math.atan (t * Math.pow((1 - eSinPhi) / (1 + eSinPhi), ecc / 2)));
}


/**
 * detect empty object
 */
/* There's a copy of this higher up in the file.
Utilities.isObjectEmpty = function(obj) {
    for(var prop in obj) {
        if(obj.hasOwnProperty(prop))
            return false;
    }
    return true;
}
*/

/*http://paulirish.com/2011/requestanimationframe-for-smart-animating/*/
window.requestAnimFrame = (function(){
    return  window.requestAnimationFrame       || 
            window.webkitRequestAnimationFrame || 
            window.mozRequestAnimationFrame    || 
            window.oRequestAnimationFrame      || 
            window.msRequestAnimationFrame     || 
            function(/* function */ callback, /* DOMElement */ element, time){
            if (!time) time =  1000 / 60;
            window.setTimeout(callback,time);
            };
})();


    
deCarta.Easing = function(type) {

    // define some constants
    var TWO_PI = Math.PI * 2,
        HALF_PI = Math.PI / 2;

    // define some function references
    var abs = Math.abs,
        pow = Math.pow,
        sin = Math.sin,
        asin = Math.asin,
        cos = Math.cos;

    var s = 1.70158;


    var easingFns = {
        linear: function(t, b, c, d) {
            return c*t/d + b;
        },

        backin: function(t, b, c, d) {
            return c*(t/=d)*t*((s+1)*t - s) + b;
        },

        backout: function(t, b, c, d) {
            return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
        },

        //this one is broken.
        backinout: function(t, b, c, d) {
            return ((t/=d/2)<1) ? c/2*(t*t*(((s*=(1.525))+1)*t-s))+b : c/2*((t-=2)*t*(((s*=(1.525))+1)*t+s)+2)+b;
        },

        bouncein: function(t, b, c, d) {
            return c - easingFns.bounceout(d-t, 0, c, d) + b;
        },

        bounceout: function(t, b, c, d) {
            if ((t/=d) < (1/2.75)) {
                return c*(7.5625*t*t) + b;
            } else if (t < (2/2.75)) {
                return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b;
            } else if (t < (2.5/2.75)) {
                return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b;
            } else {
                return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b;
            }
        },

        bounceinout: function(t, b, c, d) {
            if (t < d/2) return easingFns.bouncein(t*2, 0, c, d) / 2 + b;
            else return easingFns.bounceout(t*2-d, 0, c, d) / 2 + c/2 + b;
        },

        cubicin: function(t, b, c, d) {
            return c*(t/=d)*t*t + b;
        },

        cubicout: function(t, b, c, d) {
            return c*((t=t/d-1)*t*t + 1) + b;
        },

        cubicinout: function(t, b, c, d) {
            if ((t/=d/2) < 1) return c/2*t*t*t + b;
            return c/2*((t-=2)*t*t + 2) + b;
        },

        elasticin: function(t, b, c, d, a, p) {
            var s;

            if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*0.3;
            if (!a || a < abs(c)) { a=c; s=p/4; }
            else s = p/TWO_PI * asin (c/a);
            return -(a*pow(2,10*(t-=1)) * sin( (t*d-s)*TWO_PI/p )) + b;
        },

        elasticout: function(t, b, c, d, a, p) {
            var s;

            if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*0.3;
            if (!a || a < abs(c)) { a=c; s=p/4; }
            else s = p/TWO_PI * asin (c/a);
            return (a*pow(2,-10*t) * sin( (t*d-s)*TWO_PI/p ) + c + b);
        },

        elasticinout: function(t, b, c, d, a, p) {
            var s;

            if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(0.3*1.5);
            if (!a || a < abs(c)) { a=c; s=p/4; }
            else s = p/TWO_PI * asin (c/a);
            if (t < 1) return -0.5*(a*pow(2,10*(t-=1)) * sin( (t*d-s)*TWO_PI/p )) + b;
            return a*pow(2,-10*(t-=1)) * sin( (t*d-s)*TWO_PI/p )*0.5 + c + b;
        },

        quadin: function(t, b, c, d) {
            return c*(t/=d)*t + b;
        },

        quadout: function(t, b, c, d) {
            return -c *(t/=d)*(t-2) + b;
        },

        quadinout: function(t, b, c, d) {
            if ((t/=d/2) < 1) return c/2*t*t + b;
            return -c/2 * ((--t)*(t-2) - 1) + b;
        },

        sinein: function(t, b, c, d) {
            return -c * cos(t/d * HALF_PI) + c + b;
        },

        sineout: function(t, b, c, d) {
            return c * sin(t/d * HALF_PI) + b;
        },

        sineinout: function(t, b, c, d) {
            return -c/2 * (cos(Math.PI*t/d) - 1) + b;
        }
    }

    return (easingFns[type]) ? easingFns[type] : easingFns['linear'];

}
 
/**
  * @fileoverview WSXMLTunnel
  * deCarta confidential and proprietary.
  * Copyright 2006-2012 deCarta. All rights reserved.
  */
  
/**
 * @class The WSXMLTunnel is used for making direct XML requests to the DDS Web 
 * Services. This deCarta JavaScript API communicates with the DDS Web Services 
 * in the background, sending and receiving requests for everything from map 
 * tiles to geocodes and routes. The WSXMLTunnel allows a pathway to communicate 
 * with the DDS Web Services should the need arise to do so. A common need is
 * where the DDS Web Services provides some new, or obscure, functionality that 
 * you need right away.
 * <p>To use the WSXMLTunnel, you need to create an XMLDocument, form a DDS Web 
 * Services request, and pass it through the send function along with a callBack 
 * to handle XMLDocument response from the server.</p>
 * <p>The DDS Web Services requests are described in greater detail in the DDS 
 * Web Services documentation. A live copy of the documentation is always 
 * available on the <a href="http://developer.decarta.com">deCarta Developer 
 * Zone</a></p>
 * @description Construct a new WSXMLTunnel object.
 * @constructor
 */
function WSXMLTunnel() {
    

    // Self awareness
    var self = this;

    /**
     * Set the response format for our request.
     * As of 442, the only valid values for the responseFormat parameter
     * that will work are "JSON" and "XML".
     * Recommend not changing this property while requests are in progress.
     * @type string
     * @default "XML"
     */
    this.responseFormat = "XML";

    /**
     * Callback function storage for response handling.
     * @private
     * @type Array
     */
    var _callBackArray = [];
    

    /**
     * Send a DDS Web Services request and catch the response.
     * Calling this function makes an asynchronous request to the DDS Web 
     * Services. To handle the results, the application should provide a 
     * callBack function that has the following prototype:
     * <p><code>function callBack(xmlDoc)</code></p>
     * <p>where</p>
     * <ul>
     * <li>callBack = Arbitrary function name</li>
     * <li>xmlDoc = An XML Document object representing the response of this 
     * query</li>
     * </ul>
     * @param {string|XMLDocument} xml required The XLS query to send to the
     * web services. XLS message can be in XML document format or can be a
     * string.
     * @param {function} callBack required A callBack function that accepts an XML
     * Document object as a parameter. If Sarissa is not associated with this
     * deCarta.js library, an XML string will be passed back.
     * @throws {Exception} If a function is not passed in as a callBack, or
     * if this version of the JSAPI does not have Sarissa associated with it and
     * we are not passed the XLS message as a string.
     */
    this.send = function(xml, callBack){
        

        if ( !deCarta.String.isString(xml) ) {
            if ( !window.Sarissa && !window.Sarissa.serialize ) {
                throw new Exception("Sarissa is required to use the WSXMLTunnel with XMLDocument Objects.");
            }
            // else serialize
            xml = Sarissa.serialize(xml);
        }

        // Grab the request ID
        var reqId = Utilities.parseRequestIDFromXLS(xml);
        if ( typeof callBack == 'function' ) {
            _callBackArray[reqId] = callBack;
        } else {
            throw new Exception("WSXMLTunnel.send: callBack must be a function, arg was: " + callBack );
        }
        JSRequest.send(xml, this._callBack, this.responseFormat);
    };

    /**
     * Response handler for the initial return of the XLS response. Matches
     * the response to the assigned callback function.
     * @param {XML Document} response required The XLS response to the request. Errors
     * should be handled in the callback function. XLS will be either a 
     * @private
     */
    this._callBack = function(response) {
        
        var responseObject, reqID;
        if ( self.responseFormat == "XML" ) {
            // We gots a stringified XML document back
            // Pass back the XML Document Object
            responseObject = Sarissa.getDomDocument();
            responseObject = (new DOMParser()).parseFromString(Utilities.normalizePrefixes(response), "text/xml");
            responseObject.setProperty("SelectionLanguage", "XPath");
            responseObject.setProperty("SelectionNamespaces", "xmlns:xls='http://www.opengis.net/xls' xmlns:gml='http://www.opengis.net/gml'");
            reqID = (responseObject.selectSingleNode("//xls:Response/@requestID").value);
        }
        else {
            // If it's not XML, then we hope it's JSON
            responseObject = response;
            // Just in case we get multiple responses back
            if ( deCarta.Array.isArray(responseObject.XLS.Response) ) {
                reqID = responseObject.XLS.Response[0].requestID;
            }
            else {
                reqID = responseObject.XLS.Response.requestID;
            }
        }
        // The callback needs to deal with the XMLness or the JSONPness
        _callBackArray[reqID](responseObject);
    };
}

/**
 * @fileoverview Factory class for generating cross browser complient XML strings
 * for basic Mapping requests.
 * deCarta confidential and proprietary
 * Copyright 2006-2012 deCarta. All rights reserved.
 * @author Brent Hamby
 */

/**
 * @class Factory class for generating cross browser complient XML
 * basic for basic Mapping requests.
 * @description Constructs the XMLStringBuilder.
 * @constructor
 * @private
 */
 deCarta.XMLStringBuilder = function() {
    

    /**
     * Overlays that are currently registered for requests. Doubles as a holding
     * container for the Map client side drawn overlays.
     * @private
     * @type Array
     * @default []
     */
    this.overlays=[];
    /**
     * Special RouteID overlay. This overlay will only be added to a Portray
     * Map Request when server side shapes are drawn.
     * @type string
     * @default null
     */
    this.routeIDOverlay = null;
    /**
     * The current rendering type: "server" or "client"; this is only used by
     * the Map.
     * @private
     * @type string
     * @default "server"
     */
    this.rendering="server";
    /**
     * Instead of regenerating a route each time, we save the route and resend
     * it with additional requests. This is currently only used with the Map
     * methods associated with routeMap.
     * @deprecated Methods associated with the Map.routeMap functionality are
     * deprecated. Use RouteQuery instead.
     * @private
     */
    this.routeID=null;
    /**
     * Local authentication of the clientName. For use in case user desires
     * to have multiple map objects on the same page.
     * Must be set through one of the authenticate functions.
     * @private
     * @type string
     * @default value of Credentials.clientName
     */
    this.clientName = Credentials.clientName;
    /**
     * Local authentication of the clientPassword. For use in case user desires
     * to have multiple map objects on the same page.
     * Must be set through one of the authenticate functions.
     * @private
     * @type string
     * @default value of Credentials.clientPassword
     */
    this.clientPassword = Credentials.clientPassword;
    /**
     * Local authentication of the configuration setting. For use in case user
     * desires to have multiple map objects on the same page.
     * Must be set through the Map method setConfiguration.
     * @private
     * @type string
     * @default value of Credentials.configuration
     */
    this.configuration = Credentials.configuration;
    /**
     * Local authentication of the transparentConfiguration setting. For use in
     * case user desires to have multiple map objects on the same page.
     * Must be set through the Map method setTransparentConfiguration.
     * @private
     * @type string
     * @default value of Credentials.transparentConfiguration
     */
    this.transparentConfiguration = Credentials.transparentConfiguration;
    /**
     * Local authentication of the map type setting. For use in
     * case user desires to have multiple map objects on the same page.
     * Set through one of the Map method mapType functions.
     * @private
     * @type string
     * @default value of GLOBALS.STREET
     */
    this.mapType = GLOBALS.STREET;
    /**
     * Sets the image format to be used in Portray Map Requests for street
     * view images.
     * @type string
     * @default "PNG"
     */
    this.streetImgFormat = "PNG";
    /**
     * Sets the image format to be used in Portray Map Request for hybrid overlay
     * images.
     * @type string
     * @default "PNG"
     */
    this.hybridImgFormat = "PNG";
};

/**
 * Creates the base XLS request header.
 * Consists of the xls:XLS element and the emepty xls:RequestHeader element.
 * This base function is useful when multiple xls:Request objects will be passed.
 * @param {number} sessionID optional Convenience paramater for passing
 * in a sessionID value. If no value is passed in, a random number will
 * be generated.
 * @param {UOM} [defaultUOM] Translates to the RequestHeader defaultUOM
 * element, if it exists.
 * @returns {String} Returns the xls:XLS and xls:RequestHeader opening elements.
 */
deCarta.XMLStringBuilder.prototype.getRequestHeader = function(sessionID, defaultUOM) {
    
    // Generate default values for arguments
    sessionID = sessionID || Utilities.getRequestId();
    var header = "<xls:XLS version='1' xls:lang='en' xmlns:xls='http://www.opengis.net/xls'";
    if(Credentials.rel){
        header+=" rel='"+Credentials.rel+"' ";
    }
    header += "xmlns:gml='http://www.opengis.net/gml'><xls:RequestHeader clientName='"+this.clientName+"' sessionID='"+sessionID+"' clientAPI='desktopjs' clientPassword='"+this.clientPassword+"' configuration='";
    if( this.mapType == "STREET" ) {
        header += this.configuration + "'";
    }
    else {
        header += this.transparentConfiguration + "'";
    }
    if (defaultUOM) {
        header += " defaultUOM='"+defaultUOM+"' ";
    }
    header += "/>"; // end of the xls:RequestHeader element
    return header;
};

/**
 * Build the xls:Request element.
 * This base function is useful when multiple xls:Request objects will be passed.
 * @param {string} methodName required The name of the Web Services
 * request to be processed e.g. "PortrayMapRequest".
 * @param {number} requestID optional The requestID integer. If one is not
 * passed in, a random number will be generated.
 * @param {number} maximumResponses optional How many results this query
 * should return. For many queries this is arbitrary. If no value is passed
 * in, 10 is used as the default.
 * @returns {String} Returns the xls:Request open element.
 */
deCarta.XMLStringBuilder.prototype.getRequestOpen = function(methodName, requestID, maximumResponses) {
    
    // Generate default values for arguments
    maximumResponses = maximumResponses || "10";
    requestID = requestID || Utilities.getRequestId();
    var header = "<xls:Request maximumResponses='"+maximumResponses+"' version='1.0' requestID='"+requestID+"' methodName='"+methodName+"'>";
    return header;
};

/**
 * Create a complete XLS header for the standard, single requests.
 * Makes the basic XML document common to all of the DDS Web Services
 * requests. No real error checking is done, so pass in appropriate values.
 * @param {string} methodName required The name of the Web Services
 * request to be processed e.g. "PortrayMapRequest".
 * @param {number} [requestID] The requestID integer. If one is not
 * passed in, a random number will be generated.
 * @param {number} [maximumResponses] How many results this query
 * should return. For many queries this is arbitrary. If no value is passed
 * in, 10 is used as the default.
 * @param {number} [sessionID] Convenience paramater for passing
 * in a sessionID value. If no value is passed in, a random number will
 * be generated.
 * @param {UOM} [defaultUOM] Translates to the RequestHeader defaultUOM
 * element, if it exists.
 * @returns {String} Returns the header of a DDS Web Services query
 * as a string, ready to be tailored to a specific query.
 */
deCarta.XMLStringBuilder.prototype.getHeader = function(methodName, requestID, maximumResponses, sessionID, defaultUOM) {
    
    var header = this.getRequestHeader(sessionID, defaultUOM);
    header += this.getRequestOpen(methodName, requestID, maximumResponses);
    return header;
};

/**
 * Return the closing tags for the xls:Request and xls:XLS elements in one string.
 * @returns {string} Closure for a complete request.
 */
deCarta.XMLStringBuilder.prototype.getFooter = function(){
    
    return "</xls:Request></xls:XLS>";
};

/**
 * Create an RUOK request with which to query the server.
 * @param {number} requestId Unique request ID with which to create this request.
 * @return {String} Serialized XLS RUOKRequest.
 */
deCarta.XMLStringBuilder.prototype.createRUOKRequest = function(requestId) {
    
    var xml = this.getHeader("RuokRequest", requestId, 25, Utilities.getRequestId());
    xml+="<xls:RUOKRequest />"+this.getFooter();
    return xml;
};

/*
 * Example of a generated createMapRequest
    <?xml version="1.0" encoding="UTF-8"?>
    <xls:XLS xmlns:xls="http://www.opengis.net/xls" xmlns:gml="http://www.opengis.net/gml" xls:lang="en" version="1" rel="4.4.2">
      <xls:RequestHeader clientName="decarta-jo-nt" clientPassword="demo001" configuration="us-carto-nt" sessionID="4107834"/>
      <xls:Request maximumResponses="10" version="1.0" requestID="2086120" methodName="PortrayMapRequest">
        <xls:PortrayMapRequest>
          <xls:Output width="256" height="256" fixedgrid="true" useCache="true" format="GIF" content="URL">
            <xls:CenterContext SRS="WGS-84">
              <xls:CenterPoint>
                <gml:pos>37.786505 -122.39862</gml:pos>
              </xls:CenterPoint>
              <xls:Radius unit="KM">4</xls:Radius>
            </xls:CenterContext>
            <xls:TileGrid rows="1" columns="1">
              <xls:GridLayer name="deCarta" returnMaxImageHostAliases="true"/>
              <xls:GridLayer name="globexplorer" meta-inf="zoom=13"/>
              <xls:Pan direction="N" numTiles="0"/>
              <xls:Pan direction="S" numTiles="0"/>
              <xls:Pan direction="E" numTiles="0"/>
              <xls:Pan direction="W" numTiles="0"/>
            </xls:TileGrid>
          </xls:Output>
        </xls:PortrayMapRequest>
      </xls:Request>
    </xls:XLS>
 */
/**
 * Generates an XLS PortrayMapRequest XML dom. The PortrayMapRequest handles
 * fresh map draws as well as zooms.
 * @param pos
 * @param tileSize
 * @param requestId
 * @param {string} referenceZoomLevel required The deCarta zoom level that
 * represents the reference zoom for a first draw, or the current zoom level
 * prior to where the map will be zoomed to.
 * @param {string} newZoomLevel optional If this is a zoom request, pass in
 * the new deCarta zoom level to zoom this map to.
 * @param trafficTime
 * @param {string} sessionId optional Zoom requests might need access to stateful
 * information on the server. If this is the case, pass in the sessionId.
 * @returns {string} PortrayMapRequest XLS as a serialized string.
 */
deCarta.XMLStringBuilder.prototype.createMapRequest = function(pos, tileSize, requestId, referenceZoomLevel, newZoomLevel, trafficTime, sessionId){
    
    var overlaysToXML=this.overlaysToXLSString();
    if(!overlaysToXML[1] && !Credentials.trafficEnabled){
        sessionId=GLOBALS.TILE_SESSION_ID;
    }

    var xml = this.getHeader("PortrayMapRequest", requestId, null, sessionId );
    xml+="<xls:PortrayMapRequest><xls:Output height='"+tileSize+"' width='"+tileSize + "' ";
    // Overlays are inserted, if they exist, within this line
    xml+="format='"+(this.mapType=="STREET"?this.streetImgFormat:this.hybridImgFormat)+"' fixedgrid='true' useCache='true'";
    xml+=" projection='"+Credentials.projection+"'";
    xml+="><xls:CenterContext SRS='WGS-84'><xls:CenterPoint><gml:pos>"+pos.toString()+"</gml:pos></xls:CenterPoint><xls:Radius unit='KM'>4</xls:Radius></xls:CenterContext><xls:TileGrid rows='1' columns='1'><xls:GridLayer name='deCarta'/><xls:GridLayer name='globexplorer' meta-inf='zoom=";
    if ( !newZoomLevel ) {
        // No zoom, this is a map refresh
        xml+=Utilities.deCartaToGXZoomLevel(referenceZoomLevel);
    } else {
        // Effect a zoom
        xml+=Utilities.deCartaToGXZoomLevel(newZoomLevel)+":"+Utilities.deCartaToGXZoomLevel(referenceZoomLevel);
    }
    // Add general overlays immediately after the output
    xml+="' urlFormat='"+(Credentials.projection=='EPSG:3857'?'V2':'V1')+"'/></xls:TileGrid></xls:Output>"+overlaysToXML[0];
    if(Credentials.trafficEnabled){
        if(trafficTime){
            xml+="<xls:Overlay><xls:Traffic><xls:FlowReporting/></xls:Traffic></xls:Overlay>";
        } else {
            xml+="<xls:Overlay><xls:Traffic><xls:FlowReporting"+(trafficTime?" time='"+trafficTime+"'":"")+"/></xls:Traffic></xls:Overlay>";
        }
    }
    xml+="</xls:PortrayMapRequest>";
    xml+=this.getFooter();
    
    return xml;
};

/*
 * Example mixed Geocode Request, we will only run one sub-type of geocode request
 * at a time
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns1:XLS version="1.0" ns1:lang="en" xmlns:ns1="http://www.opengis.net/xls">
    <ns1:RequestHeader clientPassword="abc123" sessionID="999" clientName="someclient"/>
    <ns1:Request methodName="GeocodeRequest" requestID="10" maximumResponses="25" version="1.0">
        <ns1:GeocodeRequest>
            <ns1:Address countryCode="US">
                <ns1:StreetAddress>
                    <ns1:Building number="100"/>
                    <ns1:Street>1st Ave.</ns1:Street>
                </ns1:StreetAddress>
                <ns1:PostalCode>11111</ns1:PostalCode>
            </ns1:Address>
            <ns1:Address countryCode="US">
                <ns1:StreetAddress>
                    <ns1:Building number="332"/>
                    <ns1:Street>Third Street.</ns1:Street>
                </ns1:StreetAddress>
                <ns1:PostalCode>11111</ns1:PostalCode>
            </ns1:Address>
            <ns1:Address countryCode="US">
                <ns1:freeFormAddress>221 Second Avenue, Stickville, NY 11111</ns1:freeFormAddress>
            </ns1:Address>
        </ns1:GeocodeRequest>
    </ns1:Request>
</ns1:XLS>
 */
/**
 * Create a GeocodeRequest serialized XLS string.
 * @param {object} address required Type of object must be either a structured
 * address {@link Address} or a single line address {@link FreeFormAddress}.
 * @param {integer} requestId optional Opportunity to pass in a user generated
 * request id.
 * @param {boolean} returnFreeForm optional If true, which should be the default
 * passed in (it's not this functions job to enforce the default), then addresses
 * returned will be marshalled into a FreeFormAddress. If false, then the
 * structured addresses will be returned in the response and should be
 * marshalled into an Address instance.
 * @return {string} The created XLS XML request returned as a string.
 * @throws {Exception} If problems creating the XML document.
 */
deCarta.XMLStringBuilder.prototype.createGeocodeRequest = function( address, requestId, returnFreeForm, referencePoint ) {
    

    var xml = this.getHeader("GeocodeRequest", requestId );
    // Build geocode request element
    xml+="<xls:GeocodeRequest";
    if ( returnFreeForm ) {
        xml+=" returnFreeForm='true'>";
    } else {
        xml+=" returnFreeForm='false'>";
    }

    //reference point added AI 4.6.1
    if (referencePoint){
        xml += '<xls:Point xmlns:xls="http://www.opengis.net/gml"><xls:pos>' + referencePoint.getLat() + " " + referencePoint.getLon() + '</xls:pos></xls:Point>';
    }

    // Address construction
    xml+="<xls:Address countryCode='"+address.getLocale().getCountry()+"'";
    xml+=" language='"+address.getLocale().getLanguage()+"'>";
    if ( address.type == "FreeForm" ) {
        // a FreeFormAddress has been passed in
        //<xls:freeFormAddress>221 Second Avenue, Stickville, NY 11111</xls:freeFormAddress>
        xml+="<xls:freeFormAddress>" + address.toString() + "</xls:freeFormAddress>";
    } else {
        // assume an Address object has been passed in. To identify the street,
        // we will use either:
        // <xls:StreetAddress>
        //   <xls:Building number="332"/>
        //   <xls:Street>Third Street.</xls:Street>
        // </xls:StreetAddress>
        // or:
        // <xls:StreetNameAndNumber>4 N 2nd St</xls:StreetNameAndNumber>
        // followed by:
        // <xls:Place type="CountrySubdivision">NY</xls:Place>
        // <xls:Place type="CountrySecondarySubdivision">SUFFOLK</xls:Place>
        // <xls:Place type="Municipality">Stickville</xls:Place>
        // <xls:PostalCode>11111</xls:PostalCode>
        var buildingNumber = "";
        var street = "";
        if ( !(address.buildingNumber && address.street) && (address.streetNameAndNumber) ) {
            xml += "<xls:StreetNameAndNumber>"+address.streetNameAndNumber+"</xls:StreetNameAndNumber>";
        }
        else {
            if ( address.buildingNumber || address.buildingNumber == 0 ) {
                // We're really not supposed to have a building without a
                // street address
                buildingNumber = "<xls:Building number='"+address.buildingNumber+"'/>";
            }
            if ( address.street ) {
                street = "<xls:Street>"+address.street+"</xls:Street>";
            }
            if ( address.street ) {
                // As stated previously, we need a street if we have a building number
                xml+="<xls:StreetAddress>"+buildingNumber+street+"</xls:StreetAddress>";
            }
        }
        // Add the remaining geography, if present
        if ( address.countrySubdivision ) {
            xml+="<xls:Place type='CountrySubdivision'>"+address.countrySubdivision+"</xls:Place>";
        }
        if ( address.countrySecondarySubdivision ) {
            xml+="<xls:Place type='CountrySecondarySubdivision'>"+address.countrySecondarySubdivision+"</xls:Place>";
        }
        if ( address.countryTertiarySubdivision ) {
            xml+="<xls:Place type='CountryTertiarySubdivision'>"+address.countryTertiarySubdivision+"</xls:Place>";
        }
        if ( address.municipality ) {
            xml+="<xls:Place type='Municipality'>"+address.municipality+"</xls:Place>";
        }
        if ( address.municipalitySubdivision ) {
            xml+="<xls:Place type='MunicipalitySubdivision'>"+address.municipalitySubdivision+"</xls:Place>";
        }
        if ( address.postalCode ) {
            xml+="<xls:PostalCode>"+address.postalCode+"</xls:PostalCode>";
        }
    }
    //************************** Close request
    xml+="</xls:Address></xls:GeocodeRequest>";
    xml+=this.getFooter();
    
    return xml;
};

/*
 * Example Reverse Geocode
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns1:XLS version="1" ns1:lang="en" xmlns:ns1="http://www.opengis.net/xls">
    <ns1:RequestHeader clientName="someclient" sessionID="999" clientPassword="abc123"/>
    <ns1:Request maximumResponses="25" version="1.0" requestID="10" methodName="ReverseGeocodeRequest">
        <ns1:ReverseGeocodeRequest>
          <ns1:Position>
               <ns2:Point xmlns:ns2="http://www.opengis.net/gml">
                       <ns2:pos>41.003 -72.002896</ns2:pos>
               </ns2:Point>
          </ns1:Position>
        </ns1:ReverseGeocodeRequest>
    </ns1:Request>
</ns1:XLS>
 */
/**
 * Build a reverse geocode XLS request string.
 * @param {Position} pos required The position to reverseGeocode to.
 * @param {number} requestId optional Unique id for this request.
 * @returns {string} the serialized XLS for a reverse geocode request.
 */
deCarta.XMLStringBuilder.prototype.createReverseGeocodeRequest = function( pos, requestId ) {
    

    //************************** create header
    var xml = this.getHeader("ReverseGeocodeRequest", requestId );

    //************************** create body
    xml+="<xls:ReverseGeocodeRequest><xls:Position><gml:Point><gml:pos>"+pos.toString()+"</gml:pos></gml:Point></xls:Position>";

    // Right now, the preference is hard coded in the JSAPI
    // as of 4.4.2, options are StreetAddress, AddressRange and IntersectionAddress
    xml+="<xls:ReverseGeocodePreference>StreetAddress</xls:ReverseGeocodePreference>";

    //************************** Close request
    xml+="</xls:ReverseGeocodeRequest>";
    xml+=this.getFooter();
    
    return xml;
};



/*
 * Example XML response
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns1:XLS version="1" ns1:lang="en" xmlns:ns1="http://www.opengis.net/xls">
<ns1:RequestHeader configuration="navteq-north-america" sessionID="999" clientName="someclient" clientPassword="abc123"/>
<ns1:Request version="1.0" requestID="10" methodName="DirectoryRequest" maximumResponses="25">
<ns1:DirectoryRequest freeformAddrLang="FR">
<ns1:POILocation>
<ns1:WithinDistance>
<ns1:POI ID="1">
<ns2:Point xmlns:ns2="http://www.opengis.net/gml">
<ns2:pos>45.574195 -73.584945</ns2:pos>
</ns2:Point>
</ns1:POI>
<ns1:MaximumDistance value="500"/>
</ns1:WithinDistance>
</ns1:POILocation>
<ns1:POIProperties>
<ns1:POIProperty value="restaurant" name="Keyword"/>
</ns1:POIProperties>
</ns1:DirectoryRequest>
</ns1:Request>
</ns1:XLS>
*/
/**
 * Create the XLS poi request as a string.
 * @param {SearchCriteria or Array} searchCriteria required Sets constraints on what
 * types of POIs will be returned within the response. If an array of SearchCriterias
 * are passed in, multiple xls:Request messages will be made and sent to the
 * server in one shot.
 * @param {number} requestId optional A unique request ID. One will be generated
 * if not supplied.
 * @returns {string} the serialized XLS for a directory request.
 */
deCarta.XMLStringBuilder.prototype.createPOIRequest = function(searchCriteria, requestId){
    

    // Check to see if we will do a single or a multi-request
    var isMultiRequest = deCarta.Array.isArray(searchCriteria);

    var i;
    var xml = "";
    
    if ( isMultiRequest ) {
        // all request header
        xml += this.getRequestHeader(null, searchCriteria.defaultUOM);
        // loop build each request
        for ( i = 0; i < searchCriteria.length; i++ ) {
            xml += this.getRequestOpen("DirectoryRequest", requestId, searchCriteria[i].maximumResponses);
            xml += this.getDirectoryRequest(searchCriteria[i]);
            // close each request
            xml += "</xls:Request>";
        }
        // close all requests
        xml += "</xls:XLS>";
    }
    else {
        xml += this.getHeader("DirectoryRequest", requestId, searchCriteria.maximumResponses, null, searchCriteria.defaultUOM);
        // build directory request
        xml += this.getDirectoryRequest(searchCriteria);
        xml += this.getFooter();
    }
    
    return xml;

};
/**
 * build simple full details POI query
 * @param {string} poiId POI identifier previously obtained from the DDS WS.
 * @param {number} [requestId] A unique request ID. One will be generated
 * if not supplied.
 * @returns {string} the serialized XLS for a directory request.
 */
deCarta.XMLStringBuilder.prototype.createFullDetailsPOIRequest = function(poiId, requestId){
    
    var xml = this.getHeader("DirectoryRequest", requestId, 10);
    /*
    <ns1:DirectoryRequest paging="current">
        <ns1:POI ID="search:review:qype:654"/>
    </ns1:DirectoryRequest>
     */
    xml += '<xls:DirectoryRequest paging="current"><xls:POI ID="'+poiId+'"/></xls:DirectoryRequest>';
    xml += this.getFooter();
    return xml;
};

/*
    <complexType name="NearRouteType">
        <annotation>
            <documentation>deCarta proprietaty element which allows the DirectoryService to search for points along a route.</documentation>
        </annotation>
        <sequence>
            <choice>
                <element name="euclideanDistance" type="xls:DistanceType"/>
                <element name="distance" type="xls:DistanceType"/>
                <element name="drivetime" type="duration"/>
            </choice>
            <choice>
                <element name="RouteID">
                    <annotation>
                        <documentation>Decarta proprietary: compact RouteIDs to be used as overlays. Server will "rehydrate" the route and draw it on the map.</documentation>
                    </annotation>
                    <complexType>
                        <simpleContent>
                            <extension base="string">
                                <attribute name="preference" type="string"/>
                            </extension>
                        </simpleContent>
                    </complexType>
                </element>
                <element name="LineString" type="gml:LineStringType"/>
            </choice>
        </sequence>
    </complexType>
 */

/**
 * Builds an xls:DirectoryRequest portion of a Directory Request.
 * Broken out in order to allow the sending of multiple xls:Requests within a
 * single request to the server.
 * @param {AbstractSearchCriteria} is the super class for the the various search
 * systems  {@link SearchCriteria}, {@link CorridorSearchCriteria}
 * types of POIs will be returned within the response. If an array of SearchCriterias
 * are passed in, multiple xls:Request messages will be made and sent to the
 * server in one shot.
 * @returns {string} the serialized xls:DirectoryRequest for a directory request.
 */
deCarta.XMLStringBuilder.prototype.getDirectoryRequest = function(searchCriteria){
    
    var xml = "";
    //************************** create body
    // Various attributes can be set in the DirectoryRequest element
    xml += "<xls:DirectoryRequest";
    if ( searchCriteria.database != null ) {
        xml += " database='"+searchCriteria.database+"'";
    }
    if ( searchCriteria.sortDirection ) {
        xml += " sortDirection='"+searchCriteria.sortDirection+"'";
    }
    if ( searchCriteria.sortCriteria ) {
        xml += " sortCriteria='"+searchCriteria.sortCriteria+"'";
    }
    if ( searchCriteria.rankCriteria ) {
        xml += " rankCriteria='"+searchCriteria.rankCriteria+"'";
    }
    if ( searchCriteria.allowAggregates ) {
        xml += " allowAggregates='true'";
    }
    // close DirectoryRequest element
    xml += ">";

    if(searchCriteria.routeId){
        // Build the POILocation with nested elements
        xml += "<xls:POILocation><xls:NearRoute>";
        if(searchCriteria.type==="distance"){
            xml += "<xls:distance value='"+searchCriteria.distance+"' uom='M'/>";
        } else if(searchCriteria.type==="euclideanDistance"){
            xml += "<xls:euclideanDistance value='"+searchCriteria.distance+"' uom='M'/>";
        } else {
            // TODO need to build in better
            xml += "<xls:drivetime>P0DT"+Math.floor(searchCriteria.duration/60)+"H"+(searchCriteria.duration%60)+"M0S</xls:drivetime>";
        }
        xml += "<xls:RouteID>"+searchCriteria.routeId+"</xls:RouteID>";
        xml += "</xls:NearRoute></xls:POILocation>";
    	
    } else {
    	
        // Build the POILocation with nested elements
        xml += "<xls:POILocation><xls:WithinDistance>";
        // From where we look, ID carried on for legacy reasons
        xml += "<xls:POI ID='1'><gml:Point><gml:pos>"+searchCriteria.position.toString()+"</gml:pos></gml:Point></xls:POI>";
        // Set up the radial distance to search, hard coding the minimum search to zero
        xml += "<xls:MinimumDistance value='0' uom='KM'/><xls:MaximumDistance value='"+searchCriteria.radius.distance+"' uom='"+searchCriteria.radius.uom.value+"'/>";
        // Close the POILocation with nested elements
        xml += "</xls:WithinDistance></xls:POILocation>";
    }

    // Build the POIProperties that affect the categories of POIs returned
    xml += "<xls:POIProperties>";


//    // The keyword search is required and hardcoded
//    // Options: keyword | POIName | TYPESTRING | Brand
//    xml += "<xls:POIProperty value='"+searchCriteria.queryString+"' name='Keyword'/>";
//    // Look for and append any optional options
//    for(var x in searchCriteria.properties) {
//        if ( searchCriteria.properties.hasOwnProperty(x) ) {
//            xml += "<xls:POIProperty value='"+searchCriteria.properties[x]+"' name='"+x+"'/>";
//        }
//    }
    if(!searchCriteria.retrieveAll){
        var propertiesSearch=false;
        // Look for and append any optional options
        for(var x in searchCriteria.properties) {
            if ( searchCriteria.properties.hasOwnProperty(x) ) {
                propertiesSearch=true;
                xml += "<xls:POIProperty value='"+searchCriteria.properties[x]+"' name='"+x+"'/>";
            }
        }
        if(!propertiesSearch){
            // The keyword search is required and hardcoded
            // Options: keyword | POIName | TYPESTRING | Brand
            xml += "<xls:POIProperty value='"+searchCriteria.queryString+"' name='Keyword'/>";
        }
    }

    //************************** Close request
    xml += "</xls:POIProperties></xls:DirectoryRequest>";
    return xml;
};

/*
 * Example DetermineRouteRequest
<?xml version="1.0" encoding="UTF-8"?>
<xls:XLS xmlns:xls="http://www.opengis.net/xls" xmlns:gml="http://www.opengis.net/gml" version="1" xls:lang="en" rel="4.4.2">
  <xls:RequestHeader clientName="self-jo" sessionID="4430610" clientPassword="howru00" configuration="us-carto-nt"/>
  <xls:Request maximumResponses="10" version="1.0" requestID="1000" methodName="DetermineRouteRequest">
    <xls:DetermineRouteRequest distanceUnit="MI" routeQueryType="RTXT" provideRouteHandle="true">
      <xls:RoutePlan optimize="true">
        <xls:RoutePreference>Fastest</xls:RoutePreference>
        <xls:WayPointList>
          <xls:StartPoint>
            <xls:Position>
              <gml:Point>
                <gml:pos>37.304 -121.873</gml:pos>
              </gml:Point>
            </xls:Position>
          </xls:StartPoint>
          <xls:ViaPoint>
            <xls:Position>
              <gml:Point>
                <gml:pos>37.6907 -122.46595</gml:pos>
              </gml:Point>
            </xls:Position>
          </xls:ViaPoint>
          <xls:ViaPoint>
            <xls:Position>
              <gml:Point>
                <gml:pos>37.4445 -122.1602</gml:pos>
              </gml:Point>
            </xls:Position>
          </xls:ViaPoint>
          <xls:ViaPoint>
            <xls:Position>
              <gml:Point>
                <gml:pos>37.354441 -121.969119</gml:pos>
              </gml:Point>
            </xls:Position>
          </xls:ViaPoint>
          <xls:EndPoint>
            <xls:Position>
              <gml:Point>
                <gml:pos>37.766667 -122.433333</gml:pos>
              </gml:Point>
            </xls:Position>
          </xls:EndPoint>
        </xls:WayPointList>
        <xls:Logistics>
          <xls:PreferredRoute>STAA_RT</xls:PreferredRoute>
          <xls:Hazmat>1,2,3</xls:Hazmat>
          <xls:VehicleParameters>VEHPARAM_WEIGHT_GROSS:700</xls:VehicleParameters>
          <xls:VehicleTypes>VEH_4WD</xls:VehicleTypes>
        </xls:Logistics>
      </xls:RoutePlan>
      <xls:RouteInstructionsRequest providePoint="true"/>
      <xls:RouteGeometryRequest resolution="10000">
        <xls:BoundingBox>
          <xls:pos>37 -122</xls:pos>
          <xls:pos>38 -121</xls:pos>
        </xls:BoundingBox>
      </xls:RouteGeometryRequest>
    </xls:DetermineRouteRequest>
  </xls:Request>
</xls:XLS>

 */
/**
 * Create a standard route geometry XLS request as a string.
 * @param {Array} positionList required An array of Positions consisting of
 * the waypoints along a route. The XML created will calculate the route in
 * order from positionList[0] to positionList[length - 1] (the destination).
 * @param {number} requestId optional The requestID for this request. Mainly
 * used within the JS code as a marker for the callback function to run.
 * @param {RoutePreference} routePreference required Describes the rules
 * to use when calculating this route.
 * @returns {string} the serialized XLS for a DetermineRouteRequest.
 */
deCarta.XMLStringBuilder.prototype.createRouteGeometryRequest = function( positionList, requestId, routePreference ) {
    


    //************************** create header
    var xml = this.getHeader("DetermineRouteRequest", requestId);

    //************************** create body
    // Various attributes can be set in the DetermineRouteRequest element
    xml += "<xls:DetermineRouteRequest distanceUnit='"+routePreference.uom+"' routeQueryType='"+routePreference.routeQueryType+"' provideRouteHandle='"+routePreference.provideRouteHandle+"'";
    if ( routePreference.alternateRoutes ) {
        xml += " numAltRoutes='"+routePreference.alternateRoutes+"'";
    }
    // end opening element of DetermineRouteRequest
    xml += ">";

    // OPEN RoutePlan with the various optional attributes
    xml += "<xls:RoutePlan";
    if ( Credentials.trafficEnabled ) {
        xml += " useRealTimeTraffic='true'";
    }
    if ( routePreference.optimized ) {
        xml += " optimize='true'";
    }
    //if ( Credentials.trafficEnabled && routePreference.expectedStartTime ) {
    if ( routePreference.expectedStartTime ) {
        xml += " expectedStartTime='"+routePreference.expectedStartTime+"'";
    }
    if(routePreference.useExclusionZone==true){
        xml+= " useExclusionZone='true'";
    }
    // close RoutePlan opening element
    xml += ">";

    // RoutePreference
    xml += "<xls:RoutePreference>"+routePreference.routePreference+"</xls:RoutePreference>";
    
    if(routePreference.routeControl){
        xml += "<xls:RouteControl>"+routePreference.routeControl+"</xls:RouteControl>";
    }

    // WayPointList
    xml += "<xls:WayPointList>";
    for(var i=0; i<positionList.length; i++) {
        if( i == 0 ) {
            // Must have 1 and only 1 StartPoint
            xml += "<xls:StartPoint><xls:Position><gml:Point><gml:pos>"+positionList[i].toString()+"</gml:pos></gml:Point></xls:Position></xls:StartPoint>";
        } else if (i>0 && i<(positionList.length-1)) {
            xml += "<xls:ViaPoint><xls:Position><gml:Point><gml:pos>"+positionList[i].toString()+"</gml:pos></gml:Point></xls:Position></xls:ViaPoint>";
        } else if (i==(positionList.length-1)) {
            // Must have 1 and only 1 EndPoint
            xml += "<xls:EndPoint><xls:Position><gml:Point><gml:pos>"+positionList[i].toString()+"</gml:pos></gml:Point></xls:Position></xls:EndPoint>";
        }
    }
    xml += "</xls:WayPointList>";

    //Vehicle type, added 4.5.2
    if ( routePreference.vehicleType ){
        xml += '<xls:TypeOfVehicle>' + routePreference.vehicleType + '</xls:TypeOfVehicle>';

    }

    // AvoidList - general road features to avoid
    if ( routePreference.avoidList.length > 0 || routePreference.avoidAreas.length > 0 ) {
        xml += "<xls:AvoidList>";
        // Avoid Areas come first
        for ( i = 0; i < routePreference.avoidAreas.length; i++ ) {
            // Build the avoid areas via a buildAreaOfInterest function, or something like that
            xml += this.avoidAreasToXLSString(routePreference.avoidAreas[i]);
        }
        for ( i = 0; i < routePreference.avoidList.length; i++ ) {
            xml += "<xls:AvoidFeature>"+routePreference.avoidList[i].toString()+"</xls:AvoidFeature>";
        }
        xml += "</xls:AvoidList>";
    }

    // Logistics - Only if a logistics setting is specified
    var lp = routePreference.logisticsPreference;
    if ( lp && (lp.preferredRoute || lp.hazmat || lp.vehicleParameters || lp.vehicleTypes || lp.preferredTurn) ) {
        // need to set a Logistics pref
        xml += "<xls:Logistics>";
        if ( lp.preferredRoute ) {
            xml += "<xls:PreferredRoute>"+lp.preferredRoute+"</xls:PreferredRoute>";
        }
        if ( lp.hazmat ) {
            xml += "<xls:Hazmat>"+lp.hazmat+"</xls:Hazmat>";
        }
        if ( lp.vehicleParameters ) {
            xml += "<xls:VehicleParameters>"+lp.vehicleParameters+"</xls:VehicleParameters>";
        }
        if ( lp.vehicleTypes ) {
            xml += "<xls:VehicleTypes>"+lp.vehicleTypes+"</xls:VehicleTypes>";
        }
        if ( lp.preferredTurn ) {
            xml += "<xls:PreferredTurn>"+lp.preferredTurn+"</xls:PreferredTurn>";
        }
        xml += "</xls:Logistics>";
    }

    // CLOSE RoutePlan
    xml += "</xls:RoutePlan>";

    // RouteInstructionsRequest
    if ( routePreference.returnRouteInstructions ) {
        // providePoint forces the maneuver point to be returned with each RouteInstruction
        xml += "<xls:RouteInstructionsRequest providePoint='true'";
        if( routePreference.rules ) {
            xml += " rules='"+routePreference.rules+"'";
        }
        xml += "/>";
    }

    // RouteGeometryRequest
    // The DDSWS uses opposite semantics from what we use in our request for
    // routeGeometry. True-ing the returnRouteIDOnly == false on returnGeometry.
    xml += "<xls:RouteGeometryRequest returnRouteIDOnly=";
    if ( routePreference.returnRouteGeometry ) {
        // No we don't want _just_ the routeID, we want the geometry too
        xml += "'false'";
    }
    else {
        // Yes we want _just_ the routeID
        xml += "'true'";
    }
    // Make a choice: generalize on the server, or just close the tag
    if ( routePreference.generalizationFactor && routePreference.generalizationFactor !== 0 && routePreference.generalizationBBox ) {
        // Our result will need to look like this
        // <ns1:RouteGeometryRequest resolution="1000">
        //     <ns1:BoundingBox>
        //         <ns2:pos xmlns:ns2="http://www.opengis.net/gml">37.33427 -122.42005</ns2:pos>
        //         <ns3:pos xmlns:ns3="http://www.opengis.net/gml">37.77916 -121.88579</ns3:pos>
        //     </ns1:BoundingBox>
        // </ns1:RouteGeometryRequest>
        xml += " resolution ='"+routePreference.generalizationFactor+"'>"; // close RouteGeometryRequest opening tag
        // Close RouteGeometryRequest nested tag at the end of this
        xml += "<xls:BoundingBox><gml:pos>"+routePreference.generalizationBBox.minPosition+"</gml:pos><gml:pos>"+routePreference.generalizationBBox.maxPosition+"</gml:pos></xls:BoundingBox></xls:RouteGeometryRequest>";
    }
    else {
        // Close RouteGeometryRequest as an empty tag
        xml += "/>";
    }

    if(routePreference.maneuverMaps){
        xml+="<xls:RouteMapRequest><xls:Output orientation=\""+routePreference.maneuverMapConfig.orientation+"\" format=\""+routePreference.maneuverMapConfig.format+"\" width=\""+routePreference.maneuverMapConfig.width+"\" height=\""+routePreference.maneuverMapConfig.height+"\" /></xls:RouteMapRequest>";
    }

    //************************** Close request
    xml+="</xls:DetermineRouteRequest>";
    xml+=this.getFooter();
    
    return xml;
};

/*
 * Example of a basic route id request
<?xml version="1.0" encoding="UTF-8"?>
<xls:XLS xmlns:xls="http://www.opengis.net/xls" xmlns:gml="http://www.opengis.net/gml" version="1" xls:lang="en" rel="4.4.2">
  <xls:RequestHeader clientName="self-jo" sessionID="10000" clientPassword="howru00" configuration="us-carto-nt"/>
  <xls:Request maximumResponses="10" version="1.0" requestID="10000" methodName="DetermineRouteRequest">
    <xls:DetermineRouteRequest>
      <xls:RouteHandle serviceID="DetermineRouteService" routeID="5gEAAHhWNBIAAAAA5gEAAF8ajPapUqw4al0t2fYPakX6BEugAEtFx4lMpgBLRciMK6AAKkYAiJktoQAvRX+OKuF0t2gAK0oDlf0YK8XS3bUBM0oBi/54M5dLdtICO0oBMf7lPaAAPUUNijrwXS3bADlKAPj7cZxXrAA5SgC9/Ww5qwA5SgCQ/gw54XS3kwA5SgDq/NQ5qgA6SXz+MjumADpKAP/7djuXS3kfADlKAIH9sTv4F0t5Ay9KCMDxujGlADNKBZL2kDSXS3tbADdJUf9HOPBdLe0ANkoBUPlbNaECLUoJGPPiLfwF0ssLEkoWx+uhE5dLK98AE0oAwAC3E/BdLK8DJUoKJ/5DIuF0srIAK0oBPv92KV0srIkVKUUF/SKgAyJFHPwjoAEjRQ/+IKACIEUW/x6gCR5FBwEdoAQdRRQEGqAAGkUZCxagAhZFEQsToAMTRQ8PEaAAEUUiJg2iAw1FCxQOoAEORRIaD6ADD0UPFRGgAhFFExYSpAESRR0cE6ADE0UcGxSgARRFHhsToAETRR0bFKADFEUdGBOiAhNFHRsToAETRR4bE6ABE0UXFBSgBRRFDAsToAITRRYUD/BdLKwFIUoDDgC8IqsTEEYDMh0wqgEiSgHQ/dtDXSys7wBDVfCCQA=="/>
      <xls:RouteInstructionsRequest providePoint="true"/>
      <xls:RouteGeometryRequest/>
    </xls:DetermineRouteRequest>
  </xls:Request>
</xls:XLS>
*/
/**
 * Generate a request to build the route geometry from a previously created
 * RouteHandle/Route Id.
 * Note from question that I asked Geoff: What happens if the
 * routeID that gets passed in has expired? If the routeID is valid, than
 * nothing bad should happen. A valid routeID will be sent back to the DDS
 * for rehydration, as the routeID always contains the dehydrated route. An
 * invalid routeID will not be able to be rehydrated and will (elsewhere)
 * throw an exception. Care must be taken to catch and pass valid routeIDs.
 * @param {string} routeID required The value of the routeId attribute from
 * the RouteHandle element from a previously computed DetermineRouteRequest.
 * @param {number} requestId required The value of our requestId attribute from
 * our Request element from our previously generated header.
 * @param {string} sessionID optional Ability to pass through the sessionID,
 * should that ever be needed.
 * @returns {string} the serialized route geometry request using a routeID.
 */
deCarta.XMLStringBuilder.prototype.createRouteGeometryByIdRequest = function( routeID, requestId, sessionID ) {
    

    //************************** create header
    var xml = this.getHeader("DetermineRouteRequest", requestId, null, sessionID);

    //************************** create body
    // We are attempting to create an identical route. Need very
    // little information other than the routeHandle/routeId.
    // OPEN DetermineRouteRequest element and RoutHandle empty element and RouteInstructionsRequest empty element
    xml += "<xls:DetermineRouteRequest routeQueryType='RMAN'><xls:RouteHandle serviceID='DetermineRouteService' routeID='"+routeID+"'/><xls:RouteInstructionsRequest providePoint='true'/><xls:RouteGeometryRequest/>";
    
    //************************** Close request
    xml+="</xls:DetermineRouteRequest>";
    xml+=this.getFooter();
    
    return xml;
};

/**
 * Create traffic incident request as a serialized XLS string.
 * @param {TrafficIncidentSearchCriteria} searchCriteria required Constraints
 * used to determine the results.
 * @param {number} requestId optional A pre-generated request id, should a specific
 * request id be needed.
 * @returns {string} the serialized traffic incident request.
 */
deCarta.XMLStringBuilder.prototype.createTrafficIncidentRequest = function( searchCriteria, requestId ) {
    

    //************************** create header
    var xml = this.getHeader("TrafficRequest", requestId, searchCriteria.maxiumResponses);

    //************************** create body
    xml += "<xls:TrafficRequest><xls:IncidentReporting minimumSeverity='"+searchCriteria.minimumSeverity+"'/>";
    xml += "<xls:CenterContext SRS='WGS-84'><xls:CenterPoint><gml:pos>"+searchCriteria.position+"</gml:pos></xls:CenterPoint>";
    xml += "<xls:Radius unit='"+searchCriteria.radius.uom.value+"'>"+searchCriteria.radius.distance+"</xls:Radius></xls:CenterContext>";

    //************************** Close request
    xml+="</xls:TrafficRequest>";
    xml+=this.getFooter();
    
    return xml;
};

/**
 * Transform any DDSShapes associated with this instance of the XMLStringBuilder
 * and return them as a string. This string should then be appended to the current
 * XLS request being built.
 * @returns {Array} Array[0] is the DDSShapes as one XLS string, to be appended to the
 * current map object being created. Array[1] is boolean to indicate if there is overlay
 * inside the xml.
 */
deCarta.XMLStringBuilder.prototype.overlaysToXLSString = function() {
    


    // Catch the different overlays and join before returning
    // Each overlay can get long, might necessitate join.
    var overlayArray = [];

    // Special server side drawn route from dehydrated routeID
    if( this.routeIDOverlay ) {
        overlayArray.push("<xls:Overlay><xls:RouteID>"+this.routeIDOverlay+"</xls:RouteID></xls:Overlay>");
    }

    for( var i = 0; i < this.overlays.length; i++ ) {
        if (this.overlays[i].rendering == "client" || (this.rendering != "server" && this.overlays[i].rendering != "server")) {
            // Skip this shape if we shouldn't render it
            continue;
        }
        // Don't draw hidden overlays
        if(!this.overlays[i] || (this.overlays[i] && !this.overlays[i].isVisible)) {
            continue;
        }
        var xml = "";
        var ovr = this.overlays[i];

        // Open Overlay
        xml += "<xls:Overlay>";

        // Separate line and !line items
        // Still adding to opening Shape tag
        if( ovr.type == "line" ) {
            xml += "<xls:Shape color='"+ovr.fillColor+"_"+ovr.borderColor+"' style='"+ovr.borderStyle+"' width='"+ovr.width+"_"+ovr.borderWidth+"'";
            if ( ovr.strokeOpacity ) {
                // Lines can only have stroke opacity.
                // strokeOpacity overrides general opacity if present.
                xml += " opacity='"+ovr.strokeOpacity+"'";
            }
            else {
                xml += " opacity='"+ovr.opacity+"'";
            }
        }
        else {
            xml += "<xls:Shape type='"+ovr.type+"' color='"+ovr.fillColor+"_"+ovr.borderColor+"' style='"+ovr.borderStyle+"' width='"+ovr.borderWidth+"'";
            if ( ovr.strokeOpacity || ovr.fillOpacity ) {
                // the presence of a fill or stroke opacity
                // overrides a singular opacity if present.
                var sOpacity = ovr.strokeOpacity || ovr.opacity;
                var fOpacity = ovr.fillOpacity || ovr.opacity;
                // DDS needs fill opacity first
                xml += " opacity='"+fOpacity+"_"+sOpacity+"'";
            }
            else {
                xml += " opacity='"+ovr.opacity+"'";
            }
        }


        if ( ovr.type == "circle" ) {
            // Close the Shape opening tag
            xml += " pointspec='LL' radius='"+ovr.radius.uomdds+ovr.radius.distance+"'>"+ovr.position.lat+","+ovr.position.lon;
        } else {
            // Close the shape opening tag and follow with the xml
            ovr.VR7 = ovr.VR7 || Utilities.LL2VR7(ovr.positions);
            if (ovr.type == "line") {
                xml += " pointspec='VR7'>" + ovr.VR7;
            } else {
                // Here must be a polygon
                xml += " pointspec='VR7PG'>" + ovr.VR7;
            }
        }
        //************************** Close Overlay...
        xml += "</xls:Shape></xls:Overlay>";
        // ...and add it to the result array.
        overlayArray.push(xml);
    }
    // Must return as a single string.
    var toReturn = overlayArray.join("");
    
    return [toReturn, (overlayArray.length>0)?true:false];
};


/**
 * Transform an avoid area object into it's XLS counterpart.
 * @param {object} aoi The abstract area object to transform into an XLS AOI.
 * @return {string} A serialized xls:AOI object.
 * @see RoutePreference#addAvoidArea
 */
deCarta.XMLStringBuilder.prototype.avoidAreasToXLSString = function(aoi) {
    
    var i; // counter
    var xml = "<xls:AOI>";
    if ( /Line/i.test(aoi.name) ) {
        xml += "<gml:LineString>";
        for ( i = 0; i < aoi.pos.length; i++ ) {
            xml += "<gml:pos>"+aoi.pos[i]+"</gml:pos>"
        }
        xml += "</gml:LineString>";
    }
    else if ( /Polygon/i.test(aoi.name) ) {
        xml += "<gml:Polygon><gml:exterior><gml:LinearRing>";
        for ( i = 0; i < aoi.pos.length; i++ ) {
            xml += "<gml:pos>"+aoi.pos[i]+"</gml:pos>"
        }
        xml += "</gml:LinearRing></gml:exterior></gml:Polygon>";
    }    
    else if ( /Rectangle/i.test(aoi.name) ) {
        // rectangle, bounding box, envelope... we like lots of names for the same thing
        xml += "<gml:Envelope>";
        // min first, max second
        xml += "<gml:pos>"+aoi.pos[0]+"</gml:pos><gml:pos>"+aoi.pos[1]+"</gml:pos>";
        xml += "</gml:Envelope>";

    }
    else if ( /Circle/i.test(aoi.name) ) {
        // The number 1 is a fixed value, indicating only 1 arc (that of the circle) is drawn.
        xml += "<gml:CircleByCenterPoint numArc='1'>";
        xml += "<gml:pos>"+aoi.pos+"</gml:pos>";
        xml += "<gml:radius uom='"+aoi.radius.uom+"'>"+aoi.radius.distance+"</gml:radius>";
        xml += "</gml:CircleByCenterPoint>";
    }
    else {
        throw new Exception("deCarta.XMLStringBuilder.avoidAreasToXLSString: invalid type of avoid object: " + aoi.name);
    }
    xml += "</xls:AOI>";
    return xml;
};



/**
 * @fileoverview ZoomController Class file.
 * deCarta confidential and proprietary.
 * Copyright 2006-2012 deCarta. All rights reserved.
 */
/**
 * @class The ZoomController object is primarily used to provide an interactive
 * zoom bar for instances of the {@link Map} class. Once added to a Map, the
 * ZoomController provides the user a graphical interface for zooming up or
 * down through the 17 different scale levels. Each zoom level is represented
 * by a particular, repeated image. The currently selected zoom level is
 * represented by another image. Any of the zoom levels can be clicked to zoom
 * to that scale instantaneously. The top of the zoom controller, when clicked,
 * performs an incremental zoom in, and is represented by yet another image.
 * The bottom of the zoom controller, when clicked, performs an incremental
 * zoom out, and is represented by a final image.
 * @description Construct a new ZoomController object. All of the arguments to this
 * constructor are optional. If you want to build a customized zoom control
 * override the defaults by passing in arguments.
 * @param {int} selected optional The starting zoom level, from 1 (zoomed in) to
 * 17 (zoomed out). Default is 5.
 * @param {String} color optional The background color. Note: leaving the color
 * null will result in a transparent background.
 * @param {String} checkedSrc optional URL to an image to be displayed when that
 * particular zoom level is displayed.
 * @param {String} uncheckedSrc optional URL to an image to be displayed for all
 * zoom levels when those zoom levels are not displayed.
 * @param {String} topSrc optional URL to an image to be displayed for the zoom
 * in button.
 * @param {String} bottomSrc optional URL to an image to be displayed for the
 * zoom out button.
 * @param {Object} opts optional Additional options
 * <pre>
 * {
 *      xMargin: 0, // x px from edge of map. default: 0.
 *      yMargin: 0, // y px from edge of map. default: 0.
 * }
 * </pre>
 * @throws Exception Throws an exception when an invalid starting zoom level is
 * passed in as the selected parameter.
 * @constructor
 * @see Map#addZoomController
 */
function ZoomController( selected, color, checkedSrc, uncheckedSrc, topSrc, bottomSrc, opts){
//function ZoomController( selected, color, pillarSrc, sliderSrc, topSrc, bootmSrc){

    

    /*if (typeof selected === 'object'){

    }*/

    /* Set up the options */
    if (!opts) opts = {};
    this.opts = {};

    /**
     * Takes an option object and applies it locally
     * @param {object} options.
     */
    this.setOpts = function(opts){
        this.opts.xMargin = (opts.xMargin) ? opts.xMargin : 0;
        this.opts.yMargin = (opts.yMargin) ? opts.yMargin : 0;
    }
    
    this.setOpts(opts);

    //   ************************************************** Constructor Checks and Public Fields
    /**
     * The current zoom level.
     * @type number
     * @default 5
     * @private
     */
    this.selected = selected || 5;
    // Passing in zero won't cause this to throw an error because 0 is illegal
    // but gets reset to the default of 5.
//    if ( isNaN(parseInt(this.selected)) || this.selected<0 || this.selected>17 ) {
//        throw new Exception("Error instantiating ZoomController, invalid initial" +
//            " value "+selected+".  The value must be between 1 and 17");
//        return false;
//    }


    /**
     * If false, than no HTML DOM view will be created for this ZoomController.
     * Treat this property as read only.
     * @type boolean
     * @default true
     * @private
     */
    this.domView = true;
    /**
     * Total number of zoom levels available.
     * @type number
     * @default 17
     * @private
     */
    this.zoomLevels = 17;
    /**
     * Zoom level min.
     * @type number
     * @default 1
     * @private
     */
    this.lowerBound = 1;
    /**
     * Zoom level max.
     * @type number
     * @default 17
     * @private
     */
    this.upperBound = 17;

    /**
     * Sets the background color of the ZoomController div. Pass in any valid
     * CSS color string.
     * @type string
     * @default ""
     * @private
     */
    this.color= color || ""; // clear

    /**
     * The src URL for the image to display for all zoom levels not currently
     * selected.
     * @type string
     * @default Credentials.zoomUnselectedIconPath
     * @private
     */
    this.uncheckedSrc = uncheckedSrc || Credentials.zoomUnselectedIconPath;

    /**
     * The src URL for the image to display for the currently selected zoom
     * level.
     * @type string
     * @default Credentials.zoomSelectedIconPath
     * @private
     */
    this.checkedSrc = checkedSrc || Credentials.zoomSelectedIconPath;

    /**
     *The src URL for image to display the pillar part of zoom controller
     */
    //this.pillarSrc = pillarSrc || Credentials.zoomPillarIconPath;

    /**
     *The src URL for slider on the zoom controller
     */
    //this.sliderSrc=sliderSrc || Credentiasl.zoomSliderIconPath;

    /**
     * The src URL for the image to display for the zoom out button.
     * @type string
     * @default Credentials.zoomOutIconPath
     * @private
     */
    this.bottomCapSrc = bottomSrc || Credentials.zoomOutIconPath;
    this.bottomCapSrc = Credentials.imgPath + "z2t_zoom_bottom_gray.png";
    /**
     * The src URL for the image to display for the zoom in button.
     * @type string
     * @default Credentials.zoomInIconPath
     * @private
     */
    this.topCapSrc = topSrc || Credentials.zoomInIconPath;
    this.topCapSrc = Credentials.imgPath + "z2t_zoom_top_gray.png";

    this.pillarSrc = Credentials.imgPath + "z2t_zoom_rail_gray.png";
    this.sliderSrc = Credentials.imgPath + "z2t_zoom_selected_gray.png";
    /**
     * Reference to the div elements representing this zoom controller.
     * @private
     * @deprecated 4.4.1 moves to a more generalized map control interface.
     * Please use the .frame field for DOM reference instead of this.
     */
    this.zoomer = null;

    /**
     * Pointer to associated map instance.
     * @private
     */
    this.map = null;
    /**
     * General identifcation for this map control. Part of the general map control
     * interface. Treat as a read-only property.
     * @type string
     * @default "ZoomController"
     * @private
     */
    this.type = "ZoomController";
    /**
     * The on page div containing this scaleBar.
     * @type DOM Element (div)
     * @default null
     * @private
     */
    this.frame = null;

    //   ************************************************** Private Fields
    var self = this;
    // Array of discrete zoom level button IMG elements
    //var _zoomButtons = new Array();
    // The zoom in zoom level button IMG element
    var _zoomTopCap = null;
    // The zoom out zoom level button IMG element
    var _zoomBottomCap = null;

    //The zoom slider for dragging zoom
    var _zoomPillar = null;
    var _zoomSlider = null;
    var _drag = false;
    var _isIE = Utilities.ie;

    // The Y distance in kilometers across the current tilegrid
    var _presentRadiusY; // set when initialized
    // The X distance in kilometers across the current tilegrid
    var _presentRadiusX; // set when initialized
    // Is the zoom controller hidden or not? Default is not hidden.
    // Only needed to allow the zoom controller to be hidden or shown before being
    // constructed.
    var _visible = true;


    //------------------------------------------------------ Public Methods

    /**
     * Set whether a zoom controller will have JSAPI created HTML DOM
     * representation on the map or not.
     * Call before passing the zoom controller to the map.
     * @para {boolean} [view=false] Pass true to built the ZoomController
     * on the map, false to prevent the jsapi from building the HTML DOM elements.
     * @private
     */
    this.setDomView = function(view) {
        view = (view) ? true : false;
        this.domView = view;
    };
    /**
     * Sets-up the zoom controller for use.
     * @private
     */
    this.initialize = function(){
        

        if (!this.domView) {
            return false;
        }

        // ************************* Setup the zoom in button
        _zoomTopCap = document.createElement("IMG");
        _zoomTopCap.id = "decarta-ztop";
        _zoomTopCap.src = this.topCapSrc;
        _zoomTopCap.className="decarta-zoomTop";
        _zoomTopCap.onclick = function(e){
            // Quick exit if events should be ignored
            if (!GLOBALS.ALLOWDOMEVENTS) {
                return true;
            }
            e = e||event;/* get IE event ( not passed ) */
            e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
            self.zoomInOneLevel();
            return true;
        };
        deCarta.IdManager.setTag( _zoomTopCap, "ignoreForMapEvents" );

        // *****************Setup the Pillar for sliding or clicking
        _zoomPillar=document.createElement('DIV');
        _zoomPillar.style.backgroundImage="url("+this.pillarSrc+")";
        _zoomPillar.style.backgroundRepeat="repeat-y";
        // this was causing problems with certain zoom ranges
        _zoomPillar.style.backgroundPosition="center";
        _zoomPillar.id="decarta-zpillar";
        _zoomPillar.className="decarta-zoomPillar";
        _zoomPillar.onclick = function(e){
            if (!GLOBALS.ALLOWDOMEVENTS) {
                return true;
            }
            e=e||event;
            e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
            var yRelPos=e.clientY-Utilities.getAbsoluteTop(_zoomPillar) + Utilities.getScrollTop();
            var totalHeight=parseInt(_zoomPillar.offsetHeight);
            var level=Math.round(yRelPos/totalHeight*(self.zoomLevels-1))+1;
            level += (self.lowerBound - 1);
            self.map.zoomMap(level);
            return true;
        };
        deCarta.IdManager.setTag( _zoomPillar, "ignoreForMapEvents" );

        // *************** Setup zoomSlider for dragging the zoom
        _zoomSlider=document.createElement("IMG");
        _zoomSlider.src=this.sliderSrc;
        _zoomSlider.className="decarta-zoomSlider";
        _zoomSlider.id="decarta-zslider";
        deCarta.IdManager.setTag( _zoomSlider, "ignoreForMapEvents" );
        _zoomSlider.onmousedown = function(e){
            if (!GLOBALS.ALLOWDOMEVENTS) {
                return true;
            }

            e = e ? e : window.event; /* get IE event ( not passed ) */
            e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
            // Eject on a right or middle button press.
            // !_isIE is good for Safari, Opera, FF and Chrome
            // Hate to admit it, but IE does the button ident better than
            // the others. Damn groupthink.
            if ((!_isIE && e.which == 3) || (_isIE && e.button == 2)) {
                
                return true;
            }
            if ((!_isIE && e.which == 2) || (_isIE && e.button == 4)) {
                // Middle click
                return true;
            }

            _drag=true;
            _zoomSlider.style.cursor="move";
            document.body.onmousemove = whileDraggingZoomSlider; // calls dragging
            document.body.onmouseup = endDragZoomSlider;
            return false;

        };
        _zoomPillar.appendChild(_zoomSlider);

        // ************************* Setup the zoom out button
        _zoomBottomCap = document.createElement("IMG");
        _zoomBottomCap.src=this.bottomCapSrc;
        _zoomBottomCap.id="decarta-zbottom";
        _zoomBottomCap.className="decarta-zoomBottom";
        _zoomBottomCap.onclick = function(e){
            // Quick exit if events should be ignored
            if (!GLOBALS.ALLOWDOMEVENTS) {
                return true;
            }
            e = e||event;/* get IE event ( not passed ) */
            e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;
            self.zoomOutOneLevel();
            return true;
        };
        deCarta.IdManager.setTag( _zoomBottomCap, "ignoreForMapEvents" );



        // ************************* Set-up the container for the Zoom buttons
        var zoomContainerId = "decarta-zoom";
        var zoomContainterClassName = zoomContainerId;
        self.frame = document.createElement("DIV");
        self.frame.id = zoomContainerId;
        self.frame.className = zoomContainterClassName;
        self.frame.innerHTML = "";
        if ( self.color ) {
            self.frame.style.backgroundColor = self.color;
        }
        deCarta.IdManager.setTag( self.frame, "ignoreForMapEvents" );

        // ************************* add zoom objects to DOM
        self.frame.appendChild(_zoomTopCap);
        self.frame.appendChild(_zoomPillar);
        self.frame.appendChild(_zoomBottomCap);

        // ************************* 4.4.1 Backwards compatibility
        this.zoomer = this.frame;

        // Default is shown, only change state if hidden
        if ( !_visible ) {
            this.frame.style.display = "none";
        }

        // ************************* Finally set the correct zoom level
        //this.setZoomLevel(self.selected);
        adjustPillarSize();
        return true;
    };


    function endDragZoomSlider(e){
        // Logging here causes too much noise. Manually turn on if needed.
        //
        document.body.onmousemove = null;
        document.body.onmouseup = null;
        _drag=false;
        _zoomSlider.style.cursor="default";
        e = e ? e : window.event;
        e.stoppropagation? e.stoppropagation() : e.cancelBubble = true;

        var yRelPos=e.clientY-Utilities.getAbsoluteTop(_zoomPillar) + Utilities.getScrollTop();
        var level=Math.round(yRelPos/_zoomPillar.offsetHeight*  (self.zoomLevels-1)  )+1;
        level+=(self.lowerBound-1);
        if(level<1) level=1;
        if(level>17) level=17;
        self.map.zoomMap(level);
        return false;
    }


    function whileDraggingZoomSlider( e ) {
        // Grab the correct event object
        e = e ? e : window.event;

        if(!_drag)
            return false;

        var boundingTop=_zoomSlider.offsetHeight/2;
        var boundingBottom=_zoomPillar.offsetHeight-_zoomSlider.offsetHeight/2;

        var yRelPos=e.clientY-Utilities.getAbsoluteTop(_zoomPillar) + Utilities.getScrollTop();
        if(yRelPos<=boundingBottom && yRelPos>=boundingTop){
            _zoomSlider.style.top=yRelPos-_zoomSlider.offsetHeight/2+"px";
        }
        return false;
    }





    /**
     * set a custom range for the zoom controller, the default is 1-17, the
     * range must be between 1-21, for instance (3,20), also note that you must
     * call this function on the zoom controller before adding the zoom
     * controller to the map.
     * @param {int} lower must be greater than zero
     * @param {int} upper must be less than 22
     */
    this.setZoomRange = function(lower,upper){
        

        if(lower<1 || upper>21 || lower>upper){
            throw new Exception("illegal values setZoomRange: "+lower+", "+upper);
        }
        if(self.selected>upper)
            self.selected=upper;
        if(self.selected<lower)
            self.selected=lower;
        self.lowerBound=lower;
        self.upperBound=upper;
        self.zoomLevels=upper-lower+1;
        adjustPillarSize();
    };
    /**
     * A quick way to change the reference to the img src attributes for the
     * zoom controller buttons. This effectively changes the images on the fly.
     * @param {string} checked optional Sets the zoom level image source for when
     * the zoom level is selected.
     * @param {string} unchecked optional Sets the zoom level image source for
     * when the zoom level is not selected.
     * @param {string} topSrc optional Sets the image source for the zoom in
     * button.
     * @param {string} bottomSrc optional Sets the image source for the zoom
     * out button.
     */
    this.setZoomButtonImages = function( checked, unchecked, topSrc, bottomSrc ){
        

        // Reset the new zoom level buttons
        if ( checked ) {
            this.checkedSrc = checked;
        }
        if ( unchecked ) {
            this.uncheckedSrc = unchecked;
        }
        // Only reset if one or the other zoom button got an image source
        if ( checked || unchecked ) {
            for(var i=0; i<_zoomButtons.length; i++){
                _zoomButtons[i].src = this.uncheckedSrc;
            }
            if ( self.selected ) {
                _zoomButtons[self.selected-1].src = this.checkedSrc;
            }
        }
        // Reset the zoom in button
        if ( topSrc ) {
            this.topCapSrc = topSrc;
            _zoomTopCap.src = topSrc;
        }
        // Reset the zoom out button
        if ( bottomSrc ) {
            this.bottomCapSrc = bottomSrc;
            _zoomBottomCap.src = bottomSrc;
        }
    };

    /**
     * Change the background color for the div containing the ZoomController.
     * @param {String} newColor Any color, formatted as a CSS color value,
     * acceptable by the browser will work. Example, 'WHITE' or '#FFFFFF' or
     * 'rgb(255,255,255)'. Passing in null will set the background transparent.
     */
    this.setColor = function(newColor){
        
        this.frame.style.backgroundColor=newColor;
    }

    /**
     * Shows the ZoomController on a Map, the default.
     * @see ZoomController#hide
     */
    this.show = function(){
        
        _visible = true;
        if (this.frame) {
            this.frame.style.display="block";
        }
    };
    /**
     * Hides the zoomController from view.
     * @see ZoomController#show
     */
    this.hide = function(){
        
        _visible = false;
        if (this.frame) {
            this.frame.style.display="none";
        }
    };

    /**
     * Returns the current Y radius, in kilometers, for attached Map object.
     * @return {float} The current Y radius is in units kilometer and is not a
     * Radius object.
     */
    this.getRadius = function(){
        
        return _presentRadiusY;
    }
    /**
     * Set both the X radius and the Y radius of the zoom controller for the
     * attached map object.
     * @private
     */
    this.setRadius = function(r) {
        
        _presentRadiusX = r;
        //4.2.4
        // since there are now non-square grids I need to set the radius both X & Y
        var grid = self.map.getGridSize().split(" ");
        var y = grid[0];
        var x = grid[1];
        if(y == x){
            _presentRadiusY = r;
        }else{
            _presentRadiusY = ( _presentRadiusX / x ) * y;
        }
    }


    /**
     * Returns the current X radius, in kilometers, for attached Map object.
     * @return {float} The current X radius is in units kilometer and is not a
     * Radius object.
     */
    this.getRadiusX = function(){
        
        return _presentRadiusX;
    }
    /**
     * Sets the horizontal radius value for this zoom controller at this zoom
     * level for the current tilegrid.
     * @private
     */
    this.setRadiusX = function(r){
        
        _presentRadiusX = r;
    }

    /**
     * Returns the smaller of the X and Y radii for the viewable screen area
     * which is useful for framing search results to the screen.
     * @return {float} The min radius
     * Radius object.
	 * @see SearchCriteria.html#radius
     */
    this.getMinViewableRadius = function(){
        
        var grid = self.map.getGridSize().split(" ");
        var outerY = grid[0]*GLOBALS.DEFAULT_MAP_TILE_SIZE;
        var outerX = grid[1]*GLOBALS.DEFAULT_MAP_TILE_SIZE;
        var innerX=parseInt(self.map.mapDiv.style.width);
        var innerY=parseInt(self.map.mapDiv.style.height);
        var innerRadiusX = ( innerX / outerX ) * _presentRadiusX;
        var innerRadiusY = ( innerY / outerY ) * _presentRadiusY;
        return innerRadiusY<innerRadiusX ? innerRadiusY : innerRadiusX;
    }

    /**
     * Returns the bigger of the X and Y radii for the viewable screen area
     * which is useful for framing search results to the screen.
     * @return {float} The min radius
     * Radius object.
	 * @see SearchCriteria.html#radius
     */
    this.getMaxViewableRadius = function(){
        
        var grid = self.map.getGridSize().split(" ");
        var outerY = grid[0]*GLOBALS.DEFAULT_MAP_TILE_SIZE;
        var outerX = grid[1]*GLOBALS.DEFAULT_MAP_TILE_SIZE;
        var innerX=parseInt(self.map.mapDiv.style.width);
        var innerY=parseInt(self.map.mapDiv.style.height);
        var innerRadiusX = ( innerX / outerX ) * _presentRadiusX;
        var innerRadiusY = ( innerY / outerY ) * _presentRadiusY;
        return innerRadiusY>innerRadiusX ? innerRadiusY : innerRadiusX;
    }

    /**
     * Returns the larger of the X and Y radius.
     * @return {float} The max radius
     * Radius object.
     */
    this.getMaxRadius = function(){
        
        return _presentRadiusX<_presentRadiusY ? _presentRadiusY : _presentRadiusX;
    }


    /**
	 * Retrieve the present zoom level (1 to 17) of the associated Map. To set a
     * new zoom level, use {@link ZoomController#setZoomLevel}.
	 * @returns {int} The current zoom level.
	 * @see ZoomController#setZoomLevel
     */
    this.getZoomLevel = function(){
        
        return self.selected;
    }
    /**
     * Sets the zoom level of the associated map prior to a map reset, such
     * as a call to Map.centerOnPosition.
     * @param {number} level required The new zoom level.
     * @deprecated use the setZoomLevel method
     * @see ZoomController#setZoomLevel
     */
    this.setZoomValue = function( level ) {
        
        // Forward to current function.
        this.setZoomLevel( level );
    }

    /**
	 * Set the ZoomController to a new, specific zoom level. Note: This will
     * move zoom level displayed by the ZoomController, but it does not zoom the
     * associated view of the Map. To automatically zoom the associated Map to a
     * new level, use {@link ZoomController#zoomToNewLevel} or
     * {@link Map#reDrawMap}.
	 * @param {int} level required The new zoom level, from 1 (zoomed in) to 17
     * (zoomed out).
	 * @throws {Exception} Throws an exception when an invalid starting zoom
     * level is passed in as the selected parameter.
	 * @see ZoomController#zoomToNewLevel
	 * @see Map#reDrawMap
     */
    this.setZoomLevel = function(level){
        
        if(level && level<self.lowerBound || level>self.upperBound){
            throw new Exception("Error calling setZoomLevel, out of range");
            return false;
        }
        self.selected = level;
        if(_zoomSlider && _zoomSlider.style){
            var pillarHeight=parseInt(_zoomPillar.offsetHeight);
            var sliderHeight=parseInt(_zoomSlider.offsetHeight);
            level=level-(self.lowerBound-1);
            _zoomSlider.style.top=(level-1/2)*pillarHeight/self.zoomLevels-1/2*sliderHeight+"px";
            _zoomPillar.removeChild(_zoomSlider);
            _zoomPillar.appendChild(_zoomSlider);
        }


    }

    /**
     * Return a converted zoom level to be used when determining Mercator
     * Pixel calculations.
     * @private
     */
    this.getGXConvertedZoomLevel = function(){
        
        return Math.abs(21-self.selected);
    }




    /**
	  Set the ZoomController, and the associated Map, to a new, specific zoom level.
	  @param {int} level required The new zoom level, from 1 (zoomed in) to 17 (zoomed out).
	  @throws {Exception} Throws an exception when an invalid starting zoom level is passed in as the selected parameter.
     */
    this.zoomToNewLevel = function(level){
        
        if(level && level<self.lowerBound || level>self.upperBound){
            throw new Exception("Error calling zoomToNewLevel, out of range");
            return false;
        }
        self.map.zoomMap(level);
    }


    /**
	  Decrements zoom level by one and zooms the associated map in.
     */
    this.zoomInOneLevel = function(){
        
        if(self.selected <= self.lowerBound){
            return false;
        }
        self.map.zoomMap(parseInt(self.selected)-1);
    }

    /**
	  Increments zoom level by one and zooms the associated map out.
     */
    this.zoomOutOneLevel = function(){
        
        if(self.selected==self.upperBound){
            return false;
        }
        self.map.zoomMap(parseInt(self.selected)+1);
    }


    /**
     * Returns the zoom level that best fits a given BoundingBox within the
     * viewable area of the map. Note: this just returns the zoom level. To
     * display the area contained by the BoundingBox, the Map needs to be
     * recentered and the new zoom level must be set.
     * @param {BoundingBox} boundingBox required The rectangle representing the
     * area to be displayed in the associated Map.
     * @return {int} The new zoom level.
     * @see ZoomController#zoomToNewLevel
     * @see Map#centerOnPosition
     */
    this.getZoomLevelToFitBoundingBox = function(boundingBox){
        
        var tmpY = parseInt(self.map.mapDiv.style.height)/2;
        var tmpX = parseInt(self.map.mapDiv.style.width)/2;

        for(var gxZoom=20; gxZoom>0; --gxZoom){

            var scale =  Utilities.radsPerPixelAtZoom(this.map.getTileSize(), gxZoom);

            var pixelsY = Utilities.lat2pix(boundingBox.getCenterPosition().getLat(), scale);
            var pixelsX = Utilities.lon2pix(boundingBox.getCenterPosition().getLon(), scale);

            var maxlat = Utilities.pix2lat(pixelsY+tmpY, scale);
            var maxlon = Utilities.pix2lon(pixelsX+tmpX, scale);

            var minlat = Utilities.pix2lat(pixelsY-tmpY, scale);
            var minlon = Utilities.pix2lon(pixelsX-tmpX, scale);

            var gxbbox = new BoundingBox(new Position(minlat,minlon),new Position(maxlat,maxlon));

            if(gxbbox.contains(boundingBox.minPosition) && gxbbox.contains(boundingBox.maxPosition)) {
                var fit = Math.abs(21-gxZoom);
                fit = (fit<self.lowerBound ? self.lowerBound : fit);
                return fit;
                break;
            }
        }
    };

    /**
     * Returns the zoom level that best fits a given array of Positions within
     * the viewable area of the map. Note: this just returns the zoom level. To
     * display the area contained surrounding the positions, the Map needs to be
     * recentered and the new zoom level must be set.
     * @param {Array} positions required Array of Position types representing
     * the area to be displayed in the associated Map.
     * @return {int} The new zoom level.
     * @see Utilities#positionsToBoundingBox
     * @see BoundingBox#getCenterPosition
     * @see ZoomController#zoomToNewLevel
     * @see Map#centerOnPosition
     */
    this.getZoomLevelToFitPositions = function(positions){
        
        var bbox = Utilities.positionsToBoundingBox(positions);
        return self.getZoomLevelToFitBoundingBox(bbox);
    };

    /**
     * Returns the zoom level that best fits a given array of Pins within
     * the viewable area of the map. Pins need only be created and not need
     * be added to the map. Note: this just returns the zoom level. To
     * display the area contained surrounding the positions, the Map needs to be
     * recentered and the new zoom level must be set.
     * @param {Array} pins required Array of Pin types representing
     * the area to be displayed in the associated Map.
     * @return {int} The new zoom level.
     * @see Utilities#pinsToBoundingBox
     * @see BoundingBox#getCenterPosition
     * @see ZoomController#zoomToNewLevel
     * @see Map#centerOnPosition
     */
    this.getZoomLevelToFitPins = function( pins ) {
        
        // To make sure this function actually works, we need to perform
        // a two step process.
        // First estimate out an approximate zoom level for the positions
        // of the pins. Let the error handling happen in the lower level
        // functions.
        var positions = [];
        for( var i = 0; i < pins.length; i++ ) {
            positions[i] = pins[i].position.clone();
        }
        var bbox = Utilities.positionsToBoundingBox( positions );
        var approximateZoom = self.getZoomLevelToFitBoundingBox( bbox );
        var approximateScale = Utilities.radsPerPixelAtZoom( self.map.getTileSize(), Math.abs(21-approximateZoom) );
        // Zoom level is required to make an approximation of coordinates using
        // pixel based offsets
        bbox = Utilities.pinsToBoundingBox( pins, approximateScale );
        // Now we can return the zoom level adjusted for icon size
        return self.getZoomLevelToFitBoundingBox( bbox );
    };


    /*
     *  Returns the a valid zoom level based on the bounds
     *  @param (int) zoom level to check
     *  @return (int) valid zoom level
     **/
    this.getClosestValidLevel = function(val){
        if (val < this.lowerBound) return this.lowerBound;
        if (val > this.upperBound) return this.upperBound;
        return val;
    };


    //-------------------------------------------------------- map control interface
    /**
     * Interface used by the Map to grab the correct DOM object to append to the
     * page.
     * @returns {DOM Element|null} The DOM element representation of the ZoomController
     * that should be appended to the map object, or null if there is nothing
     * to append.
     * @private
     */
    this.appendThis = function() {
        
        // Lazy create the frame
        if (!this.frame) {
            this.initialize();
        }
        // If we still don't have something
        var element = this.frame || null;
        return element;
    };

    /**
     * Interface for the Map object to remove the ScaleBar from the DOM.
     * @returns {DOM Element} The DOM element representation of the ScaleBar that
     * should be removed from the map object.
     * @private
     */
    this.removeThis = function() {
        
        this.map = null;

        //@todo add any cleanup to this function, should we wish to.

        return this.frame;
    };

    /**
     * Repositions the ZoomController relative to the associated Map instance.
     * To be called after the CopyrightMessage has been associated with a Map
     * and usually only needed when the Map has been resized. Part of the general
     * map control interface.
     * @param {DOMDimensions} ddim required Dimenions of map against which to
     * position this control.
     * @private
     */
    this.position = function( ddim ) {
        
        if ( !this.map ) {
            return;
        }
        // Attach to the upper left. We don't actually use the dimensions
        // object

        if (this.frame) {
            switch (this.opts.screenPosition) {
                default:                
                    if(this.map.getPanController()){
                        this.frame.style.top= 61 + this.opts.yMargin + "px"
                        this.frame.style.left= 21 + this.opts.xMargin + "px"
                    } else {
                        this.frame.style.top = "10px";
                        this.frame.style.left = "10px";
                    }
                break;
                case 'topRight':
                    throw('Not Implemented');
                break;
            }

            //we can only get the pillar height after we appended it to DOM, so instead of set slider position
            //in initialize function, we can set the position here.
            this.setZoomLevel(self.selected);
        }
    };

    //-------------------------------------------------------- Inner Methods

    function adjustPillarSize(){
        if(self.frame){
            _zoomPillar.style.height=(self.zoomLevels*10)+"px";
            _zoomBottomCap.style.top=((self.zoomLevels*10)+20)+"px";
        }
    }
} /* end ZoomController class and constructor */

deCarta.Mobile = {};
deCarta.Mobile.Exception = {};
deCarta.Mobile.Exception.raise = function() {};
